<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CustomImportOrderCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.imports</a> &gt; <span class="el_source">CustomImportOrderCheck.java</span></div><h1>CustomImportOrderCheck.java</h1><pre class="source lang-java linenums">///////////////////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code and other text files for adherence to a set of rules.
// Copyright (C) 2001-2022 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
///////////////////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.imports;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

/**
 * &lt;p&gt;
 * Checks that the groups of import declarations appear in the order specified
 * by the user. If there is an import but its group is not specified in the
 * configuration such an import should be placed at the end of the import list.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The rule consists of:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;
 * STATIC group. This group sets the ordering of static imports.
 * &lt;/li&gt;
 * &lt;li&gt;
 * SAME_PACKAGE(n) group. This group sets the ordering of the same package imports.
 * Imports are considered on SAME_PACKAGE group if &lt;b&gt;n&lt;/b&gt; first domains in package
 * name and import name are identical:
 * &lt;pre&gt;
 * package java.util.concurrent.locks;
 *
 * import java.io.File;
 * import java.util.*; //#1
 * import java.util.List; //#2
 * import java.util.StringTokenizer; //#3
 * import java.util.concurrent.*; //#4
 * import java.util.concurrent.AbstractExecutorService; //#5
 * import java.util.concurrent.locks.LockSupport; //#6
 * import java.util.regex.Pattern; //#7
 * import java.util.regex.Matcher; //#8
 * &lt;/pre&gt;
 * If we have SAME_PACKAGE(3) on configuration file, imports #4-6 will be considered as
 * a SAME_PACKAGE group (java.util.concurrent.*, java.util.concurrent.AbstractExecutorService,
 * java.util.concurrent.locks.LockSupport). SAME_PACKAGE(2) will include #1-8.
 * SAME_PACKAGE(4) will include only #6. SAME_PACKAGE(5) will result in no imports assigned
 * to SAME_PACKAGE group because actual package java.util.concurrent.locks has only 4 domains.
 * &lt;/li&gt;
 * &lt;li&gt;
 * THIRD_PARTY_PACKAGE group. This group sets ordering of third party imports.
 * Third party imports are all imports except STATIC, SAME_PACKAGE(n), STANDARD_JAVA_PACKAGE and
 * SPECIAL_IMPORTS.
 * &lt;/li&gt;
 * &lt;li&gt;
 * STANDARD_JAVA_PACKAGE group. By default, this group sets ordering of standard java/javax imports.
 * &lt;/li&gt;
 * &lt;li&gt;
 * SPECIAL_IMPORTS group. This group may contain some imports that have particular meaning for the
 * user.
 * &lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * Use the separator '###' between rules.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
 * thirdPartyPackageRegExp and standardPackageRegExp options.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Pretty often one import can match more than one group. For example, static import from standard
 * package or regular expressions are configured to allow one import match multiple groups.
 * In this case, group will be assigned according to priorities:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;
 * STATIC has top priority
 * &lt;/li&gt;
 * &lt;li&gt;
 * SAME_PACKAGE has second priority
 * &lt;/li&gt;
 * &lt;li&gt;
 * STANDARD_JAVA_PACKAGE and SPECIAL_IMPORTS will compete using &quot;best match&quot; rule: longer
 * matching substring wins; in case of the same length, lower position of matching substring
 * wins; if position is the same, order of rules in configuration solves the puzzle.
 * &lt;/li&gt;
 * &lt;li&gt;
 * THIRD_PARTY has the least priority
 * &lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * Few examples to illustrate &quot;best match&quot;:
 * &lt;/p&gt;
 * &lt;p&gt;
 * 1. patterns STANDARD_JAVA_PACKAGE = &quot;Check&quot;, SPECIAL_IMPORTS=&quot;ImportOrderCheck&quot; and input file:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck;
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Result: imports will be assigned to SPECIAL_IMPORTS, because matching substring length is 16.
 * Matching substring for STANDARD_JAVA_PACKAGE is 5.
 * &lt;/p&gt;
 * &lt;p&gt;
 * 2. patterns STANDARD_JAVA_PACKAGE = &quot;Check&quot;, SPECIAL_IMPORTS=&quot;Avoid&quot; and file:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * import com.puppycrawl.tools.checkstyle.checks.imports.AvoidStarImportCheck;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Result: import will be assigned to SPECIAL_IMPORTS. Matching substring length is 5 for both
 * patterns. However, &quot;Avoid&quot; position is lower than &quot;Check&quot; position.
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * Property {@code customImportOrderRules} - Specify format of order declaration
 * customizing by user.
 * Type is {@code java.lang.String}.
 * Default value is {@code &quot;&quot;}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code standardPackageRegExp} - Specify RegExp for STANDARD_JAVA_PACKAGE group imports.
 * Type is {@code java.util.regex.Pattern}.
 * Default value is {@code &quot;^(java|javax)\.&quot;}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code thirdPartyPackageRegExp} - Specify RegExp for THIRD_PARTY_PACKAGE group imports.
 * Type is {@code java.util.regex.Pattern}.
 * Default value is {@code &quot;.*&quot;}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code specialImportsRegExp} - Specify RegExp for SPECIAL_IMPORTS group imports.
 * Type is {@code java.util.regex.Pattern}.
 * Default value is {@code &quot;^$&quot;}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code separateLineBetweenGroups} - Force empty line separator between
 * import groups.
 * Type is {@code boolean}.
 * Default value is {@code true}.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Property {@code sortImportsInGroupAlphabetically} - Force grouping alphabetically,
 * in &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Order&quot;&gt;ASCII sort order&lt;/a&gt;.
 * Type is {@code boolean}.
 * Default value is {@code false}.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 *     To configure the check :
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;/&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 * import org.apache.commons.io.FileUtils; // OK
 * import static java.util.*; // OK
 * import java.time.*; // OK
 * import static java.io.*; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check so that it checks in the order
 * (static imports,standard java packages,third party package):
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import static java.io.*; // violation as static imports should be in top
 *
 * import org.apache.commons.io.FileUtils; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check such that only java packages are included in standard java packages
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;standardPackageRegExp&amp;quot; value=&amp;quot;^java\.&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // violation as it is not included in standard java package group.
 *
 * import org.apache.commons.io.FileUtils; // violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to include only &quot;com&quot; packages as third party group imports:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;thirdPartyPackageRegExp&amp;quot; value=&amp;quot;^com\.&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 *
 * import org.apache.commons.io.FileUtils; // violation(should be in end)
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check to force some packages in special import group:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###SPECIAL_IMPORTS###STANDARD_JAVA_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^org\.&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // OK
 *
 * import org.json.JSONObject; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 *
 * import org.apache.commons.io.FileUtils; // violation
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check such that empty line separator between two groups is enabled:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^org\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;thirdPartyPackageRegExp&amp;quot; value=&amp;quot;^com\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;separateLineBetweenGroups&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import org.apache.commons.io.FileUtils; // violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check such that import groups are forced to be sorted alphabetically:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^org\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;thirdPartyPackageRegExp&amp;quot; value=&amp;quot;^com\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;separateLineBetweenGroups&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;sortImportsInGroupAlphabetically&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // Violation since it should come before&quot;java.util&quot;
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import org.apache.commons.io.FileUtils; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check so that it matches default Eclipse formatter configuration
 * (tested on Kepler and Luna releases):
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * group of static imports is on the top
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups of non-static imports: &quot;java&quot; and &quot;javax&quot; packages first, then &quot;org&quot; and then all other
 * imports
 * &lt;/li&gt;
 * &lt;li&gt;
 * imports will be sorted in the groups
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups are separated by single blank line
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Notes:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * &quot;com&quot; package is not mentioned on configuration, because it is ignored by Eclipse Kepler and Luna
 * (looks like Eclipse defect)
 * &lt;/li&gt;
 * &lt;li&gt;
 * configuration below doesn't work in all 100% cases due to inconsistent behavior prior to Mars
 * release, but covers most scenarios
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^org\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;sortImportsInGroupAlphabetically&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;separateLineBetweenGroups&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.util.*; // OK
 * import static java.io.*; // Violation since it should come before&quot;java.util&quot;
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import org.apache.commons.io.FileUtils; // Violation should be separated by space
 *
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check so that it matches default Eclipse formatter configuration
 * (tested on Mars release):
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * group of static imports is on the top
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups of non-static imports: &quot;java&quot; and &quot;javax&quot; packages first, then &quot;org&quot; and &quot;com&quot;,
 * then all other imports as one group
 * &lt;/li&gt;
 * &lt;li&gt;
 * imports will be sorted in the groups
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups are separated by one blank line
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###STANDARD_JAVA_PACKAGE###SPECIAL_IMPORTS###THIRD_PARTY_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^org\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;thirdPartyPackageRegExp&amp;quot; value=&amp;quot;^com\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;sortImportsInGroupAlphabetically&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;separateLineBetweenGroups&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.io.*; // OK
 * import static java.util.*; // OK
 *
 * import java.time.*; // OK
 * import javax.net.*; // OK
 *
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // Violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // Violation
 *
 * import org.apache.commons.io.FileUtils;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check so that it matches default IntelliJ IDEA formatter configuration
 * (tested on v14):
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * group of static imports is on the bottom
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups of non-static imports: all imports except of &quot;javax&quot; and &quot;java&quot;, then &quot;javax&quot; and &quot;java&quot;
 * &lt;/li&gt;
 * &lt;li&gt;
 * imports will be sorted in the groups
 * &lt;/li&gt;
 * &lt;li&gt;
 * groups are separated by one blank line
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Note: &quot;separated&quot; option is disabled because IDEA default has blank line between &quot;java&quot; and
 * static imports, and no blank line between &quot;javax&quot; and &quot;java&quot;
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&quot;CustomImportOrder&quot;&amp;gt;
 *   &amp;lt;property name=&quot;customImportOrderRules&quot;
 *     value=&quot;THIRD_PARTY_PACKAGE###SPECIAL_IMPORTS###STANDARD_JAVA_PACKAGE###STATIC&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;specialImportsRegExp&quot; value=&quot;^javax\.&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;standardPackageRegExp&quot; value=&quot;^java\.&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&amp;gt;
 *   &amp;lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;false&quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.io.*; // OK
 * import static java.util.*; // OK
 *
 * import java.time.*; // violation should be in standard package group
 *                    // below special import
 *
 * import javax.net.*; // Violation should be in special import group
 *
 * import org.apache.commons.io.FileUtils; // Violation should be in
 *                                        // THIRD PARTY PACKAGE GROUP
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // Violation
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // Violation
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To configure the check so that it matches default NetBeans formatter configuration
 * (tested on v8):
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * groups of non-static imports are not defined, all imports will be sorted as a one group
 * &lt;/li&gt;
 * &lt;li&gt;
 * static imports are not separated, they will be sorted along with other imports
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;/&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.io.*; // OK
 * import static java.util.*; // OK
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 *
 * import org.apache.commons.io.FileUtils; // should not be separated by line
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To set RegExps for THIRD_PARTY_PACKAGE and STANDARD_JAVA_PACKAGE groups use
 * thirdPartyPackageRegExp and standardPackageRegExp options.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;STATIC###SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STANDARD_JAVA_PACKAGE&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;thirdPartyPackageRegExp&amp;quot; value=&amp;quot;^(com|org)\.&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;standardPackageRegExp&amp;quot; value=&amp;quot;^(java|javax)\.&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.io.*; // OK
 * import static java.util.*; // OK
 * import java.time.*; // violation
 * import javax.net.*; // violation
 *
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * import org.apache.commons.io.FileUtils; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Also, this check can be configured to force empty line separator between
 * import groups. For example.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;separateLineBetweenGroups&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.company;
 *
 * import static java.io.*; // OK
 * import static java.util.*; // OK
 * import java.time.*; // OK
 * import javax.net.*; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck; // OK
 * import com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck; // OK
 * import org.apache.commons.io.FileUtils; // OK
 * &lt;/pre&gt;
 * &lt;p&gt;
 * It is possible to enforce
 * &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Order&quot;&gt;ASCII sort order&lt;/a&gt;
 * of imports in groups using the following configuration:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;sortImportsInGroupAlphabetically&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Example of ASCII order:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * import java.awt.Dialog;
 * import java.awt.Window;
 * import java.awt.color.ColorSpace;
 * import java.awt.Frame; // violation here - in ASCII order 'F' should go before 'c',
 *                        // as all uppercase come before lowercase letters
 * &lt;/pre&gt;
 * &lt;p&gt;
 * To force checking imports sequence such as:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * package com.puppycrawl.tools.checkstyle.imports;
 *
 * import com.google.common.annotations.GwtCompatible;
 * import com.google.common.annotations.Beta;
 * import com.google.common.annotations.VisibleForTesting;
 *
 * import org.abego.treelayout.Configuration;
 *
 * import static sun.tools.util.ModifierFilter.ALL_ACCESS;
 *
 * import com.google.common.annotations.GwtCompatible; // violation here - should be in the
 *                                                     // THIRD_PARTY_PACKAGE group
 * import android.*;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * configure as follows:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;CustomImportOrder&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;customImportOrderRules&amp;quot;
 *     value=&amp;quot;SAME_PACKAGE(3)###THIRD_PARTY_PACKAGE###STATIC###SPECIAL_IMPORTS&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;specialImportsRegExp&amp;quot; value=&amp;quot;^android\.&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}
 * &lt;/p&gt;
 * &lt;p&gt;
 * Violation Message Keys:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * {@code custom.import.order}
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@code custom.import.order.lex}
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@code custom.import.order.line.separator}
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@code custom.import.order.nonGroup.expected}
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@code custom.import.order.nonGroup.import}
 * &lt;/li&gt;
 * &lt;li&gt;
 * {@code custom.import.order.separated.internally}
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since 5.8
 */
@FileStatefulCheck
<span class="fc" id="L660">public class CustomImportOrderCheck extends AbstractCheck {</span>

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_LINE_SEPARATOR = &quot;custom.import.order.line.separator&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_SEPARATED_IN_GROUP = &quot;custom.import.order.separated.internally&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_LEX = &quot;custom.import.order.lex&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_NONGROUP_IMPORT = &quot;custom.import.order.nonGroup.import&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_NONGROUP_EXPECTED = &quot;custom.import.order.nonGroup.expected&quot;;

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_ORDER = &quot;custom.import.order&quot;;

    /** STATIC group name. */
    public static final String STATIC_RULE_GROUP = &quot;STATIC&quot;;

    /** SAME_PACKAGE group name. */
    public static final String SAME_PACKAGE_RULE_GROUP = &quot;SAME_PACKAGE&quot;;

    /** THIRD_PARTY_PACKAGE group name. */
    public static final String THIRD_PARTY_PACKAGE_RULE_GROUP = &quot;THIRD_PARTY_PACKAGE&quot;;

    /** STANDARD_JAVA_PACKAGE group name. */
    public static final String STANDARD_JAVA_PACKAGE_RULE_GROUP = &quot;STANDARD_JAVA_PACKAGE&quot;;

    /** SPECIAL_IMPORTS group name. */
    public static final String SPECIAL_IMPORTS_RULE_GROUP = &quot;SPECIAL_IMPORTS&quot;;

    /** NON_GROUP group name. */
    private static final String NON_GROUP_RULE_GROUP = &quot;NOT_ASSIGNED_TO_ANY_GROUP&quot;;

    /** Pattern used to separate groups of imports. */
<span class="fc" id="L717">    private static final Pattern GROUP_SEPARATOR_PATTERN = Pattern.compile(&quot;\\s*###\\s*&quot;);</span>

    /** Processed list of import order rules. */
<span class="fc" id="L720">    private final List&lt;String&gt; customOrderRules = new ArrayList&lt;&gt;();</span>

    /** Contains objects with import attributes. */
<span class="fc" id="L723">    private final List&lt;ImportDetails&gt; importToGroupList = new ArrayList&lt;&gt;();</span>

    /** Specify format of order declaration customizing by user. */
<span class="fc" id="L726">    private String customImportOrderRules = &quot;&quot;;</span>

    /** Specify RegExp for SAME_PACKAGE group imports. */
<span class="fc" id="L729">    private String samePackageDomainsRegExp = &quot;&quot;;</span>

    /** Specify RegExp for STANDARD_JAVA_PACKAGE group imports. */
<span class="fc" id="L732">    private Pattern standardPackageRegExp = Pattern.compile(&quot;^(java|javax)\\.&quot;);</span>

    /** Specify RegExp for THIRD_PARTY_PACKAGE group imports. */
<span class="fc" id="L735">    private Pattern thirdPartyPackageRegExp = Pattern.compile(&quot;.*&quot;);</span>

    /** Specify RegExp for SPECIAL_IMPORTS group imports. */
<span class="fc" id="L738">    private Pattern specialImportsRegExp = Pattern.compile(&quot;^$&quot;);</span>

    /** Force empty line separator between import groups. */
<span class="fc" id="L741">    private boolean separateLineBetweenGroups = true;</span>

    /**
     * Force grouping alphabetically,
     * in &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Order&quot;&gt; ASCII sort order&lt;/a&gt;.
     */
    private boolean sortImportsInGroupAlphabetically;

    /** Number of first domains for SAME_PACKAGE group. */
<span class="fc" id="L750">    private int samePackageMatchingDepth = 2;</span>

    /**
     * Setter to specify RegExp for STANDARD_JAVA_PACKAGE group imports.
     *
     * @param regexp
     *        user value.
     */
    public final void setStandardPackageRegExp(Pattern regexp) {
<span class="fc" id="L759">        standardPackageRegExp = regexp;</span>
<span class="fc" id="L760">    }</span>

    /**
     * Setter to specify RegExp for THIRD_PARTY_PACKAGE group imports.
     *
     * @param regexp
     *        user value.
     */
    public final void setThirdPartyPackageRegExp(Pattern regexp) {
<span class="fc" id="L769">        thirdPartyPackageRegExp = regexp;</span>
<span class="fc" id="L770">    }</span>

    /**
     * Setter to specify RegExp for SPECIAL_IMPORTS group imports.
     *
     * @param regexp
     *        user value.
     */
    public final void setSpecialImportsRegExp(Pattern regexp) {
<span class="fc" id="L779">        specialImportsRegExp = regexp;</span>
<span class="fc" id="L780">    }</span>

    /**
     * Setter to force empty line separator between import groups.
     *
     * @param value
     *        user value.
     */
    public final void setSeparateLineBetweenGroups(boolean value) {
<span class="fc" id="L789">        separateLineBetweenGroups = value;</span>
<span class="fc" id="L790">    }</span>

    /**
     * Setter to force grouping alphabetically, in
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Order&quot;&gt;ASCII sort order&lt;/a&gt;.
     *
     * @param value
     *        user value.
     */
    public final void setSortImportsInGroupAlphabetically(boolean value) {
<span class="fc" id="L800">        sortImportsInGroupAlphabetically = value;</span>
<span class="fc" id="L801">    }</span>

    /**
     * Setter to specify format of order declaration customizing by user.
     *
     * @param inputCustomImportOrder
     *        user value.
     */
    public final void setCustomImportOrderRules(final String inputCustomImportOrder) {
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (!customImportOrderRules.equals(inputCustomImportOrder)) {</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            for (String currentState : GROUP_SEPARATOR_PATTERN.split(inputCustomImportOrder)) {</span>
<span class="fc" id="L812">                addRulesToList(currentState);</span>
            }
<span class="fc" id="L814">            customOrderRules.add(NON_GROUP_RULE_GROUP);</span>
        }
<span class="fc" id="L816">        customImportOrderRules = inputCustomImportOrder;</span>
<span class="fc" id="L817">    }</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L821">        return getRequiredTokens();</span>
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L826">        return getRequiredTokens();</span>
    }

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L831">        return new int[] {</span>
            TokenTypes.IMPORT,
            TokenTypes.STATIC_IMPORT,
            TokenTypes.PACKAGE_DEF,
        };
    }

    @Override
    public void beginTree(DetailAST rootAST) {
<span class="fc" id="L840">        importToGroupList.clear();</span>
<span class="fc" id="L841">    }</span>

    @Override
    public void visitToken(DetailAST ast) {
<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (ast.getType() == TokenTypes.PACKAGE_DEF) {</span>
<span class="fc" id="L846">            samePackageDomainsRegExp = createSamePackageRegexp(</span>
                    samePackageMatchingDepth, ast);
        }
        else {
<span class="fc" id="L850">            final String importFullPath = getFullImportIdent(ast);</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">            final boolean isStatic = ast.getType() == TokenTypes.STATIC_IMPORT;</span>
<span class="fc" id="L852">            importToGroupList.add(new ImportDetails(importFullPath,</span>
<span class="fc" id="L853">                    getImportGroup(isStatic, importFullPath), isStatic, ast));</span>
        }
<span class="fc" id="L855">    }</span>

    @Override
    public void finishTree(DetailAST rootAST) {
<span class="fc bfc" id="L859" title="All 2 branches covered.">        if (!importToGroupList.isEmpty()) {</span>
<span class="fc" id="L860">            finishImportList();</span>
        }
<span class="fc" id="L862">    }</span>

    /** Examine the order of all the imports and log any violations. */
    private void finishImportList() {
<span class="fc" id="L866">        String currentGroup = getFirstGroup();</span>
<span class="fc" id="L867">        int currentGroupNumber = customOrderRules.lastIndexOf(currentGroup);</span>
<span class="fc" id="L868">        ImportDetails previousImportObjectFromCurrentGroup = null;</span>
<span class="fc" id="L869">        String previousImportFromCurrentGroup = null;</span>

<span class="fc bfc" id="L871" title="All 2 branches covered.">        for (ImportDetails importObject : importToGroupList) {</span>
<span class="fc" id="L872">            final String importGroup = importObject.getImportGroup();</span>
<span class="fc" id="L873">            final String fullImportIdent = importObject.getImportFullPath();</span>

<span class="fc bfc" id="L875" title="All 2 branches covered.">            if (importGroup.equals(currentGroup)) {</span>
<span class="fc" id="L876">                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,</span>
                        importObject, fullImportIdent);
<span class="fc bfc" id="L878" title="All 2 branches covered.">                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {</span>
<span class="fc" id="L879">                    log(importObject.getImportAST(), MSG_LEX,</span>
                            fullImportIdent, previousImportFromCurrentGroup);
                }
                else {
<span class="fc" id="L883">                    previousImportFromCurrentGroup = fullImportIdent;</span>
                }
<span class="fc" id="L885">                previousImportObjectFromCurrentGroup = importObject;</span>
            }
            else {
                // not the last group, last one is always NON_GROUP
<span class="fc bfc" id="L889" title="All 2 branches covered.">                if (customOrderRules.size() &gt; currentGroupNumber + 1) {</span>
<span class="fc" id="L890">                    final String nextGroup = getNextImportGroup(currentGroupNumber + 1);</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                    if (importGroup.equals(nextGroup)) {</span>
<span class="fc" id="L892">                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,</span>
                                importObject, fullImportIdent);
<span class="fc" id="L894">                        currentGroup = nextGroup;</span>
<span class="fc" id="L895">                        currentGroupNumber = customOrderRules.lastIndexOf(nextGroup);</span>
<span class="fc" id="L896">                        previousImportFromCurrentGroup = fullImportIdent;</span>
                    }
                    else {
<span class="fc" id="L899">                        logWrongImportGroupOrder(importObject.getImportAST(),</span>
                                importGroup, nextGroup, fullImportIdent);
                    }
<span class="fc" id="L902">                    previousImportObjectFromCurrentGroup = importObject;</span>
<span class="fc" id="L903">                }</span>
                else {
<span class="fc" id="L905">                    logWrongImportGroupOrder(importObject.getImportAST(),</span>
                            importGroup, currentGroup, fullImportIdent);
                }
            }
<span class="fc" id="L909">        }</span>
<span class="fc" id="L910">    }</span>

    /**
     * Log violation if empty line is missed.
     *
     * @param previousImport previous import from current group.
     * @param importObject current import.
     * @param fullImportIdent full import identifier.
     */
    private void validateMissedEmptyLine(ImportDetails previousImport,
                                         ImportDetails importObject, String fullImportIdent) {
<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (isEmptyLineMissed(previousImport, importObject)) {</span>
<span class="fc" id="L922">            log(importObject.getImportAST(), MSG_LINE_SEPARATOR, fullImportIdent);</span>
        }
<span class="fc" id="L924">    }</span>

    /**
     * Log violation if extra empty line is present.
     *
     * @param previousImport previous import from current group.
     * @param importObject current import.
     * @param fullImportIdent full import identifier.
     */
    private void validateExtraEmptyLine(ImportDetails previousImport,
                                        ImportDetails importObject, String fullImportIdent) {
<span class="fc bfc" id="L935" title="All 2 branches covered.">        if (isSeparatedByExtraEmptyLine(previousImport, importObject)) {</span>
<span class="fc" id="L936">            log(importObject.getImportAST(), MSG_SEPARATED_IN_GROUP, fullImportIdent);</span>
        }
<span class="fc" id="L938">    }</span>

    /**
     * Get first import group.
     *
     * @return
     *        first import group of file.
     */
    private String getFirstGroup() {
<span class="fc" id="L947">        final ImportDetails firstImport = importToGroupList.get(0);</span>
<span class="fc" id="L948">        return getImportGroup(firstImport.isStaticImport(),</span>
<span class="fc" id="L949">                firstImport.getImportFullPath());</span>
    }

    /**
     * Examine alphabetical order of imports.
     *
     * @param previousImport
     *        previous import of current group.
     * @param currentImport
     *        current import.
     * @return
     *        true, if previous and current import are not in alphabetical order.
     */
    private boolean isAlphabeticalOrderBroken(String previousImport,
                                              String currentImport) {
<span class="fc bfc" id="L964" title="All 4 branches covered.">        return sortImportsInGroupAlphabetically</span>
                &amp;&amp; previousImport != null
<span class="fc bfc" id="L966" title="All 2 branches covered.">                &amp;&amp; compareImports(currentImport, previousImport) &lt; 0;</span>
    }

    /**
     * Examine empty lines between groups.
     *
     * @param previousImportObject
     *        previous import in current group.
     * @param currentImportObject
     *        current import.
     * @return
     *        true, if current import NOT separated from previous import by empty line.
     */
    private boolean isEmptyLineMissed(ImportDetails previousImportObject,
                                      ImportDetails currentImportObject) {
<span class="fc bfc" id="L981" title="All 2 branches covered.">        return separateLineBetweenGroups</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                &amp;&amp; getCountOfEmptyLinesBetween(</span>
<span class="fc" id="L983">                     previousImportObject.getEndLineNumber(),</span>
<span class="fc" id="L984">                     currentImportObject.getStartLineNumber()) != 1;</span>
    }

    /**
     * Examine that imports separated by more than one empty line.
     *
     * @param previousImportObject
     *        previous import in current group.
     * @param currentImportObject
     *        current import.
     * @return
     *        true, if current import separated from previous by more than one empty line.
     */
    private boolean isSeparatedByExtraEmptyLine(ImportDetails previousImportObject,
                                                ImportDetails currentImportObject) {
<span class="fc bfc" id="L999" title="All 2 branches covered.">        return previousImportObject != null</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                &amp;&amp; getCountOfEmptyLinesBetween(</span>
<span class="fc" id="L1001">                     previousImportObject.getEndLineNumber(),</span>
<span class="fc" id="L1002">                     currentImportObject.getStartLineNumber()) &gt; 0;</span>
    }

    /**
     * Log wrong import group order.
     *
     * @param importAST
     *        import ast.
     * @param importGroup
     *        import group.
     * @param currentGroupNumber
     *        current group number we are checking.
     * @param fullImportIdent
     *        full import name.
     */
    private void logWrongImportGroupOrder(DetailAST importAST, String importGroup,
            String currentGroupNumber, String fullImportIdent) {
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (NON_GROUP_RULE_GROUP.equals(importGroup)) {</span>
<span class="fc" id="L1020">            log(importAST, MSG_NONGROUP_IMPORT, fullImportIdent);</span>
        }
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        else if (NON_GROUP_RULE_GROUP.equals(currentGroupNumber)) {</span>
<span class="fc" id="L1023">            log(importAST, MSG_NONGROUP_EXPECTED, importGroup, fullImportIdent);</span>
        }
        else {
<span class="fc" id="L1026">            log(importAST, MSG_ORDER, importGroup, currentGroupNumber, fullImportIdent);</span>
        }
<span class="fc" id="L1028">    }</span>

    /**
     * Get next import group.
     *
     * @param currentGroupNumber
     *        current group number.
     * @return
     *        next import group.
     */
    private String getNextImportGroup(int currentGroupNumber) {
<span class="fc" id="L1039">        int nextGroupNumber = currentGroupNumber;</span>

<span class="fc bfc" id="L1041" title="All 2 branches covered.">        while (customOrderRules.size() &gt; nextGroupNumber + 1) {</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">            if (hasAnyImportInCurrentGroup(customOrderRules.get(nextGroupNumber))) {</span>
<span class="fc" id="L1043">                break;</span>
            }
<span class="fc" id="L1045">            nextGroupNumber++;</span>
        }
<span class="fc" id="L1047">        return customOrderRules.get(nextGroupNumber);</span>
    }

    /**
     * Checks if current group contains any import.
     *
     * @param currentGroup
     *        current group.
     * @return
     *        true, if current group contains at least one import.
     */
    private boolean hasAnyImportInCurrentGroup(String currentGroup) {
<span class="fc" id="L1059">        boolean result = false;</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        for (ImportDetails currentImport : importToGroupList) {</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">            if (currentGroup.equals(currentImport.getImportGroup())) {</span>
<span class="fc" id="L1062">                result = true;</span>
<span class="fc" id="L1063">                break;</span>
            }
<span class="fc" id="L1065">        }</span>
<span class="fc" id="L1066">        return result;</span>
    }

    /**
     * Get import valid group.
     *
     * @param isStatic
     *        is static import.
     * @param importPath
     *        full import path.
     * @return import valid group.
     */
    private String getImportGroup(boolean isStatic, String importPath) {
<span class="fc" id="L1079">        RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);</span>
<span class="fc bfc" id="L1080" title="All 4 branches covered.">        if (isStatic &amp;&amp; customOrderRules.contains(STATIC_RULE_GROUP)) {</span>
<span class="fc" id="L1081">            bestMatch.group = STATIC_RULE_GROUP;</span>
<span class="fc" id="L1082">            bestMatch.matchLength = importPath.length();</span>
        }
<span class="fc bfc" id="L1084" title="All 2 branches covered.">        else if (customOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {</span>
<span class="fc" id="L1085">            final String importPathTrimmedToSamePackageDepth =</span>
<span class="fc" id="L1086">                    getFirstDomainsFromIdent(samePackageMatchingDepth, importPath);</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">            if (samePackageDomainsRegExp.equals(importPathTrimmedToSamePackageDepth)) {</span>
<span class="fc" id="L1088">                bestMatch.group = SAME_PACKAGE_RULE_GROUP;</span>
<span class="fc" id="L1089">                bestMatch.matchLength = importPath.length();</span>
            }
        }
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        for (String group : customOrderRules) {</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">            if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {</span>
<span class="fc" id="L1094">                bestMatch = findBetterPatternMatch(importPath,</span>
                        STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackageRegExp, bestMatch);
            }
<span class="fc bfc" id="L1097" title="All 2 branches covered.">            if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {</span>
<span class="fc" id="L1098">                bestMatch = findBetterPatternMatch(importPath,</span>
                        group, specialImportsRegExp, bestMatch);
            }
<span class="fc" id="L1101">        }</span>

<span class="fc bfc" id="L1103" title="All 2 branches covered.">        if (NON_GROUP_RULE_GROUP.equals(bestMatch.group)</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">                &amp;&amp; customOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">                &amp;&amp; thirdPartyPackageRegExp.matcher(importPath).find()) {</span>
<span class="fc" id="L1106">            bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;</span>
        }
<span class="fc" id="L1108">        return bestMatch.group;</span>
    }

    /**
     * Tries to find better matching regular expression:
     * longer matching substring wins; in case of the same length,
     * lower position of matching substring wins.
     *
     * @param importPath
     *      Full import identifier
     * @param group
     *      Import group we are trying to assign the import
     * @param regExp
     *      Regular expression for import group
     * @param currentBestMatch
     *      object with currently best match
     * @return better match (if found) or the same (currentBestMatch)
     */
    private static RuleMatchForImport findBetterPatternMatch(String importPath, String group,
            Pattern regExp, RuleMatchForImport currentBestMatch) {
<span class="fc" id="L1128">        RuleMatchForImport betterMatchCandidate = currentBestMatch;</span>
<span class="fc" id="L1129">        final Matcher matcher = regExp.matcher(importPath);</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">        while (matcher.find()) {</span>
<span class="fc" id="L1131">            final int matchStart = matcher.start();</span>
<span class="fc" id="L1132">            final int length = matcher.end() - matchStart;</span>
<span class="fc bfc" id="L1133" title="All 6 branches covered.">            if (length &gt; betterMatchCandidate.matchLength</span>
                    || length == betterMatchCandidate.matchLength
                        &amp;&amp; matchStart &lt; betterMatchCandidate.matchPosition) {
<span class="fc" id="L1136">                betterMatchCandidate = new RuleMatchForImport(group, length, matchStart);</span>
            }
<span class="fc" id="L1138">        }</span>
<span class="fc" id="L1139">        return betterMatchCandidate;</span>
    }

    /**
     * Checks compare two import paths.
     *
     * @param import1
     *        current import.
     * @param import2
     *        previous import.
     * @return a negative integer, zero, or a positive integer as the
     *        specified String is greater than, equal to, or less
     *        than this String, ignoring case considerations.
     */
    private static int compareImports(String import1, String import2) {
<span class="fc" id="L1154">        int result = 0;</span>
<span class="fc" id="L1155">        final String separator = &quot;\\.&quot;;</span>
<span class="fc" id="L1156">        final String[] import1Tokens = import1.split(separator);</span>
<span class="fc" id="L1157">        final String[] import2Tokens = import2.split(separator);</span>
<span class="fc bfc" id="L1158" title="All 4 branches covered.">        for (int i = 0; i != import1Tokens.length &amp;&amp; i != import2Tokens.length; i++) {</span>
<span class="fc" id="L1159">            final String import1Token = import1Tokens[i];</span>
<span class="fc" id="L1160">            final String import2Token = import2Tokens[i];</span>
<span class="fc" id="L1161">            result = import1Token.compareTo(import2Token);</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">            if (result != 0) {</span>
<span class="fc" id="L1163">                break;</span>
            }
        }
<span class="fc bfc" id="L1166" title="All 2 branches covered.">        if (result == 0) {</span>
<span class="fc" id="L1167">            result = Integer.compare(import1Tokens.length, import2Tokens.length);</span>
        }
<span class="fc" id="L1169">        return result;</span>
    }

    /**
     * Counts empty lines between given parameters.
     *
     * @param fromLineNo
     *        One-based line number of previous import.
     * @param toLineNo
     *        One-based line number of current import.
     * @return count of empty lines between given parameters, exclusive,
     *        eg., (fromLineNo, toLineNo).
     */
    private int getCountOfEmptyLinesBetween(int fromLineNo, int toLineNo) {
<span class="fc" id="L1183">        int result = 0;</span>
<span class="fc" id="L1184">        final String[] lines = getLines();</span>

<span class="fc bfc" id="L1186" title="All 2 branches covered.">        for (int i = fromLineNo + 1; i &lt;= toLineNo - 1; i++) {</span>
            // &quot;- 1&quot; because the numbering is one-based
<span class="fc bfc" id="L1188" title="All 2 branches covered.">            if (CommonUtil.isBlank(lines[i - 1])) {</span>
<span class="fc" id="L1189">                result++;</span>
            }
        }
<span class="fc" id="L1192">        return result;</span>
    }

    /**
     * Forms import full path.
     *
     * @param token
     *        current token.
     * @return full path or null.
     */
    private static String getFullImportIdent(DetailAST token) {
<span class="fc" id="L1203">        String ident = &quot;&quot;;</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (token != null) {</span>
<span class="fc" id="L1205">            ident = FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();</span>
        }
<span class="fc" id="L1207">        return ident;</span>
    }

    /**
     * Parses ordering rule and adds it to the list with rules.
     *
     * @param ruleStr
     *        String with rule.
     * @throws IllegalArgumentException when SAME_PACKAGE rule parameter is not positive integer
     * @throws IllegalStateException when ruleStr is unexpected value
     */
    private void addRulesToList(String ruleStr) {
<span class="fc bfc" id="L1219" title="All 2 branches covered.">        if (STATIC_RULE_GROUP.equals(ruleStr)</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">                || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">                || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">                || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {</span>
<span class="fc" id="L1223">            customOrderRules.add(ruleStr);</span>
        }
<span class="fc bfc" id="L1225" title="All 2 branches covered.">        else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {</span>
<span class="fc" id="L1226">            final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,</span>
<span class="fc" id="L1227">                    ruleStr.indexOf(')'));</span>
<span class="fc" id="L1228">            samePackageMatchingDepth = Integer.parseInt(rule);</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">            if (samePackageMatchingDepth &lt;= 0) {</span>
<span class="fc" id="L1230">                throw new IllegalArgumentException(</span>
                        &quot;SAME_PACKAGE rule parameter should be positive integer: &quot; + ruleStr);
            }
<span class="fc" id="L1233">            customOrderRules.add(SAME_PACKAGE_RULE_GROUP);</span>
<span class="fc" id="L1234">        }</span>
        else {
<span class="fc" id="L1236">            throw new IllegalStateException(&quot;Unexpected rule: &quot; + ruleStr);</span>
        }
<span class="fc" id="L1238">    }</span>

    /**
     * Creates samePackageDomainsRegExp of the first package domains.
     *
     * @param firstPackageDomainsCount
     *        number of first package domains.
     * @param packageNode
     *        package node.
     * @return same package regexp.
     */
    private static String createSamePackageRegexp(int firstPackageDomainsCount,
             DetailAST packageNode) {
<span class="fc" id="L1251">        final String packageFullPath = getFullImportIdent(packageNode);</span>
<span class="fc" id="L1252">        return getFirstDomainsFromIdent(firstPackageDomainsCount, packageFullPath);</span>
    }

    /**
     * Extracts defined amount of domains from the left side of package/import identifier.
     *
     * @param firstPackageDomainsCount
     *        number of first package domains.
     * @param packageFullPath
     *        full identifier containing path to package or imported object.
     * @return String with defined amount of domains or full identifier
     *        (if full identifier had less domain than specified)
     */
    private static String getFirstDomainsFromIdent(
            final int firstPackageDomainsCount, final String packageFullPath) {
<span class="fc" id="L1267">        final StringBuilder builder = new StringBuilder(256);</span>
<span class="fc" id="L1268">        final StringTokenizer tokens = new StringTokenizer(packageFullPath, &quot;.&quot;);</span>
<span class="fc" id="L1269">        int count = firstPackageDomainsCount;</span>

<span class="fc bfc" id="L1271" title="All 4 branches covered.">        while (count &gt; 0 &amp;&amp; tokens.hasMoreTokens()) {</span>
<span class="fc" id="L1272">            builder.append(tokens.nextToken()).append('.');</span>
<span class="fc" id="L1273">            count--;</span>
        }
<span class="fc" id="L1275">        return builder.toString();</span>
    }

    /**
     * Contains import attributes as line number, import full path, import
     * group.
     */
    private static class ImportDetails {

        /** Import full path. */
        private final String importFullPath;

        /** Import group. */
        private final String importGroup;

        /** Is static import. */
        private final boolean staticImport;

        /** Import AST. */
        private final DetailAST importAST;

        /**
         * Initialise importFullPath, importGroup, staticImport, importAST.
         *
         * @param importFullPath
         *        import full path.
         * @param importGroup
         *        import group.
         * @param staticImport
         *        if import is static.
         * @param importAST
         *        import ast
         */
        /* package */ ImportDetails(String importFullPath, String importGroup, boolean staticImport,
<span class="fc" id="L1309">                                    DetailAST importAST) {</span>
<span class="fc" id="L1310">            this.importFullPath = importFullPath;</span>
<span class="fc" id="L1311">            this.importGroup = importGroup;</span>
<span class="fc" id="L1312">            this.staticImport = staticImport;</span>
<span class="fc" id="L1313">            this.importAST = importAST;</span>
<span class="fc" id="L1314">        }</span>

        /**
         * Get import full path variable.
         *
         * @return import full path variable.
         */
        public String getImportFullPath() {
<span class="fc" id="L1322">            return importFullPath;</span>
        }

        /**
         * Get import start line number from ast.
         *
         * @return import start line from ast.
         */
        public int getStartLineNumber() {
<span class="fc" id="L1331">            return importAST.getLineNo();</span>
        }

        /**
         * Get import end line number from ast.
         * &lt;p&gt;
         * &lt;b&gt;Note:&lt;/b&gt; It can be different from &lt;b&gt;startLineNumber&lt;/b&gt; when import statement span
         * multiple lines.
         * &lt;/p&gt;
         *
         * @return import end line from ast.
         */
        public int getEndLineNumber() {
<span class="fc" id="L1344">            return importAST.getLastChild().getLineNo();</span>
        }

        /**
         * Get import group.
         *
         * @return import group.
         */
        public String getImportGroup() {
<span class="fc" id="L1353">            return importGroup;</span>
        }

        /**
         * Checks if import is static.
         *
         * @return true, if import is static.
         */
        public boolean isStaticImport() {
<span class="fc" id="L1362">            return staticImport;</span>
        }

        /**
         * Get import ast.
         *
         * @return import ast.
         */
        public DetailAST getImportAST() {
<span class="fc" id="L1371">            return importAST;</span>
        }

    }

    /**
     * Contains matching attributes assisting in definition of &quot;best matching&quot;
     * group for import.
     */
    private static class RuleMatchForImport {

        /** Position of matching string for current best match. */
        private final int matchPosition;
        /** Length of matching string for current best match. */
        private int matchLength;
        /** Import group for current best match. */
        private String group;

        /**
         * Constructor to initialize the fields.
         *
         * @param group
         *        Matched group.
         * @param length
         *        Matching length.
         * @param position
         *        Matching position.
         */
<span class="fc" id="L1399">        /* package */ RuleMatchForImport(String group, int length, int position) {</span>
<span class="fc" id="L1400">            this.group = group;</span>
<span class="fc" id="L1401">            matchLength = length;</span>
<span class="fc" id="L1402">            matchPosition = position;</span>
<span class="fc" id="L1403">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>