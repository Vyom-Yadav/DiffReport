<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaLanguageParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.grammar.java</a> &gt; <span class="el_source">JavaLanguageParser.java</span></div><h1>JavaLanguageParser.java</h1><pre class="source lang-java linenums">// Generated from com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser.g4 by ANTLR 4.10.1
package com.puppycrawl.tools.checkstyle.grammar.java;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.v4.runtime.tree.*;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

@SuppressWarnings({&quot;all&quot;, &quot;warnings&quot;, &quot;unchecked&quot;, &quot;unused&quot;, &quot;cast&quot;})
public class JavaLanguageParser extends Parser {
<span class="fc" id="L14">	static { RuntimeMetaData.checkVersion(&quot;4.10.1&quot;, RuntimeMetaData.VERSION); }</span>

	protected static final DFA[] _decisionToDFA;
<span class="fc" id="L17">	protected static final PredictionContextCache _sharedContextCache =</span>
		new PredictionContextCache();
	public static final int
		COMPILATION_UNIT=1, PLACEHOLDER1=2, NULL_TREE_LOOKAHEAD=3, BLOCK=4, MODIFIERS=5, 
		OBJBLOCK=6, SLIST=7, CTOR_DEF=8, METHOD_DEF=9, VARIABLE_DEF=10, INSTANCE_INIT=11, 
		STATIC_INIT=12, TYPE=13, CLASS_DEF=14, INTERFACE_DEF=15, PACKAGE_DEF=16, 
		ARRAY_DECLARATOR=17, EXTENDS_CLAUSE=18, IMPLEMENTS_CLAUSE=19, PARAMETERS=20, 
		PARAMETER_DEF=21, LABELED_STAT=22, TYPECAST=23, INDEX_OP=24, POST_INC=25, 
		POST_DEC=26, METHOD_CALL=27, EXPR=28, ARRAY_INIT=29, IMPORT=30, UNARY_MINUS=31, 
		UNARY_PLUS=32, CASE_GROUP=33, ELIST=34, FOR_INIT=35, FOR_CONDITION=36, 
		FOR_ITERATOR=37, EMPTY_STAT=38, FINAL=39, ABSTRACT=40, STRICTFP=41, SUPER_CTOR_CALL=42, 
		CTOR_CALL=43, LITERAL_PACKAGE=44, SEMI=45, LITERAL_IMPORT=46, LBRACK=47, 
		RBRACK=48, LITERAL_VOID=49, LITERAL_BOOLEAN=50, LITERAL_BYTE=51, LITERAL_CHAR=52, 
		LITERAL_SHORT=53, LITERAL_INT=54, LITERAL_FLOAT=55, LITERAL_LONG=56, LITERAL_DOUBLE=57, 
		IDENT=58, DOT=59, STAR=60, LITERAL_PRIVATE=61, LITERAL_PUBLIC=62, LITERAL_PROTECTED=63, 
		LITERAL_STATIC=64, LITERAL_TRANSIENT=65, LITERAL_NATIVE=66, LITERAL_SYNCHRONIZED=67, 
		LITERAL_VOLATILE=68, LITERAL_CLASS=69, LITERAL_EXTENDS=70, LITERAL_INTERFACE=71, 
		LCURLY=72, RCURLY=73, COMMA=74, LITERAL_IMPLEMENTS=75, LPAREN=76, RPAREN=77, 
		LITERAL_THIS=78, LITERAL_SUPER=79, ASSIGN=80, LITERAL_THROWS=81, COLON=82, 
		LITERAL_IF=83, LITERAL_WHILE=84, LITERAL_DO=85, LITERAL_BREAK=86, LITERAL_CONTINUE=87, 
		LITERAL_RETURN=88, LITERAL_SWITCH=89, LITERAL_THROW=90, LITERAL_FOR=91, 
		LITERAL_ELSE=92, LITERAL_CASE=93, LITERAL_DEFAULT=94, LITERAL_TRY=95, 
		LITERAL_CATCH=96, LITERAL_FINALLY=97, PLUS_ASSIGN=98, MINUS_ASSIGN=99, 
		STAR_ASSIGN=100, DIV_ASSIGN=101, MOD_ASSIGN=102, SR_ASSIGN=103, BSR_ASSIGN=104, 
		SL_ASSIGN=105, BAND_ASSIGN=106, BXOR_ASSIGN=107, BOR_ASSIGN=108, QUESTION=109, 
		LOR=110, LAND=111, BOR=112, BXOR=113, BAND=114, NOT_EQUAL=115, EQUAL=116, 
		LT=117, GT=118, LE=119, GE=120, LITERAL_INSTANCEOF=121, SL=122, SR=123, 
		BSR=124, PLUS=125, MINUS=126, DIV=127, MOD=128, INC=129, DEC=130, BNOT=131, 
		LNOT=132, LITERAL_TRUE=133, LITERAL_FALSE=134, LITERAL_NULL=135, LITERAL_NEW=136, 
		NUM_INT=137, CHAR_LITERAL=138, STRING_LITERAL=139, NUM_FLOAT=140, NUM_LONG=141, 
		NUM_DOUBLE=142, WS=143, SINGLE_LINE_COMMENT=144, BLOCK_COMMENT_BEGIN=145, 
		ESC=146, HEX_DIGIT=147, VOCAB=148, EXPONENT=149, FLOAT_SUFFIX=150, ASSERT=151, 
		STATIC_IMPORT=152, ENUM=153, ENUM_DEF=154, ENUM_CONSTANT_DEF=155, FOR_EACH_CLAUSE=156, 
		ANNOTATION_DEF=157, ANNOTATIONS=158, ANNOTATION=159, ANNOTATION_MEMBER_VALUE_PAIR=160, 
		ANNOTATION_FIELD_DEF=161, ANNOTATION_ARRAY_INIT=162, TYPE_ARGUMENTS=163, 
		TYPE_ARGUMENT=164, TYPE_PARAMETERS=165, TYPE_PARAMETER=166, WILDCARD_TYPE=167, 
		TYPE_UPPER_BOUNDS=168, TYPE_LOWER_BOUNDS=169, AT=170, ELLIPSIS=171, GENERIC_START=172, 
		GENERIC_END=173, TYPE_EXTENSION_AND=174, DO_WHILE=175, RESOURCE_SPECIFICATION=176, 
		RESOURCES=177, RESOURCE=178, DOUBLE_COLON=179, METHOD_REF=180, LAMBDA=181, 
		BLOCK_COMMENT_END=182, COMMENT_CONTENT=183, SINGLE_LINE_COMMENT_CONTENT=184, 
		BLOCK_COMMENT_CONTENT=185, STD_ESC=186, BINARY_DIGIT=187, ID_START=188, 
		ID_PART=189, INT_LITERAL=190, LONG_LITERAL=191, FLOAT_LITERAL=192, DOUBLE_LITERAL=193, 
		HEX_FLOAT_LITERAL=194, HEX_DOUBLE_LITERAL=195, SIGNED_INTEGER=196, BINARY_EXPONENT=197, 
		PATTERN_VARIABLE_DEF=198, RECORD_DEF=199, LITERAL_RECORD=200, RECORD_COMPONENTS=201, 
		RECORD_COMPONENT_DEF=202, COMPACT_CTOR_DEF=203, TEXT_BLOCK_LITERAL_BEGIN=204, 
		TEXT_BLOCK_CONTENT=205, TEXT_BLOCK_LITERAL_END=206, LITERAL_YIELD=207, 
		SWITCH_RULE=208, LITERAL_NON_SEALED=209, LITERAL_SEALED=210, LITERAL_PERMITS=211, 
		PERMITS_CLAUSE=212, PATTERN_DEF=213, LITERAL_CONST=214, LITERAL_GOTO=215, 
		DECIMAL_LITERAL_LONG=216, DECIMAL_LITERAL=217, HEX_LITERAL_LONG=218, HEX_LITERAL=219, 
		OCT_LITERAL_LONG=220, OCT_LITERAL=221, BINARY_LITERAL_LONG=222, BINARY_LITERAL=223;
	public static final int
		RULE_compilationUnit = 0, RULE_packageDeclaration = 1, RULE_importDeclaration = 2, 
		RULE_typeDeclaration = 3, RULE_types = 4, RULE_modifier = 5, RULE_variableModifier = 6, 
		RULE_classDeclaration = 7, RULE_recordDeclaration = 8, RULE_recordComponentsList = 9, 
		RULE_recordComponents = 10, RULE_recordComponent = 11, RULE_lastRecordComponent = 12, 
		RULE_recordBody = 13, RULE_recordBodyDeclaration = 14, RULE_compactConstructorDeclaration = 15, 
		RULE_classExtends = 16, RULE_implementsClause = 17, RULE_typeParameters = 18, 
		RULE_typeParameter = 19, RULE_typeUpperBounds = 20, RULE_typeBound = 21, 
		RULE_typeBoundType = 22, RULE_enumDeclaration = 23, RULE_enumBody = 24, 
		RULE_enumConstants = 25, RULE_enumConstant = 26, RULE_enumBodyDeclarations = 27, 
		RULE_interfaceDeclaration = 28, RULE_interfaceExtends = 29, RULE_classBody = 30, 
		RULE_interfaceBody = 31, RULE_classBodyDeclaration = 32, RULE_memberDeclaration = 33, 
		RULE_methodDeclaration = 34, RULE_methodBody = 35, RULE_throwsList = 36, 
		RULE_constructorDeclaration = 37, RULE_fieldDeclaration = 38, RULE_interfaceBodyDeclaration = 39, 
		RULE_interfaceMemberDeclaration = 40, RULE_interfaceMethodDeclaration = 41, 
		RULE_variableDeclarators = 42, RULE_variableDeclarator = 43, RULE_variableDeclaratorId = 44, 
		RULE_variableInitializer = 45, RULE_arrayInitializer = 46, RULE_classOrInterfaceType = 47, 
		RULE_classOrInterfaceTypeExtended = 48, RULE_typeArgument = 49, RULE_qualifiedNameList = 50, 
		RULE_formalParameters = 51, RULE_formalParameterList = 52, RULE_formalParameter = 53, 
		RULE_lastFormalParameter = 54, RULE_qualifiedName = 55, RULE_qualifiedNameExtended = 56, 
		RULE_literal = 57, RULE_integerLiteral = 58, RULE_floatLiteral = 59, RULE_textBlockLiteral = 60, 
		RULE_annotations = 61, RULE_annotation = 62, RULE_elementValuePairs = 63, 
		RULE_elementValuePair = 64, RULE_elementValue = 65, RULE_elementValueArrayInitializer = 66, 
		RULE_annotationTypeDeclaration = 67, RULE_annotationTypeBody = 68, RULE_annotationTypeElementDeclaration = 69, 
		RULE_annotationTypeElementRest = 70, RULE_annotationMethodRest = 71, RULE_annotationConstantRest = 72, 
		RULE_defaultValue = 73, RULE_constructorBlock = 74, RULE_explicitConstructorInvocation = 75, 
		RULE_block = 76, RULE_blockStatement = 77, RULE_localVariableDeclaration = 78, 
		RULE_localTypeDeclaration = 79, RULE_statement = 80, RULE_switchExpressionOrStatement = 81, 
		RULE_switchBlock = 82, RULE_switchLabeledRule = 83, RULE_switchLabeledExpression = 84, 
		RULE_switchLabeledBlock = 85, RULE_switchLabeledThrow = 86, RULE_elseStat = 87, 
		RULE_catchClause = 88, RULE_catchParameter = 89, RULE_catchType = 90, 
		RULE_finallyBlock = 91, RULE_resourceSpecification = 92, RULE_resources = 93, 
		RULE_resource = 94, RULE_resourceDeclaration = 95, RULE_variableAccess = 96, 
		RULE_fieldAccessNoIdent = 97, RULE_switchBlockStatementGroup = 98, RULE_switchLabel = 99, 
		RULE_caseConstants = 100, RULE_caseConstant = 101, RULE_forControl = 102, 
		RULE_forInit = 103, RULE_enhancedForControl = 104, RULE_parExpression = 105, 
		RULE_expressionList = 106, RULE_expression = 107, RULE_expr = 108, RULE_typeCastParameters = 109, 
		RULE_lambdaExpression = 110, RULE_lambdaParameters = 111, RULE_multiLambdaParams = 112, 
		RULE_lambdaBody = 113, RULE_primary = 114, RULE_classType = 115, RULE_creator = 116, 
		RULE_createdName = 117, RULE_createdNameExtended = 118, RULE_innerCreator = 119, 
		RULE_arrayCreatorRest = 120, RULE_bracketsWithExp = 121, RULE_classCreatorRest = 122, 
		RULE_typeArgumentsOrDiamond = 123, RULE_nonWildcardTypeArgumentsOrDiamond = 124, 
		RULE_nonWildcardTypeArguments = 125, RULE_typeArgumentsTypeList = 126, 
		RULE_typeList = 127, RULE_typeType = 128, RULE_classOrInterfaceOrPrimitiveType = 129, 
		RULE_arrayDeclarator = 130, RULE_primitiveType = 131, RULE_typeArguments = 132, 
		RULE_superSuffix = 133, RULE_arguments = 134, RULE_pattern = 135, RULE_guardedPattern = 136, 
		RULE_primaryPattern = 137, RULE_typePattern = 138, RULE_permittedSubclassesAndInterfaces = 139, 
		RULE_id = 140;
	private static String[] makeRuleNames() {
<span class="fc" id="L116">		return new String[] {</span>
			&quot;compilationUnit&quot;, &quot;packageDeclaration&quot;, &quot;importDeclaration&quot;, &quot;typeDeclaration&quot;, 
			&quot;types&quot;, &quot;modifier&quot;, &quot;variableModifier&quot;, &quot;classDeclaration&quot;, &quot;recordDeclaration&quot;, 
			&quot;recordComponentsList&quot;, &quot;recordComponents&quot;, &quot;recordComponent&quot;, &quot;lastRecordComponent&quot;, 
			&quot;recordBody&quot;, &quot;recordBodyDeclaration&quot;, &quot;compactConstructorDeclaration&quot;, 
			&quot;classExtends&quot;, &quot;implementsClause&quot;, &quot;typeParameters&quot;, &quot;typeParameter&quot;, 
			&quot;typeUpperBounds&quot;, &quot;typeBound&quot;, &quot;typeBoundType&quot;, &quot;enumDeclaration&quot;, &quot;enumBody&quot;, 
			&quot;enumConstants&quot;, &quot;enumConstant&quot;, &quot;enumBodyDeclarations&quot;, &quot;interfaceDeclaration&quot;, 
			&quot;interfaceExtends&quot;, &quot;classBody&quot;, &quot;interfaceBody&quot;, &quot;classBodyDeclaration&quot;, 
			&quot;memberDeclaration&quot;, &quot;methodDeclaration&quot;, &quot;methodBody&quot;, &quot;throwsList&quot;, 
			&quot;constructorDeclaration&quot;, &quot;fieldDeclaration&quot;, &quot;interfaceBodyDeclaration&quot;, 
			&quot;interfaceMemberDeclaration&quot;, &quot;interfaceMethodDeclaration&quot;, &quot;variableDeclarators&quot;, 
			&quot;variableDeclarator&quot;, &quot;variableDeclaratorId&quot;, &quot;variableInitializer&quot;, 
			&quot;arrayInitializer&quot;, &quot;classOrInterfaceType&quot;, &quot;classOrInterfaceTypeExtended&quot;, 
			&quot;typeArgument&quot;, &quot;qualifiedNameList&quot;, &quot;formalParameters&quot;, &quot;formalParameterList&quot;, 
			&quot;formalParameter&quot;, &quot;lastFormalParameter&quot;, &quot;qualifiedName&quot;, &quot;qualifiedNameExtended&quot;, 
			&quot;literal&quot;, &quot;integerLiteral&quot;, &quot;floatLiteral&quot;, &quot;textBlockLiteral&quot;, &quot;annotations&quot;, 
			&quot;annotation&quot;, &quot;elementValuePairs&quot;, &quot;elementValuePair&quot;, &quot;elementValue&quot;, 
			&quot;elementValueArrayInitializer&quot;, &quot;annotationTypeDeclaration&quot;, &quot;annotationTypeBody&quot;, 
			&quot;annotationTypeElementDeclaration&quot;, &quot;annotationTypeElementRest&quot;, &quot;annotationMethodRest&quot;, 
			&quot;annotationConstantRest&quot;, &quot;defaultValue&quot;, &quot;constructorBlock&quot;, &quot;explicitConstructorInvocation&quot;, 
			&quot;block&quot;, &quot;blockStatement&quot;, &quot;localVariableDeclaration&quot;, &quot;localTypeDeclaration&quot;, 
			&quot;statement&quot;, &quot;switchExpressionOrStatement&quot;, &quot;switchBlock&quot;, &quot;switchLabeledRule&quot;, 
			&quot;switchLabeledExpression&quot;, &quot;switchLabeledBlock&quot;, &quot;switchLabeledThrow&quot;, 
			&quot;elseStat&quot;, &quot;catchClause&quot;, &quot;catchParameter&quot;, &quot;catchType&quot;, &quot;finallyBlock&quot;, 
			&quot;resourceSpecification&quot;, &quot;resources&quot;, &quot;resource&quot;, &quot;resourceDeclaration&quot;, 
			&quot;variableAccess&quot;, &quot;fieldAccessNoIdent&quot;, &quot;switchBlockStatementGroup&quot;, 
			&quot;switchLabel&quot;, &quot;caseConstants&quot;, &quot;caseConstant&quot;, &quot;forControl&quot;, &quot;forInit&quot;, 
			&quot;enhancedForControl&quot;, &quot;parExpression&quot;, &quot;expressionList&quot;, &quot;expression&quot;, 
			&quot;expr&quot;, &quot;typeCastParameters&quot;, &quot;lambdaExpression&quot;, &quot;lambdaParameters&quot;, 
			&quot;multiLambdaParams&quot;, &quot;lambdaBody&quot;, &quot;primary&quot;, &quot;classType&quot;, &quot;creator&quot;, 
			&quot;createdName&quot;, &quot;createdNameExtended&quot;, &quot;innerCreator&quot;, &quot;arrayCreatorRest&quot;, 
			&quot;bracketsWithExp&quot;, &quot;classCreatorRest&quot;, &quot;typeArgumentsOrDiamond&quot;, &quot;nonWildcardTypeArgumentsOrDiamond&quot;, 
			&quot;nonWildcardTypeArguments&quot;, &quot;typeArgumentsTypeList&quot;, &quot;typeList&quot;, &quot;typeType&quot;, 
			&quot;classOrInterfaceOrPrimitiveType&quot;, &quot;arrayDeclarator&quot;, &quot;primitiveType&quot;, 
			&quot;typeArguments&quot;, &quot;superSuffix&quot;, &quot;arguments&quot;, &quot;pattern&quot;, &quot;guardedPattern&quot;, 
			&quot;primaryPattern&quot;, &quot;typePattern&quot;, &quot;permittedSubclassesAndInterfaces&quot;, 
			&quot;id&quot;
		};
	}
<span class="fc" id="L156">	public static final String[] ruleNames = makeRuleNames();</span>

	private static String[] makeLiteralNames() {
<span class="fc" id="L159">		return new String[] {</span>
			null, null, null, null, null, null, null, null, null, null, null, null, 
			null, null, null, null, null, null, &quot;'extends'&quot;, null, null, null, null, 
			null, null, null, null, null, null, null, &quot;'import'&quot;, null, null, null, 
			null, null, null, null, null, &quot;'final'&quot;, &quot;'abstract'&quot;, &quot;'strictfp'&quot;, 
			null, null, &quot;'package'&quot;, &quot;';'&quot;, null, &quot;'['&quot;, &quot;']'&quot;, &quot;'void'&quot;, &quot;'boolean'&quot;, 
			&quot;'byte'&quot;, &quot;'char'&quot;, &quot;'short'&quot;, &quot;'int'&quot;, &quot;'float'&quot;, &quot;'long'&quot;, &quot;'double'&quot;, 
			null, &quot;'.'&quot;, &quot;'*'&quot;, &quot;'private'&quot;, &quot;'public'&quot;, &quot;'protected'&quot;, &quot;'static'&quot;, 
			&quot;'transient'&quot;, &quot;'native'&quot;, &quot;'synchronized'&quot;, &quot;'volatile'&quot;, &quot;'class'&quot;, 
			null, &quot;'interface'&quot;, &quot;'{'&quot;, &quot;'}'&quot;, &quot;','&quot;, &quot;'implements'&quot;, &quot;'('&quot;, &quot;')'&quot;, 
			&quot;'this'&quot;, &quot;'super'&quot;, &quot;'='&quot;, &quot;'throws'&quot;, &quot;':'&quot;, &quot;'if'&quot;, &quot;'while'&quot;, &quot;'do'&quot;, 
			&quot;'break'&quot;, &quot;'continue'&quot;, &quot;'return'&quot;, &quot;'switch'&quot;, &quot;'throw'&quot;, &quot;'for'&quot;, 
			&quot;'else'&quot;, &quot;'case'&quot;, &quot;'default'&quot;, &quot;'try'&quot;, &quot;'catch'&quot;, &quot;'finally'&quot;, &quot;'+='&quot;, 
			&quot;'-='&quot;, &quot;'*='&quot;, &quot;'/='&quot;, &quot;'%='&quot;, &quot;'&gt;&gt;='&quot;, &quot;'&gt;&gt;&gt;='&quot;, &quot;'&lt;&lt;='&quot;, &quot;'&amp;='&quot;, &quot;'^='&quot;, 
			&quot;'|='&quot;, &quot;'?'&quot;, &quot;'||'&quot;, &quot;'&amp;&amp;'&quot;, &quot;'|'&quot;, &quot;'^'&quot;, &quot;'&amp;'&quot;, &quot;'!='&quot;, &quot;'=='&quot;, &quot;'&lt;'&quot;, 
			&quot;'&gt;'&quot;, &quot;'&lt;='&quot;, &quot;'&gt;='&quot;, &quot;'instanceof'&quot;, null, null, null, &quot;'+'&quot;, &quot;'-'&quot;, 
			&quot;'/'&quot;, &quot;'%'&quot;, &quot;'++'&quot;, &quot;'--'&quot;, &quot;'~'&quot;, &quot;'!'&quot;, &quot;'true'&quot;, &quot;'false'&quot;, &quot;'null'&quot;, 
			&quot;'new'&quot;, null, null, null, null, null, null, null, null, null, null, 
			null, null, null, null, &quot;'assert'&quot;, null, &quot;'enum'&quot;, null, null, null, 
			null, null, null, null, null, null, null, null, null, null, null, null, 
			null, &quot;'@'&quot;, &quot;'...'&quot;, null, null, null, null, null, null, null, &quot;'::'&quot;, 
			null, &quot;'-&gt;'&quot;, null, null, null, null, null, null, null, null, null, null, 
			null, null, null, null, null, null, null, null, &quot;'record'&quot;, null, null, 
			null, null, null, null, &quot;'yield'&quot;, null, &quot;'non-sealed'&quot;, &quot;'sealed'&quot;, 
			&quot;'permits'&quot;, null, null, &quot;'const'&quot;, &quot;'goto'&quot;
		};
	}
<span class="fc" id="L186">	private static final String[] _LITERAL_NAMES = makeLiteralNames();</span>
	private static String[] makeSymbolicNames() {
<span class="fc" id="L188">		return new String[] {</span>
			null, &quot;COMPILATION_UNIT&quot;, &quot;PLACEHOLDER1&quot;, &quot;NULL_TREE_LOOKAHEAD&quot;, &quot;BLOCK&quot;, 
			&quot;MODIFIERS&quot;, &quot;OBJBLOCK&quot;, &quot;SLIST&quot;, &quot;CTOR_DEF&quot;, &quot;METHOD_DEF&quot;, &quot;VARIABLE_DEF&quot;, 
			&quot;INSTANCE_INIT&quot;, &quot;STATIC_INIT&quot;, &quot;TYPE&quot;, &quot;CLASS_DEF&quot;, &quot;INTERFACE_DEF&quot;, 
			&quot;PACKAGE_DEF&quot;, &quot;ARRAY_DECLARATOR&quot;, &quot;EXTENDS_CLAUSE&quot;, &quot;IMPLEMENTS_CLAUSE&quot;, 
			&quot;PARAMETERS&quot;, &quot;PARAMETER_DEF&quot;, &quot;LABELED_STAT&quot;, &quot;TYPECAST&quot;, &quot;INDEX_OP&quot;, 
			&quot;POST_INC&quot;, &quot;POST_DEC&quot;, &quot;METHOD_CALL&quot;, &quot;EXPR&quot;, &quot;ARRAY_INIT&quot;, &quot;IMPORT&quot;, 
			&quot;UNARY_MINUS&quot;, &quot;UNARY_PLUS&quot;, &quot;CASE_GROUP&quot;, &quot;ELIST&quot;, &quot;FOR_INIT&quot;, &quot;FOR_CONDITION&quot;, 
			&quot;FOR_ITERATOR&quot;, &quot;EMPTY_STAT&quot;, &quot;FINAL&quot;, &quot;ABSTRACT&quot;, &quot;STRICTFP&quot;, &quot;SUPER_CTOR_CALL&quot;, 
			&quot;CTOR_CALL&quot;, &quot;LITERAL_PACKAGE&quot;, &quot;SEMI&quot;, &quot;LITERAL_IMPORT&quot;, &quot;LBRACK&quot;, &quot;RBRACK&quot;, 
			&quot;LITERAL_VOID&quot;, &quot;LITERAL_BOOLEAN&quot;, &quot;LITERAL_BYTE&quot;, &quot;LITERAL_CHAR&quot;, &quot;LITERAL_SHORT&quot;, 
			&quot;LITERAL_INT&quot;, &quot;LITERAL_FLOAT&quot;, &quot;LITERAL_LONG&quot;, &quot;LITERAL_DOUBLE&quot;, &quot;IDENT&quot;, 
			&quot;DOT&quot;, &quot;STAR&quot;, &quot;LITERAL_PRIVATE&quot;, &quot;LITERAL_PUBLIC&quot;, &quot;LITERAL_PROTECTED&quot;, 
			&quot;LITERAL_STATIC&quot;, &quot;LITERAL_TRANSIENT&quot;, &quot;LITERAL_NATIVE&quot;, &quot;LITERAL_SYNCHRONIZED&quot;, 
			&quot;LITERAL_VOLATILE&quot;, &quot;LITERAL_CLASS&quot;, &quot;LITERAL_EXTENDS&quot;, &quot;LITERAL_INTERFACE&quot;, 
			&quot;LCURLY&quot;, &quot;RCURLY&quot;, &quot;COMMA&quot;, &quot;LITERAL_IMPLEMENTS&quot;, &quot;LPAREN&quot;, &quot;RPAREN&quot;, 
			&quot;LITERAL_THIS&quot;, &quot;LITERAL_SUPER&quot;, &quot;ASSIGN&quot;, &quot;LITERAL_THROWS&quot;, &quot;COLON&quot;, 
			&quot;LITERAL_IF&quot;, &quot;LITERAL_WHILE&quot;, &quot;LITERAL_DO&quot;, &quot;LITERAL_BREAK&quot;, &quot;LITERAL_CONTINUE&quot;, 
			&quot;LITERAL_RETURN&quot;, &quot;LITERAL_SWITCH&quot;, &quot;LITERAL_THROW&quot;, &quot;LITERAL_FOR&quot;, &quot;LITERAL_ELSE&quot;, 
			&quot;LITERAL_CASE&quot;, &quot;LITERAL_DEFAULT&quot;, &quot;LITERAL_TRY&quot;, &quot;LITERAL_CATCH&quot;, &quot;LITERAL_FINALLY&quot;, 
			&quot;PLUS_ASSIGN&quot;, &quot;MINUS_ASSIGN&quot;, &quot;STAR_ASSIGN&quot;, &quot;DIV_ASSIGN&quot;, &quot;MOD_ASSIGN&quot;, 
			&quot;SR_ASSIGN&quot;, &quot;BSR_ASSIGN&quot;, &quot;SL_ASSIGN&quot;, &quot;BAND_ASSIGN&quot;, &quot;BXOR_ASSIGN&quot;, 
			&quot;BOR_ASSIGN&quot;, &quot;QUESTION&quot;, &quot;LOR&quot;, &quot;LAND&quot;, &quot;BOR&quot;, &quot;BXOR&quot;, &quot;BAND&quot;, &quot;NOT_EQUAL&quot;, 
			&quot;EQUAL&quot;, &quot;LT&quot;, &quot;GT&quot;, &quot;LE&quot;, &quot;GE&quot;, &quot;LITERAL_INSTANCEOF&quot;, &quot;SL&quot;, &quot;SR&quot;, &quot;BSR&quot;, 
			&quot;PLUS&quot;, &quot;MINUS&quot;, &quot;DIV&quot;, &quot;MOD&quot;, &quot;INC&quot;, &quot;DEC&quot;, &quot;BNOT&quot;, &quot;LNOT&quot;, &quot;LITERAL_TRUE&quot;, 
			&quot;LITERAL_FALSE&quot;, &quot;LITERAL_NULL&quot;, &quot;LITERAL_NEW&quot;, &quot;NUM_INT&quot;, &quot;CHAR_LITERAL&quot;, 
			&quot;STRING_LITERAL&quot;, &quot;NUM_FLOAT&quot;, &quot;NUM_LONG&quot;, &quot;NUM_DOUBLE&quot;, &quot;WS&quot;, &quot;SINGLE_LINE_COMMENT&quot;, 
			&quot;BLOCK_COMMENT_BEGIN&quot;, &quot;ESC&quot;, &quot;HEX_DIGIT&quot;, &quot;VOCAB&quot;, &quot;EXPONENT&quot;, &quot;FLOAT_SUFFIX&quot;, 
			&quot;ASSERT&quot;, &quot;STATIC_IMPORT&quot;, &quot;ENUM&quot;, &quot;ENUM_DEF&quot;, &quot;ENUM_CONSTANT_DEF&quot;, &quot;FOR_EACH_CLAUSE&quot;, 
			&quot;ANNOTATION_DEF&quot;, &quot;ANNOTATIONS&quot;, &quot;ANNOTATION&quot;, &quot;ANNOTATION_MEMBER_VALUE_PAIR&quot;, 
			&quot;ANNOTATION_FIELD_DEF&quot;, &quot;ANNOTATION_ARRAY_INIT&quot;, &quot;TYPE_ARGUMENTS&quot;, &quot;TYPE_ARGUMENT&quot;, 
			&quot;TYPE_PARAMETERS&quot;, &quot;TYPE_PARAMETER&quot;, &quot;WILDCARD_TYPE&quot;, &quot;TYPE_UPPER_BOUNDS&quot;, 
			&quot;TYPE_LOWER_BOUNDS&quot;, &quot;AT&quot;, &quot;ELLIPSIS&quot;, &quot;GENERIC_START&quot;, &quot;GENERIC_END&quot;, 
			&quot;TYPE_EXTENSION_AND&quot;, &quot;DO_WHILE&quot;, &quot;RESOURCE_SPECIFICATION&quot;, &quot;RESOURCES&quot;, 
			&quot;RESOURCE&quot;, &quot;DOUBLE_COLON&quot;, &quot;METHOD_REF&quot;, &quot;LAMBDA&quot;, &quot;BLOCK_COMMENT_END&quot;, 
			&quot;COMMENT_CONTENT&quot;, &quot;SINGLE_LINE_COMMENT_CONTENT&quot;, &quot;BLOCK_COMMENT_CONTENT&quot;, 
			&quot;STD_ESC&quot;, &quot;BINARY_DIGIT&quot;, &quot;ID_START&quot;, &quot;ID_PART&quot;, &quot;INT_LITERAL&quot;, &quot;LONG_LITERAL&quot;, 
			&quot;FLOAT_LITERAL&quot;, &quot;DOUBLE_LITERAL&quot;, &quot;HEX_FLOAT_LITERAL&quot;, &quot;HEX_DOUBLE_LITERAL&quot;, 
			&quot;SIGNED_INTEGER&quot;, &quot;BINARY_EXPONENT&quot;, &quot;PATTERN_VARIABLE_DEF&quot;, &quot;RECORD_DEF&quot;, 
			&quot;LITERAL_RECORD&quot;, &quot;RECORD_COMPONENTS&quot;, &quot;RECORD_COMPONENT_DEF&quot;, &quot;COMPACT_CTOR_DEF&quot;, 
			&quot;TEXT_BLOCK_LITERAL_BEGIN&quot;, &quot;TEXT_BLOCK_CONTENT&quot;, &quot;TEXT_BLOCK_LITERAL_END&quot;, 
			&quot;LITERAL_YIELD&quot;, &quot;SWITCH_RULE&quot;, &quot;LITERAL_NON_SEALED&quot;, &quot;LITERAL_SEALED&quot;, 
			&quot;LITERAL_PERMITS&quot;, &quot;PERMITS_CLAUSE&quot;, &quot;PATTERN_DEF&quot;, &quot;LITERAL_CONST&quot;, 
			&quot;LITERAL_GOTO&quot;, &quot;DECIMAL_LITERAL_LONG&quot;, &quot;DECIMAL_LITERAL&quot;, &quot;HEX_LITERAL_LONG&quot;, 
			&quot;HEX_LITERAL&quot;, &quot;OCT_LITERAL_LONG&quot;, &quot;OCT_LITERAL&quot;, &quot;BINARY_LITERAL_LONG&quot;, 
			&quot;BINARY_LITERAL&quot;
		};
	}
<span class="fc" id="L236">	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();</span>
<span class="fc" id="L237">	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);</span>

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
<span class="fc" id="L245">		tokenNames = new String[_SYMBOLIC_NAMES.length];</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">		for (int i = 0; i &lt; tokenNames.length; i++) {</span>
<span class="fc" id="L247">			tokenNames[i] = VOCABULARY.getLiteralName(i);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">			if (tokenNames[i] == null) {</span>
<span class="fc" id="L249">				tokenNames[i] = VOCABULARY.getSymbolicName(i);</span>
			}

<span class="fc bfc" id="L252" title="All 2 branches covered.">			if (tokenNames[i] == null) {</span>
<span class="fc" id="L253">				tokenNames[i] = &quot;&lt;INVALID&gt;&quot;;</span>
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
<span class="nc" id="L261">		return tokenNames;</span>
	}

	@Override

	public Vocabulary getVocabulary() {
<span class="fc" id="L267">		return VOCABULARY;</span>
	}

	@Override
<span class="nc" id="L271">	public String getGrammarFileName() { return &quot;JavaLanguageParser.g4&quot;; }</span>

	@Override
<span class="nc" id="L274">	public String[] getRuleNames() { return ruleNames; }</span>

	@Override
<span class="nc" id="L277">	public String getSerializedATN() { return _serializedATN; }</span>

	@Override
<span class="fc" id="L280">	public ATN getATN() { return _ATN; }</span>



	    /**
	     * This is the number of files to parse before clearing the parser's
	     * DFA states. This number can have a significant impact on performance;
	     * we have found 500 files to be a good balance between parser speed and
	     * memory usage. This field must be public in order to be accessed and
	     * used for {@link JavaLanguageParser#JavaLanguageParser(TokenStream, int)}
	     * generated constructor.
	     */
	    public static final int CLEAR_DFA_LIMIT = 500;

	    /**
	    * This value tracks the depth of a switch expression. Along with the
	    * IDENT to id rule at the end of the parser, this value helps us
	    * to know if the &quot;yield&quot; we are parsing is an IDENT, method call, class,
	    * field, etc. or if it is a java 13+ yield statement. Positive values
	    * indicate that we are within a (possibly nested) switch expression.
	    */
<span class="fc" id="L301">	    private int switchBlockDepth = 0;</span>

	    /**
	     * Checks if next statement is a yield statement.
	     *
	     * @return true if next statement is a yield statement.
	     */
	    private boolean isYieldStatement() {
<span class="pc bpc" id="L309" title="1 of 4 branches missed.">	        return _input.LT(1).getType() == JavaLanguageLexer.LITERAL_YIELD &amp;&amp; switchBlockDepth &gt; 0;</span>
	    }

<span class="fc" id="L312">	    static int fileCounter = 0;</span>

	    /**
	     * We create a custom constructor so that we can clear the DFA
	     * states upon instantiation of JavaLanguageParser.
	     *
	     * @param input the token stream to parse
	     * @param clearDfaLimit this is the number of files to parse before clearing
	     *         the parser's DFA states. This number can have a significant impact
	     *         on performance; more frequent clearing of DFA states can lead to
	     *         slower parsing but lower memory usage. Conversely, not clearing the
	     *         DFA states at all can lead to enormous memory usage, but may also
	     *         have a negative effect on memory usage from higher garbage collector
	     *         activity.
	     */
	    public JavaLanguageParser(TokenStream input, int clearDfaLimit) {
<span class="fc" id="L328">	        super(input);</span>
<span class="fc" id="L329">	        _interp = new ParserATNSimulator(this, _ATN , _decisionToDFA, _sharedContextCache);</span>
<span class="fc" id="L330">	        fileCounter++;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">	        if (fileCounter &gt; clearDfaLimit) {</span>
<span class="fc" id="L332">	            _interp.clearDFA();</span>
<span class="fc" id="L333">	            fileCounter = 0;</span>
	        }
<span class="fc" id="L335">	    }</span>

	public JavaLanguageParser(TokenStream input) {
<span class="fc" id="L338">		super(input);</span>
<span class="fc" id="L339">		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);</span>
<span class="fc" id="L340">	}</span>

	public static class CompilationUnitContext extends ParserRuleContext {
<span class="nc" id="L343">		public TerminalNode EOF() { return getToken(JavaLanguageParser.EOF, 0); }</span>
		public PackageDeclarationContext packageDeclaration() {
<span class="nc" id="L345">			return getRuleContext(PackageDeclarationContext.class,0);</span>
		}
		public List&lt;ImportDeclarationContext&gt; importDeclaration() {
<span class="nc" id="L348">			return getRuleContexts(ImportDeclarationContext.class);</span>
		}
		public ImportDeclarationContext importDeclaration(int i) {
<span class="nc" id="L351">			return getRuleContext(ImportDeclarationContext.class,i);</span>
		}
		public List&lt;TypeDeclarationContext&gt; typeDeclaration() {
<span class="nc" id="L354">			return getRuleContexts(TypeDeclarationContext.class);</span>
		}
		public TypeDeclarationContext typeDeclaration(int i) {
<span class="nc" id="L357">			return getRuleContext(TypeDeclarationContext.class,i);</span>
		}
		public CompilationUnitContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L360">			super(parent, invokingState);</span>
<span class="fc" id="L361">		}</span>
<span class="nc" id="L362">		@Override public int getRuleIndex() { return RULE_compilationUnit; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCompilationUnit(this);</span>
<span class="nc" id="L366">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CompilationUnitContext compilationUnit() throws RecognitionException {
<span class="fc" id="L371">		CompilationUnitContext _localctx = new CompilationUnitContext(_ctx, getState());</span>
<span class="fc" id="L372">		enterRule(_localctx, 0, RULE_compilationUnit);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L376">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L378">			setState(283);</span>
<span class="fc" id="L379">			_errHandler.sync(this);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">			switch ( getInterpreter().adaptivePredict(_input,0,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L383">				setState(282);</span>
<span class="fc" id="L384">				packageDeclaration();</span>
				}
				break;
			}
<span class="fc" id="L388">			setState(288);</span>
<span class="fc" id="L389">			_errHandler.sync(this);</span>
<span class="fc" id="L390">			_alt = getInterpreter().adaptivePredict(_input,1,_ctx);</span>
<span class="pc bpc" id="L391" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L395">					setState(285);</span>
<span class="fc" id="L396">					importDeclaration();</span>
					}
					} 
				}
<span class="fc" id="L400">				setState(290);</span>
<span class="fc" id="L401">				_errHandler.sync(this);</span>
<span class="fc" id="L402">				_alt = getInterpreter().adaptivePredict(_input,1,_ctx);</span>
			}
<span class="fc" id="L404">			setState(294);</span>
<span class="fc" id="L405">			_errHandler.sync(this);</span>
<span class="fc" id="L406">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L407" title="2 of 8 branches missed.">			while (((((_la - 39)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 39)) &amp; ((1L &lt;&lt; (FINAL - 39)) | (1L &lt;&lt; (ABSTRACT - 39)) | (1L &lt;&lt; (STRICTFP - 39)) | (1L &lt;&lt; (SEMI - 39)) | (1L &lt;&lt; (LITERAL_PRIVATE - 39)) | (1L &lt;&lt; (LITERAL_PUBLIC - 39)) | (1L &lt;&lt; (LITERAL_PROTECTED - 39)) | (1L &lt;&lt; (LITERAL_STATIC - 39)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 39)) | (1L &lt;&lt; (LITERAL_NATIVE - 39)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 39)) | (1L &lt;&lt; (LITERAL_VOLATILE - 39)) | (1L &lt;&lt; (LITERAL_CLASS - 39)) | (1L &lt;&lt; (LITERAL_INTERFACE - 39)) | (1L &lt;&lt; (LITERAL_DEFAULT - 39)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L410">				setState(291);</span>
<span class="fc" id="L411">				typeDeclaration();</span>
				}
				}
<span class="fc" id="L414">				setState(296);</span>
<span class="fc" id="L415">				_errHandler.sync(this);</span>
<span class="fc" id="L416">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L418">			setState(297);</span>
<span class="fc" id="L419">			match(EOF);</span>
			}
		}
<span class="fc" id="L422">		catch (RecognitionException re) {</span>
<span class="fc" id="L423">			_localctx.exception = re;</span>
<span class="nc" id="L424">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L425">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L428">			exitRule();</span>
		}
<span class="fc" id="L430">		return _localctx;</span>
	}

	public static class PackageDeclarationContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="fc" id="L435">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
<span class="fc" id="L437">		public TerminalNode LITERAL_PACKAGE() { return getToken(JavaLanguageParser.LITERAL_PACKAGE, 0); }</span>
		public QualifiedNameContext qualifiedName() {
<span class="fc" id="L439">			return getRuleContext(QualifiedNameContext.class,0);</span>
		}
<span class="fc" id="L441">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public PackageDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L443">			super(parent, invokingState);</span>
<span class="fc" id="L444">		}</span>
<span class="nc" id="L445">		@Override public int getRuleIndex() { return RULE_packageDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPackageDeclaration(this);</span>
<span class="nc" id="L449">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PackageDeclarationContext packageDeclaration() throws RecognitionException {
<span class="fc" id="L454">		PackageDeclarationContext _localctx = new PackageDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L455">		enterRule(_localctx, 2, RULE_packageDeclaration);</span>
		try {
<span class="fc" id="L457">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L459">			setState(299);</span>
<span class="fc" id="L460">			annotations(true);</span>
<span class="fc" id="L461">			setState(300);</span>
<span class="fc" id="L462">			match(LITERAL_PACKAGE);</span>
<span class="fc" id="L463">			setState(301);</span>
<span class="fc" id="L464">			qualifiedName();</span>
<span class="fc" id="L465">			setState(302);</span>
<span class="fc" id="L466">			match(SEMI);</span>
			}
		}
<span class="nc" id="L469">		catch (RecognitionException re) {</span>
<span class="nc" id="L470">			_localctx.exception = re;</span>
<span class="nc" id="L471">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L472">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L475">			exitRule();</span>
		}
<span class="fc" id="L477">		return _localctx;</span>
	}

	public static class ImportDeclarationContext extends ParserRuleContext {
		public ImportDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L482">			super(parent, invokingState);</span>
<span class="fc" id="L483">		}</span>
<span class="nc" id="L484">		@Override public int getRuleIndex() { return RULE_importDeclaration; }</span>
	 
<span class="fc" id="L486">		public ImportDeclarationContext() { }</span>
		public void copyFrom(ImportDeclarationContext ctx) {
<span class="fc" id="L488">			super.copyFrom(ctx);</span>
<span class="fc" id="L489">		}</span>
	}
	public static class SingleSemiImportContext extends ImportDeclarationContext {
<span class="fc" id="L492">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L493">		public SingleSemiImportContext(ImportDeclarationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSingleSemiImport(this);</span>
<span class="nc" id="L497">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ImportDecContext extends ImportDeclarationContext {
<span class="nc" id="L501">		public TerminalNode IMPORT() { return getToken(JavaLanguageParser.IMPORT, 0); }</span>
		public QualifiedNameContext qualifiedName() {
<span class="fc" id="L503">			return getRuleContext(QualifiedNameContext.class,0);</span>
		}
<span class="fc" id="L505">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L506">		public TerminalNode LITERAL_STATIC() { return getToken(JavaLanguageParser.LITERAL_STATIC, 0); }</span>
<span class="fc" id="L507">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L508">		public TerminalNode STAR() { return getToken(JavaLanguageParser.STAR, 0); }</span>
<span class="fc" id="L509">		public ImportDecContext(ImportDeclarationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitImportDec(this);</span>
<span class="nc" id="L513">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ImportDeclarationContext importDeclaration() throws RecognitionException {
<span class="fc" id="L518">		ImportDeclarationContext _localctx = new ImportDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L519">		enterRule(_localctx, 4, RULE_importDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L522">			setState(316);</span>
<span class="fc" id="L523">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L524" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case IMPORT:
<span class="fc" id="L526">				_localctx = new ImportDecContext(_localctx);</span>
<span class="fc" id="L527">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L529">				setState(304);</span>
<span class="fc" id="L530">				match(IMPORT);</span>
<span class="fc" id="L531">				setState(306);</span>
<span class="fc" id="L532">				_errHandler.sync(this);</span>
<span class="fc" id="L533">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">				if (_la==LITERAL_STATIC) {</span>
					{
<span class="fc" id="L536">					setState(305);</span>
<span class="fc" id="L537">					match(LITERAL_STATIC);</span>
					}
				}

<span class="fc" id="L541">				setState(308);</span>
<span class="fc" id="L542">				qualifiedName();</span>
<span class="fc" id="L543">				setState(311);</span>
<span class="fc" id="L544">				_errHandler.sync(this);</span>
<span class="fc" id="L545">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">				if (_la==DOT) {</span>
					{
<span class="fc" id="L548">					setState(309);</span>
<span class="fc" id="L549">					match(DOT);</span>
<span class="fc" id="L550">					setState(310);</span>
<span class="fc" id="L551">					match(STAR);</span>
					}
				}

<span class="fc" id="L555">				setState(313);</span>
<span class="fc" id="L556">				match(SEMI);</span>
				}
<span class="fc" id="L558">				break;</span>
			case SEMI:
<span class="fc" id="L560">				_localctx = new SingleSemiImportContext(_localctx);</span>
<span class="fc" id="L561">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L563">				setState(315);</span>
<span class="fc" id="L564">				match(SEMI);</span>
				}
<span class="fc" id="L566">				break;</span>
			default:
<span class="nc" id="L568">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L571">		catch (RecognitionException re) {</span>
<span class="nc" id="L572">			_localctx.exception = re;</span>
<span class="nc" id="L573">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L574">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L577">			exitRule();</span>
		}
<span class="fc" id="L579">		return _localctx;</span>
	}

	public static class TypeDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L584">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public TypesContext type;
		public Token SEMI;
<span class="fc" id="L587">		public List&lt;Token&gt; semi = new ArrayList&lt;Token&gt;();</span>
		public TypesContext types() {
<span class="nc" id="L589">			return getRuleContext(TypesContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L592">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L595">			return getRuleContext(ModifierContext.class,i);</span>
		}
<span class="nc" id="L597">		public List&lt;TerminalNode&gt; SEMI() { return getTokens(JavaLanguageParser.SEMI); }</span>
		public TerminalNode SEMI(int i) {
<span class="nc" id="L599">			return getToken(JavaLanguageParser.SEMI, i);</span>
		}
		public TypeDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L602">			super(parent, invokingState);</span>
<span class="fc" id="L603">		}</span>
<span class="nc" id="L604">		@Override public int getRuleIndex() { return RULE_typeDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeDeclaration(this);</span>
<span class="nc" id="L608">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeDeclarationContext typeDeclaration() throws RecognitionException {
<span class="fc" id="L613">		TypeDeclarationContext _localctx = new TypeDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L614">		enterRule(_localctx, 6, RULE_typeDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L617">			setState(330);</span>
<span class="fc" id="L618">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L619" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
			case ABSTRACT:
			case STRICTFP:
			case LITERAL_PRIVATE:
			case LITERAL_PUBLIC:
			case LITERAL_PROTECTED:
			case LITERAL_STATIC:
			case LITERAL_TRANSIENT:
			case LITERAL_NATIVE:
			case LITERAL_SYNCHRONIZED:
			case LITERAL_VOLATILE:
			case LITERAL_CLASS:
			case LITERAL_INTERFACE:
			case LITERAL_DEFAULT:
			case ENUM:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
<span class="fc" id="L639">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L641">				setState(321);</span>
<span class="fc" id="L642">				_errHandler.sync(this);</span>
<span class="fc" id="L643">				_alt = getInterpreter().adaptivePredict(_input,6,_ctx);</span>
<span class="pc bpc" id="L644" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L648">						setState(318);</span>
<span class="fc" id="L649">						((TypeDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L650">						((TypeDeclarationContext)_localctx).mods.add(((TypeDeclarationContext)_localctx).modifier);</span>
						}
						} 
					}
<span class="fc" id="L654">					setState(323);</span>
<span class="fc" id="L655">					_errHandler.sync(this);</span>
<span class="fc" id="L656">					_alt = getInterpreter().adaptivePredict(_input,6,_ctx);</span>
				}
<span class="fc" id="L658">				setState(324);</span>
<span class="fc" id="L659">				((TypeDeclarationContext)_localctx).type = types(_localctx.mods);</span>
				}
<span class="fc" id="L661">				break;</span>
			case SEMI:
<span class="fc" id="L663">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L665">				setState(326); </span>
<span class="fc" id="L666">				_errHandler.sync(this);</span>
<span class="fc" id="L667">				_alt = 1;</span>
				do {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">					switch (_alt) {</span>
					case 1:
						{
						{
<span class="fc" id="L673">						setState(325);</span>
<span class="fc" id="L674">						((TypeDeclarationContext)_localctx).SEMI = match(SEMI);</span>
<span class="fc" id="L675">						((TypeDeclarationContext)_localctx).semi.add(((TypeDeclarationContext)_localctx).SEMI);</span>
						}
						}
<span class="fc" id="L678">						break;</span>
					default:
<span class="nc" id="L680">						throw new NoViableAltException(this);</span>
					}
<span class="fc" id="L682">					setState(328); </span>
<span class="fc" id="L683">					_errHandler.sync(this);</span>
<span class="fc" id="L684">					_alt = getInterpreter().adaptivePredict(_input,7,_ctx);</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">				} while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );</span>
				}
<span class="nc" id="L687">				break;</span>
			default:
<span class="nc" id="L689">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L692">		catch (RecognitionException re) {</span>
<span class="nc" id="L693">			_localctx.exception = re;</span>
<span class="nc" id="L694">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L695">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L698">			exitRule();</span>
		}
<span class="fc" id="L700">		return _localctx;</span>
	}

	public static class TypesContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public ClassDeclarationContext classDeclaration() {
<span class="nc" id="L706">			return getRuleContext(ClassDeclarationContext.class,0);</span>
		}
		public EnumDeclarationContext enumDeclaration() {
<span class="nc" id="L709">			return getRuleContext(EnumDeclarationContext.class,0);</span>
		}
		public InterfaceDeclarationContext interfaceDeclaration() {
<span class="nc" id="L712">			return getRuleContext(InterfaceDeclarationContext.class,0);</span>
		}
		public AnnotationTypeDeclarationContext annotationTypeDeclaration() {
<span class="nc" id="L715">			return getRuleContext(AnnotationTypeDeclarationContext.class,0);</span>
		}
		public RecordDeclarationContext recordDeclaration() {
<span class="nc" id="L718">			return getRuleContext(RecordDeclarationContext.class,0);</span>
		}
<span class="nc" id="L720">		public TypesContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public TypesContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L722">			super(parent, invokingState);</span>
<span class="fc" id="L723">			this.mods = mods;</span>
<span class="fc" id="L724">		}</span>
<span class="nc" id="L725">		@Override public int getRuleIndex() { return RULE_types; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypes(this);</span>
<span class="nc" id="L729">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypesContext types(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L734">		TypesContext _localctx = new TypesContext(_ctx, getState(), mods);</span>
<span class="fc" id="L735">		enterRule(_localctx, 8, RULE_types);</span>
		try {
<span class="fc" id="L737">			setState(337);</span>
<span class="fc" id="L738">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L739" title="1 of 6 branches missed.">			switch (_input.LA(1)) {</span>
			case LITERAL_CLASS:
<span class="fc" id="L741">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L743">				setState(332);</span>
<span class="fc" id="L744">				classDeclaration(mods);</span>
				}
<span class="fc" id="L746">				break;</span>
			case ENUM:
<span class="fc" id="L748">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L750">				setState(333);</span>
<span class="fc" id="L751">				enumDeclaration(mods);</span>
				}
<span class="fc" id="L753">				break;</span>
			case LITERAL_INTERFACE:
<span class="fc" id="L755">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L757">				setState(334);</span>
<span class="fc" id="L758">				interfaceDeclaration(mods);</span>
				}
<span class="fc" id="L760">				break;</span>
			case AT:
<span class="fc" id="L762">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L764">				setState(335);</span>
<span class="fc" id="L765">				annotationTypeDeclaration(mods);</span>
				}
<span class="fc" id="L767">				break;</span>
			case LITERAL_RECORD:
<span class="fc" id="L769">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L771">				setState(336);</span>
<span class="fc" id="L772">				recordDeclaration(mods);</span>
				}
<span class="fc" id="L774">				break;</span>
			default:
<span class="nc" id="L776">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L779">		catch (RecognitionException re) {</span>
<span class="nc" id="L780">			_localctx.exception = re;</span>
<span class="nc" id="L781">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L782">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L785">			exitRule();</span>
		}
<span class="fc" id="L787">		return _localctx;</span>
	}

	public static class ModifierContext extends ParserRuleContext {
		public AnnotationContext annotation() {
<span class="nc" id="L792">			return getRuleContext(AnnotationContext.class,0);</span>
		}
<span class="nc" id="L794">		public TerminalNode LITERAL_PUBLIC() { return getToken(JavaLanguageParser.LITERAL_PUBLIC, 0); }</span>
<span class="nc" id="L795">		public TerminalNode LITERAL_PROTECTED() { return getToken(JavaLanguageParser.LITERAL_PROTECTED, 0); }</span>
<span class="nc" id="L796">		public TerminalNode LITERAL_PRIVATE() { return getToken(JavaLanguageParser.LITERAL_PRIVATE, 0); }</span>
<span class="nc" id="L797">		public TerminalNode LITERAL_STATIC() { return getToken(JavaLanguageParser.LITERAL_STATIC, 0); }</span>
<span class="nc" id="L798">		public TerminalNode ABSTRACT() { return getToken(JavaLanguageParser.ABSTRACT, 0); }</span>
<span class="nc" id="L799">		public TerminalNode LITERAL_DEFAULT() { return getToken(JavaLanguageParser.LITERAL_DEFAULT, 0); }</span>
<span class="nc" id="L800">		public TerminalNode FINAL() { return getToken(JavaLanguageParser.FINAL, 0); }</span>
<span class="nc" id="L801">		public TerminalNode STRICTFP() { return getToken(JavaLanguageParser.STRICTFP, 0); }</span>
<span class="nc" id="L802">		public TerminalNode LITERAL_NATIVE() { return getToken(JavaLanguageParser.LITERAL_NATIVE, 0); }</span>
<span class="nc" id="L803">		public TerminalNode LITERAL_SYNCHRONIZED() { return getToken(JavaLanguageParser.LITERAL_SYNCHRONIZED, 0); }</span>
<span class="nc" id="L804">		public TerminalNode LITERAL_TRANSIENT() { return getToken(JavaLanguageParser.LITERAL_TRANSIENT, 0); }</span>
<span class="nc" id="L805">		public TerminalNode LITERAL_VOLATILE() { return getToken(JavaLanguageParser.LITERAL_VOLATILE, 0); }</span>
<span class="nc" id="L806">		public TerminalNode LITERAL_NON_SEALED() { return getToken(JavaLanguageParser.LITERAL_NON_SEALED, 0); }</span>
<span class="nc" id="L807">		public TerminalNode LITERAL_SEALED() { return getToken(JavaLanguageParser.LITERAL_SEALED, 0); }</span>
		public ModifierContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L809">			super(parent, invokingState);</span>
<span class="fc" id="L810">		}</span>
<span class="nc" id="L811">		@Override public int getRuleIndex() { return RULE_modifier; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitModifier(this);</span>
<span class="nc" id="L815">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ModifierContext modifier() throws RecognitionException {
<span class="fc" id="L820">		ModifierContext _localctx = new ModifierContext(_ctx, getState());</span>
<span class="fc" id="L821">		enterRule(_localctx, 10, RULE_modifier);</span>
		try {
<span class="fc" id="L823">			setState(354);</span>
<span class="fc" id="L824">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L825" title="1 of 16 branches missed.">			switch (_input.LA(1)) {</span>
			case AT:
<span class="fc" id="L827">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L829">				setState(339);</span>
<span class="fc" id="L830">				annotation();</span>
				}
<span class="fc" id="L832">				break;</span>
			case LITERAL_PUBLIC:
<span class="fc" id="L834">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L836">				setState(340);</span>
<span class="fc" id="L837">				match(LITERAL_PUBLIC);</span>
				}
<span class="fc" id="L839">				break;</span>
			case LITERAL_PROTECTED:
<span class="fc" id="L841">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L843">				setState(341);</span>
<span class="fc" id="L844">				match(LITERAL_PROTECTED);</span>
				}
<span class="fc" id="L846">				break;</span>
			case LITERAL_PRIVATE:
<span class="fc" id="L848">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L850">				setState(342);</span>
<span class="fc" id="L851">				match(LITERAL_PRIVATE);</span>
				}
<span class="fc" id="L853">				break;</span>
			case LITERAL_STATIC:
<span class="fc" id="L855">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L857">				setState(343);</span>
<span class="fc" id="L858">				match(LITERAL_STATIC);</span>
				}
<span class="fc" id="L860">				break;</span>
			case ABSTRACT:
<span class="fc" id="L862">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L864">				setState(344);</span>
<span class="fc" id="L865">				match(ABSTRACT);</span>
				}
<span class="fc" id="L867">				break;</span>
			case LITERAL_DEFAULT:
<span class="fc" id="L869">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L871">				setState(345);</span>
<span class="fc" id="L872">				match(LITERAL_DEFAULT);</span>
				}
<span class="fc" id="L874">				break;</span>
			case FINAL:
<span class="fc" id="L876">				enterOuterAlt(_localctx, 8);</span>
				{
<span class="fc" id="L878">				setState(346);</span>
<span class="fc" id="L879">				match(FINAL);</span>
				}
<span class="fc" id="L881">				break;</span>
			case STRICTFP:
<span class="fc" id="L883">				enterOuterAlt(_localctx, 9);</span>
				{
<span class="fc" id="L885">				setState(347);</span>
<span class="fc" id="L886">				match(STRICTFP);</span>
				}
<span class="fc" id="L888">				break;</span>
			case LITERAL_NATIVE:
<span class="fc" id="L890">				enterOuterAlt(_localctx, 10);</span>
				{
<span class="fc" id="L892">				setState(348);</span>
<span class="fc" id="L893">				match(LITERAL_NATIVE);</span>
				}
<span class="fc" id="L895">				break;</span>
			case LITERAL_SYNCHRONIZED:
<span class="fc" id="L897">				enterOuterAlt(_localctx, 11);</span>
				{
<span class="fc" id="L899">				setState(349);</span>
<span class="fc" id="L900">				match(LITERAL_SYNCHRONIZED);</span>
				}
<span class="fc" id="L902">				break;</span>
			case LITERAL_TRANSIENT:
<span class="fc" id="L904">				enterOuterAlt(_localctx, 12);</span>
				{
<span class="fc" id="L906">				setState(350);</span>
<span class="fc" id="L907">				match(LITERAL_TRANSIENT);</span>
				}
<span class="fc" id="L909">				break;</span>
			case LITERAL_VOLATILE:
<span class="fc" id="L911">				enterOuterAlt(_localctx, 13);</span>
				{
<span class="fc" id="L913">				setState(351);</span>
<span class="fc" id="L914">				match(LITERAL_VOLATILE);</span>
				}
<span class="fc" id="L916">				break;</span>
			case LITERAL_NON_SEALED:
<span class="fc" id="L918">				enterOuterAlt(_localctx, 14);</span>
				{
<span class="fc" id="L920">				setState(352);</span>
<span class="fc" id="L921">				match(LITERAL_NON_SEALED);</span>
				}
<span class="fc" id="L923">				break;</span>
			case LITERAL_SEALED:
<span class="fc" id="L925">				enterOuterAlt(_localctx, 15);</span>
				{
<span class="fc" id="L927">				setState(353);</span>
<span class="fc" id="L928">				match(LITERAL_SEALED);</span>
				}
<span class="fc" id="L930">				break;</span>
			default:
<span class="nc" id="L932">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L935">		catch (RecognitionException re) {</span>
<span class="nc" id="L936">			_localctx.exception = re;</span>
<span class="nc" id="L937">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L938">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L941">			exitRule();</span>
		}
<span class="fc" id="L943">		return _localctx;</span>
	}

	public static class VariableModifierContext extends ParserRuleContext {
<span class="nc" id="L947">		public TerminalNode FINAL() { return getToken(JavaLanguageParser.FINAL, 0); }</span>
		public AnnotationContext annotation() {
<span class="nc" id="L949">			return getRuleContext(AnnotationContext.class,0);</span>
		}
		public VariableModifierContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L952">			super(parent, invokingState);</span>
<span class="fc" id="L953">		}</span>
<span class="nc" id="L954">		@Override public int getRuleIndex() { return RULE_variableModifier; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableModifier(this);</span>
<span class="nc" id="L958">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableModifierContext variableModifier() throws RecognitionException {
<span class="fc" id="L963">		VariableModifierContext _localctx = new VariableModifierContext(_ctx, getState());</span>
<span class="fc" id="L964">		enterRule(_localctx, 12, RULE_variableModifier);</span>
		try {
<span class="fc" id="L966">			setState(358);</span>
<span class="fc" id="L967">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L968" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
<span class="fc" id="L970">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L972">				setState(356);</span>
<span class="fc" id="L973">				match(FINAL);</span>
				}
<span class="fc" id="L975">				break;</span>
			case AT:
<span class="fc" id="L977">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L979">				setState(357);</span>
<span class="fc" id="L980">				annotation();</span>
				}
<span class="fc" id="L982">				break;</span>
			default:
<span class="nc" id="L984">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L987">		catch (RecognitionException re) {</span>
<span class="nc" id="L988">			_localctx.exception = re;</span>
<span class="nc" id="L989">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L990">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L993">			exitRule();</span>
		}
<span class="fc" id="L995">		return _localctx;</span>
	}

	public static class ClassDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L1000">		public TerminalNode LITERAL_CLASS() { return getToken(JavaLanguageParser.LITERAL_CLASS, 0); }</span>
		public IdContext id() {
<span class="nc" id="L1002">			return getRuleContext(IdContext.class,0);</span>
		}
		public ClassBodyContext classBody() {
<span class="nc" id="L1005">			return getRuleContext(ClassBodyContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L1008">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public ClassExtendsContext classExtends() {
<span class="nc" id="L1011">			return getRuleContext(ClassExtendsContext.class,0);</span>
		}
		public ImplementsClauseContext implementsClause() {
<span class="nc" id="L1014">			return getRuleContext(ImplementsClauseContext.class,0);</span>
		}
		public PermittedSubclassesAndInterfacesContext permittedSubclassesAndInterfaces() {
<span class="nc" id="L1017">			return getRuleContext(PermittedSubclassesAndInterfacesContext.class,0);</span>
		}
<span class="nc" id="L1019">		public ClassDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public ClassDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L1021">			super(parent, invokingState);</span>
<span class="fc" id="L1022">			this.mods = mods;</span>
<span class="fc" id="L1023">		}</span>
<span class="nc" id="L1024">		@Override public int getRuleIndex() { return RULE_classDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassDeclaration(this);</span>
<span class="nc" id="L1028">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassDeclarationContext classDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L1033">		ClassDeclarationContext _localctx = new ClassDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L1034">		enterRule(_localctx, 14, RULE_classDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L1037">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1039">			setState(360);</span>
<span class="fc" id="L1040">			match(LITERAL_CLASS);</span>
<span class="fc" id="L1041">			setState(361);</span>
<span class="fc" id="L1042">			id();</span>
<span class="fc" id="L1043">			setState(363);</span>
<span class="fc" id="L1044">			_errHandler.sync(this);</span>
<span class="fc" id="L1045">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L1048">				setState(362);</span>
<span class="fc" id="L1049">				typeParameters();</span>
				}
			}

<span class="fc" id="L1053">			setState(366);</span>
<span class="fc" id="L1054">			_errHandler.sync(this);</span>
<span class="fc" id="L1055">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">			if (_la==EXTENDS_CLAUSE) {</span>
				{
<span class="fc" id="L1058">				setState(365);</span>
<span class="fc" id="L1059">				classExtends();</span>
				}
			}

<span class="fc" id="L1063">			setState(369);</span>
<span class="fc" id="L1064">			_errHandler.sync(this);</span>
<span class="fc" id="L1065">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">			if (_la==LITERAL_IMPLEMENTS) {</span>
				{
<span class="fc" id="L1068">				setState(368);</span>
<span class="fc" id="L1069">				implementsClause();</span>
				}
			}

<span class="fc" id="L1073">			setState(372);</span>
<span class="fc" id="L1074">			_errHandler.sync(this);</span>
<span class="fc" id="L1075">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">			if (_la==LITERAL_PERMITS) {</span>
				{
<span class="fc" id="L1078">				setState(371);</span>
<span class="fc" id="L1079">				permittedSubclassesAndInterfaces();</span>
				}
			}

<span class="fc" id="L1083">			setState(374);</span>
<span class="fc" id="L1084">			classBody();</span>
			}
		}
<span class="nc" id="L1087">		catch (RecognitionException re) {</span>
<span class="nc" id="L1088">			_localctx.exception = re;</span>
<span class="nc" id="L1089">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1090">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1093">			exitRule();</span>
		}
<span class="fc" id="L1095">		return _localctx;</span>
	}

	public static class RecordDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L1100">		public TerminalNode LITERAL_RECORD() { return getToken(JavaLanguageParser.LITERAL_RECORD, 0); }</span>
		public IdContext id() {
<span class="nc" id="L1102">			return getRuleContext(IdContext.class,0);</span>
		}
		public RecordComponentsListContext recordComponentsList() {
<span class="nc" id="L1105">			return getRuleContext(RecordComponentsListContext.class,0);</span>
		}
		public RecordBodyContext recordBody() {
<span class="nc" id="L1108">			return getRuleContext(RecordBodyContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L1111">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public ImplementsClauseContext implementsClause() {
<span class="nc" id="L1114">			return getRuleContext(ImplementsClauseContext.class,0);</span>
		}
<span class="nc" id="L1116">		public RecordDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public RecordDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L1118">			super(parent, invokingState);</span>
<span class="fc" id="L1119">			this.mods = mods;</span>
<span class="fc" id="L1120">		}</span>
<span class="nc" id="L1121">		@Override public int getRuleIndex() { return RULE_recordDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordDeclaration(this);</span>
<span class="nc" id="L1125">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordDeclarationContext recordDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L1130">		RecordDeclarationContext _localctx = new RecordDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L1131">		enterRule(_localctx, 16, RULE_recordDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L1134">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1136">			setState(376);</span>
<span class="fc" id="L1137">			match(LITERAL_RECORD);</span>
<span class="fc" id="L1138">			setState(377);</span>
<span class="fc" id="L1139">			id();</span>
<span class="fc" id="L1140">			setState(379);</span>
<span class="fc" id="L1141">			_errHandler.sync(this);</span>
<span class="fc" id="L1142">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L1145">				setState(378);</span>
<span class="fc" id="L1146">				typeParameters();</span>
				}
			}

<span class="fc" id="L1150">			setState(381);</span>
<span class="fc" id="L1151">			recordComponentsList();</span>
<span class="fc" id="L1152">			setState(383);</span>
<span class="fc" id="L1153">			_errHandler.sync(this);</span>
<span class="fc" id="L1154">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">			if (_la==LITERAL_IMPLEMENTS) {</span>
				{
<span class="fc" id="L1157">				setState(382);</span>
<span class="fc" id="L1158">				implementsClause();</span>
				}
			}

<span class="fc" id="L1162">			setState(385);</span>
<span class="fc" id="L1163">			recordBody();</span>
			}
		}
<span class="nc" id="L1166">		catch (RecognitionException re) {</span>
<span class="nc" id="L1167">			_localctx.exception = re;</span>
<span class="nc" id="L1168">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1169">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1172">			exitRule();</span>
		}
<span class="fc" id="L1174">		return _localctx;</span>
	}

	public static class RecordComponentsListContext extends ParserRuleContext {
<span class="fc" id="L1178">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L1179">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public RecordComponentsContext recordComponents() {
<span class="fc" id="L1181">			return getRuleContext(RecordComponentsContext.class,0);</span>
		}
		public RecordComponentsListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1184">			super(parent, invokingState);</span>
<span class="fc" id="L1185">		}</span>
<span class="nc" id="L1186">		@Override public int getRuleIndex() { return RULE_recordComponentsList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordComponentsList(this);</span>
<span class="nc" id="L1190">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordComponentsListContext recordComponentsList() throws RecognitionException {
<span class="fc" id="L1195">		RecordComponentsListContext _localctx = new RecordComponentsListContext(_ctx, getState());</span>
<span class="fc" id="L1196">		enterRule(_localctx, 18, RULE_recordComponentsList);</span>
		int _la;
		try {
<span class="fc" id="L1199">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1201">			setState(387);</span>
<span class="fc" id="L1202">			match(LPAREN);</span>
<span class="fc" id="L1203">			setState(389);</span>
<span class="fc" id="L1204">			_errHandler.sync(this);</span>
<span class="fc" id="L1205">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L1206" title="2 of 8 branches missed.">			if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)))) != 0)) {</span>
				{
<span class="fc" id="L1208">				setState(388);</span>
<span class="fc" id="L1209">				recordComponents();</span>
				}
			}

<span class="fc" id="L1213">			setState(391);</span>
<span class="fc" id="L1214">			match(RPAREN);</span>
			}
		}
<span class="nc" id="L1217">		catch (RecognitionException re) {</span>
<span class="nc" id="L1218">			_localctx.exception = re;</span>
<span class="nc" id="L1219">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1220">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1223">			exitRule();</span>
		}
<span class="fc" id="L1225">		return _localctx;</span>
	}

	public static class RecordComponentsContext extends ParserRuleContext {
		public List&lt;RecordComponentContext&gt; recordComponent() {
<span class="nc" id="L1230">			return getRuleContexts(RecordComponentContext.class);</span>
		}
		public RecordComponentContext recordComponent(int i) {
<span class="nc" id="L1233">			return getRuleContext(RecordComponentContext.class,i);</span>
		}
<span class="nc" id="L1235">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L1237">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public LastRecordComponentContext lastRecordComponent() {
<span class="nc" id="L1240">			return getRuleContext(LastRecordComponentContext.class,0);</span>
		}
		public RecordComponentsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1243">			super(parent, invokingState);</span>
<span class="fc" id="L1244">		}</span>
<span class="nc" id="L1245">		@Override public int getRuleIndex() { return RULE_recordComponents; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordComponents(this);</span>
<span class="nc" id="L1249">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordComponentsContext recordComponents() throws RecognitionException {
<span class="fc" id="L1254">		RecordComponentsContext _localctx = new RecordComponentsContext(_ctx, getState());</span>
<span class="fc" id="L1255">		enterRule(_localctx, 20, RULE_recordComponents);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L1259">			setState(406);</span>
<span class="fc" id="L1260">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L1261" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,21,_ctx) ) {</span>
			case 1:
<span class="fc" id="L1263">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L1265">				setState(393);</span>
<span class="fc" id="L1266">				recordComponent();</span>
<span class="fc" id="L1267">				setState(398);</span>
<span class="fc" id="L1268">				_errHandler.sync(this);</span>
<span class="fc" id="L1269">				_alt = getInterpreter().adaptivePredict(_input,19,_ctx);</span>
<span class="pc bpc" id="L1270" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L1274">						setState(394);</span>
<span class="fc" id="L1275">						match(COMMA);</span>
<span class="fc" id="L1276">						setState(395);</span>
<span class="fc" id="L1277">						recordComponent();</span>
						}
						} 
					}
<span class="fc" id="L1281">					setState(400);</span>
<span class="fc" id="L1282">					_errHandler.sync(this);</span>
<span class="fc" id="L1283">					_alt = getInterpreter().adaptivePredict(_input,19,_ctx);</span>
				}
<span class="fc" id="L1285">				setState(403);</span>
<span class="fc" id="L1286">				_errHandler.sync(this);</span>
<span class="fc" id="L1287">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">				if (_la==COMMA) {</span>
					{
<span class="fc" id="L1290">					setState(401);</span>
<span class="fc" id="L1291">					match(COMMA);</span>
<span class="fc" id="L1292">					setState(402);</span>
<span class="fc" id="L1293">					lastRecordComponent();</span>
					}
				}

				}
				break;
			case 2:
<span class="fc" id="L1300">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L1302">				setState(405);</span>
<span class="fc" id="L1303">				lastRecordComponent();</span>
				}
				break;
			}
		}
<span class="nc" id="L1308">		catch (RecognitionException re) {</span>
<span class="nc" id="L1309">			_localctx.exception = re;</span>
<span class="nc" id="L1310">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1311">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1314">			exitRule();</span>
		}
<span class="fc" id="L1316">		return _localctx;</span>
	}

	public static class RecordComponentContext extends ParserRuleContext {
		public TypeTypeContext type;
		public AnnotationsContext annotations() {
<span class="nc" id="L1322">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L1325">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L1328">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public RecordComponentContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1331">			super(parent, invokingState);</span>
<span class="fc" id="L1332">		}</span>
<span class="nc" id="L1333">		@Override public int getRuleIndex() { return RULE_recordComponent; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordComponent(this);</span>
<span class="nc" id="L1337">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordComponentContext recordComponent() throws RecognitionException {
<span class="fc" id="L1342">		RecordComponentContext _localctx = new RecordComponentContext(_ctx, getState());</span>
<span class="fc" id="L1343">		enterRule(_localctx, 22, RULE_recordComponent);</span>
		try {
<span class="fc" id="L1345">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1347">			setState(408);</span>
<span class="fc" id="L1348">			annotations(true);</span>
<span class="fc" id="L1349">			setState(409);</span>
<span class="fc" id="L1350">			((RecordComponentContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L1351">			setState(410);</span>
<span class="fc" id="L1352">			id();</span>
			}
		}
<span class="nc" id="L1355">		catch (RecognitionException re) {</span>
<span class="nc" id="L1356">			_localctx.exception = re;</span>
<span class="nc" id="L1357">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1358">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1361">			exitRule();</span>
		}
<span class="fc" id="L1363">		return _localctx;</span>
	}

	public static class LastRecordComponentContext extends ParserRuleContext {
		public TypeTypeContext type;
		public AnnotationsContext annotations() {
<span class="nc" id="L1369">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
<span class="nc" id="L1371">		public TerminalNode ELLIPSIS() { return getToken(JavaLanguageParser.ELLIPSIS, 0); }</span>
		public IdContext id() {
<span class="nc" id="L1373">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L1376">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public LastRecordComponentContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1379">			super(parent, invokingState);</span>
<span class="fc" id="L1380">		}</span>
<span class="nc" id="L1381">		@Override public int getRuleIndex() { return RULE_lastRecordComponent; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLastRecordComponent(this);</span>
<span class="nc" id="L1385">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LastRecordComponentContext lastRecordComponent() throws RecognitionException {
<span class="fc" id="L1390">		LastRecordComponentContext _localctx = new LastRecordComponentContext(_ctx, getState());</span>
<span class="fc" id="L1391">		enterRule(_localctx, 24, RULE_lastRecordComponent);</span>
		try {
<span class="fc" id="L1393">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1395">			setState(412);</span>
<span class="fc" id="L1396">			annotations(true);</span>
<span class="fc" id="L1397">			setState(413);</span>
<span class="fc" id="L1398">			((LastRecordComponentContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L1399">			setState(414);</span>
<span class="fc" id="L1400">			match(ELLIPSIS);</span>
<span class="fc" id="L1401">			setState(415);</span>
<span class="fc" id="L1402">			id();</span>
			}
		}
<span class="nc" id="L1405">		catch (RecognitionException re) {</span>
<span class="nc" id="L1406">			_localctx.exception = re;</span>
<span class="nc" id="L1407">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1408">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1411">			exitRule();</span>
		}
<span class="fc" id="L1413">		return _localctx;</span>
	}

	public static class RecordBodyContext extends ParserRuleContext {
<span class="nc" id="L1417">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L1418">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;RecordBodyDeclarationContext&gt; recordBodyDeclaration() {
<span class="nc" id="L1420">			return getRuleContexts(RecordBodyDeclarationContext.class);</span>
		}
		public RecordBodyDeclarationContext recordBodyDeclaration(int i) {
<span class="nc" id="L1423">			return getRuleContext(RecordBodyDeclarationContext.class,i);</span>
		}
		public RecordBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1426">			super(parent, invokingState);</span>
<span class="fc" id="L1427">		}</span>
<span class="nc" id="L1428">		@Override public int getRuleIndex() { return RULE_recordBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1431" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordBody(this);</span>
<span class="nc" id="L1432">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordBodyContext recordBody() throws RecognitionException {
<span class="fc" id="L1437">		RecordBodyContext _localctx = new RecordBodyContext(_ctx, getState());</span>
<span class="fc" id="L1438">		enterRule(_localctx, 26, RULE_recordBody);</span>
		int _la;
		try {
<span class="fc" id="L1441">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1443">			setState(417);</span>
<span class="fc" id="L1444">			match(LCURLY);</span>
<span class="fc" id="L1445">			setState(421);</span>
<span class="fc" id="L1446">			_errHandler.sync(this);</span>
<span class="fc" id="L1447">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L1448" title="2 of 12 branches missed.">			while ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; ABSTRACT) | (1L &lt;&lt; STRICTFP) | (1L &lt;&lt; SEMI) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT) | (1L &lt;&lt; LITERAL_PRIVATE) | (1L &lt;&lt; LITERAL_PUBLIC) | (1L &lt;&lt; LITERAL_PROTECTED))) != 0) || ((((_la - 64)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 64)) &amp; ((1L &lt;&lt; (LITERAL_STATIC - 64)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 64)) | (1L &lt;&lt; (LITERAL_NATIVE - 64)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 64)) | (1L &lt;&lt; (LITERAL_VOLATILE - 64)) | (1L &lt;&lt; (LITERAL_CLASS - 64)) | (1L &lt;&lt; (LITERAL_INTERFACE - 64)) | (1L &lt;&lt; (LCURLY - 64)) | (1L &lt;&lt; (LITERAL_DEFAULT - 64)) | (1L &lt;&lt; (LT - 64)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_YIELD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)) | (1L &lt;&lt; (LITERAL_PERMITS - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L1451">				setState(418);</span>
<span class="fc" id="L1452">				recordBodyDeclaration();</span>
				}
				}
<span class="fc" id="L1455">				setState(423);</span>
<span class="fc" id="L1456">				_errHandler.sync(this);</span>
<span class="fc" id="L1457">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L1459">			setState(424);</span>
<span class="fc" id="L1460">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L1463">		catch (RecognitionException re) {</span>
<span class="nc" id="L1464">			_localctx.exception = re;</span>
<span class="nc" id="L1465">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1466">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1469">			exitRule();</span>
		}
<span class="fc" id="L1471">		return _localctx;</span>
	}

	public static class RecordBodyDeclarationContext extends ParserRuleContext {
		public CompactConstructorDeclarationContext compactConstructorDeclaration() {
<span class="nc" id="L1476">			return getRuleContext(CompactConstructorDeclarationContext.class,0);</span>
		}
		public ClassBodyDeclarationContext classBodyDeclaration() {
<span class="nc" id="L1479">			return getRuleContext(ClassBodyDeclarationContext.class,0);</span>
		}
		public RecordBodyDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1482">			super(parent, invokingState);</span>
<span class="fc" id="L1483">		}</span>
<span class="nc" id="L1484">		@Override public int getRuleIndex() { return RULE_recordBodyDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRecordBodyDeclaration(this);</span>
<span class="nc" id="L1488">			else return visitor.visitChildren(this);</span>
		}
	}

	public final RecordBodyDeclarationContext recordBodyDeclaration() throws RecognitionException {
<span class="fc" id="L1493">		RecordBodyDeclarationContext _localctx = new RecordBodyDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L1494">		enterRule(_localctx, 28, RULE_recordBodyDeclaration);</span>
		try {
<span class="fc" id="L1496">			setState(428);</span>
<span class="fc" id="L1497">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L1498" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,23,_ctx) ) {</span>
			case 1:
<span class="fc" id="L1500">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L1502">				setState(426);</span>
<span class="fc" id="L1503">				compactConstructorDeclaration();</span>
				}
<span class="fc" id="L1505">				break;</span>
			case 2:
<span class="fc" id="L1507">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L1509">				setState(427);</span>
<span class="fc" id="L1510">				classBodyDeclaration();</span>
				}
				break;
			}
		}
<span class="nc" id="L1515">		catch (RecognitionException re) {</span>
<span class="nc" id="L1516">			_localctx.exception = re;</span>
<span class="nc" id="L1517">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1518">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1521">			exitRule();</span>
		}
<span class="fc" id="L1523">		return _localctx;</span>
	}

	public static class CompactConstructorDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L1528">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public IdContext id() {
<span class="fc" id="L1530">			return getRuleContext(IdContext.class,0);</span>
		}
		public ConstructorBlockContext constructorBlock() {
<span class="fc" id="L1533">			return getRuleContext(ConstructorBlockContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L1536">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L1539">			return getRuleContext(ModifierContext.class,i);</span>
		}
		public CompactConstructorDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1542">			super(parent, invokingState);</span>
<span class="fc" id="L1543">		}</span>
<span class="nc" id="L1544">		@Override public int getRuleIndex() { return RULE_compactConstructorDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCompactConstructorDeclaration(this);</span>
<span class="nc" id="L1548">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CompactConstructorDeclarationContext compactConstructorDeclaration() throws RecognitionException {
<span class="fc" id="L1553">		CompactConstructorDeclarationContext _localctx = new CompactConstructorDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L1554">		enterRule(_localctx, 30, RULE_compactConstructorDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L1557">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1559">			setState(433);</span>
<span class="fc" id="L1560">			_errHandler.sync(this);</span>
<span class="fc" id="L1561">			_alt = getInterpreter().adaptivePredict(_input,24,_ctx);</span>
<span class="pc bpc" id="L1562" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L1563" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L1566">					setState(430);</span>
<span class="fc" id="L1567">					((CompactConstructorDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L1568">					((CompactConstructorDeclarationContext)_localctx).mods.add(((CompactConstructorDeclarationContext)_localctx).modifier);</span>
					}
					} 
				}
<span class="fc" id="L1572">				setState(435);</span>
<span class="fc" id="L1573">				_errHandler.sync(this);</span>
<span class="fc" id="L1574">				_alt = getInterpreter().adaptivePredict(_input,24,_ctx);</span>
			}
<span class="fc" id="L1576">			setState(436);</span>
<span class="fc" id="L1577">			id();</span>
<span class="fc" id="L1578">			setState(437);</span>
<span class="fc" id="L1579">			constructorBlock();</span>
			}
		}
<span class="nc" id="L1582">		catch (RecognitionException re) {</span>
<span class="nc" id="L1583">			_localctx.exception = re;</span>
<span class="nc" id="L1584">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1585">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1588">			exitRule();</span>
		}
<span class="fc" id="L1590">		return _localctx;</span>
	}

	public static class ClassExtendsContext extends ParserRuleContext {
		public TypeTypeContext type;
<span class="fc" id="L1595">		public TerminalNode EXTENDS_CLAUSE() { return getToken(JavaLanguageParser.EXTENDS_CLAUSE, 0); }</span>
		public TypeTypeContext typeType() {
<span class="nc" id="L1597">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public ClassExtendsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1600">			super(parent, invokingState);</span>
<span class="fc" id="L1601">		}</span>
<span class="nc" id="L1602">		@Override public int getRuleIndex() { return RULE_classExtends; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1605" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassExtends(this);</span>
<span class="nc" id="L1606">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassExtendsContext classExtends() throws RecognitionException {
<span class="fc" id="L1611">		ClassExtendsContext _localctx = new ClassExtendsContext(_ctx, getState());</span>
<span class="fc" id="L1612">		enterRule(_localctx, 32, RULE_classExtends);</span>
		try {
<span class="fc" id="L1614">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1616">			setState(439);</span>
<span class="fc" id="L1617">			match(EXTENDS_CLAUSE);</span>
<span class="fc" id="L1618">			setState(440);</span>
<span class="fc" id="L1619">			((ClassExtendsContext)_localctx).type = typeType(false);</span>
			}
		}
<span class="nc" id="L1622">		catch (RecognitionException re) {</span>
<span class="nc" id="L1623">			_localctx.exception = re;</span>
<span class="nc" id="L1624">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1625">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1628">			exitRule();</span>
		}
<span class="fc" id="L1630">		return _localctx;</span>
	}

	public static class ImplementsClauseContext extends ParserRuleContext {
<span class="fc" id="L1634">		public TerminalNode LITERAL_IMPLEMENTS() { return getToken(JavaLanguageParser.LITERAL_IMPLEMENTS, 0); }</span>
		public TypeListContext typeList() {
<span class="fc" id="L1636">			return getRuleContext(TypeListContext.class,0);</span>
		}
		public ImplementsClauseContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1639">			super(parent, invokingState);</span>
<span class="fc" id="L1640">		}</span>
<span class="nc" id="L1641">		@Override public int getRuleIndex() { return RULE_implementsClause; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitImplementsClause(this);</span>
<span class="nc" id="L1645">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ImplementsClauseContext implementsClause() throws RecognitionException {
<span class="fc" id="L1650">		ImplementsClauseContext _localctx = new ImplementsClauseContext(_ctx, getState());</span>
<span class="fc" id="L1651">		enterRule(_localctx, 34, RULE_implementsClause);</span>
		try {
<span class="fc" id="L1653">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1655">			setState(442);</span>
<span class="fc" id="L1656">			match(LITERAL_IMPLEMENTS);</span>
<span class="fc" id="L1657">			setState(443);</span>
<span class="fc" id="L1658">			typeList();</span>
			}
		}
<span class="nc" id="L1661">		catch (RecognitionException re) {</span>
<span class="nc" id="L1662">			_localctx.exception = re;</span>
<span class="nc" id="L1663">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1664">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1667">			exitRule();</span>
		}
<span class="fc" id="L1669">		return _localctx;</span>
	}

	public static class TypeParametersContext extends ParserRuleContext {
<span class="fc" id="L1673">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
		public List&lt;TypeParameterContext&gt; typeParameter() {
<span class="nc" id="L1675">			return getRuleContexts(TypeParameterContext.class);</span>
		}
		public TypeParameterContext typeParameter(int i) {
<span class="nc" id="L1678">			return getRuleContext(TypeParameterContext.class,i);</span>
		}
<span class="fc" id="L1680">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
<span class="nc" id="L1681">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L1683">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public TypeParametersContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1686">			super(parent, invokingState);</span>
<span class="fc" id="L1687">		}</span>
<span class="nc" id="L1688">		@Override public int getRuleIndex() { return RULE_typeParameters; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeParameters(this);</span>
<span class="nc" id="L1692">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeParametersContext typeParameters() throws RecognitionException {
<span class="fc" id="L1697">		TypeParametersContext _localctx = new TypeParametersContext(_ctx, getState());</span>
<span class="fc" id="L1698">		enterRule(_localctx, 36, RULE_typeParameters);</span>
		int _la;
		try {
<span class="fc" id="L1701">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1703">			setState(445);</span>
<span class="fc" id="L1704">			match(LT);</span>
<span class="fc" id="L1705">			setState(446);</span>
<span class="fc" id="L1706">			typeParameter();</span>
<span class="fc" id="L1707">			setState(451);</span>
<span class="fc" id="L1708">			_errHandler.sync(this);</span>
<span class="fc" id="L1709">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L1713">				setState(447);</span>
<span class="fc" id="L1714">				match(COMMA);</span>
<span class="fc" id="L1715">				setState(448);</span>
<span class="fc" id="L1716">				typeParameter();</span>
				}
				}
<span class="fc" id="L1719">				setState(453);</span>
<span class="fc" id="L1720">				_errHandler.sync(this);</span>
<span class="fc" id="L1721">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L1723">			setState(454);</span>
<span class="fc" id="L1724">			match(GT);</span>
			}
		}
<span class="nc" id="L1727">		catch (RecognitionException re) {</span>
<span class="nc" id="L1728">			_localctx.exception = re;</span>
<span class="nc" id="L1729">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1730">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1733">			exitRule();</span>
		}
<span class="fc" id="L1735">		return _localctx;</span>
	}

	public static class TypeParameterContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="nc" id="L1740">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L1743">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeUpperBoundsContext typeUpperBounds() {
<span class="nc" id="L1746">			return getRuleContext(TypeUpperBoundsContext.class,0);</span>
		}
		public TypeParameterContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1749">			super(parent, invokingState);</span>
<span class="fc" id="L1750">		}</span>
<span class="nc" id="L1751">		@Override public int getRuleIndex() { return RULE_typeParameter; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeParameter(this);</span>
<span class="nc" id="L1755">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeParameterContext typeParameter() throws RecognitionException {
<span class="fc" id="L1760">		TypeParameterContext _localctx = new TypeParameterContext(_ctx, getState());</span>
<span class="fc" id="L1761">		enterRule(_localctx, 38, RULE_typeParameter);</span>
		int _la;
		try {
<span class="fc" id="L1764">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1766">			setState(456);</span>
<span class="fc" id="L1767">			annotations(false);</span>
<span class="fc" id="L1768">			setState(457);</span>
<span class="fc" id="L1769">			id();</span>
<span class="fc" id="L1770">			setState(459);</span>
<span class="fc" id="L1771">			_errHandler.sync(this);</span>
<span class="fc" id="L1772">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">			if (_la==EXTENDS_CLAUSE) {</span>
				{
<span class="fc" id="L1775">				setState(458);</span>
<span class="fc" id="L1776">				typeUpperBounds();</span>
				}
			}

			}
		}
<span class="nc" id="L1782">		catch (RecognitionException re) {</span>
<span class="nc" id="L1783">			_localctx.exception = re;</span>
<span class="nc" id="L1784">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1785">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1788">			exitRule();</span>
		}
<span class="fc" id="L1790">		return _localctx;</span>
	}

	public static class TypeUpperBoundsContext extends ParserRuleContext {
<span class="fc" id="L1794">		public TerminalNode EXTENDS_CLAUSE() { return getToken(JavaLanguageParser.EXTENDS_CLAUSE, 0); }</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L1796">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public TypeBoundContext typeBound() {
<span class="nc" id="L1799">			return getRuleContext(TypeBoundContext.class,0);</span>
		}
		public TypeUpperBoundsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1802">			super(parent, invokingState);</span>
<span class="fc" id="L1803">		}</span>
<span class="nc" id="L1804">		@Override public int getRuleIndex() { return RULE_typeUpperBounds; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeUpperBounds(this);</span>
<span class="nc" id="L1808">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeUpperBoundsContext typeUpperBounds() throws RecognitionException {
<span class="fc" id="L1813">		TypeUpperBoundsContext _localctx = new TypeUpperBoundsContext(_ctx, getState());</span>
<span class="fc" id="L1814">		enterRule(_localctx, 40, RULE_typeUpperBounds);</span>
		try {
<span class="fc" id="L1816">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1818">			setState(461);</span>
<span class="fc" id="L1819">			match(EXTENDS_CLAUSE);</span>
<span class="fc" id="L1820">			setState(462);</span>
<span class="fc" id="L1821">			annotations(false);</span>
<span class="fc" id="L1822">			setState(463);</span>
<span class="fc" id="L1823">			typeBound();</span>
			}
		}
<span class="nc" id="L1826">		catch (RecognitionException re) {</span>
<span class="nc" id="L1827">			_localctx.exception = re;</span>
<span class="nc" id="L1828">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1829">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1832">			exitRule();</span>
		}
<span class="fc" id="L1834">		return _localctx;</span>
	}

	public static class TypeBoundContext extends ParserRuleContext {
		public List&lt;TypeBoundTypeContext&gt; typeBoundType() {
<span class="fc" id="L1839">			return getRuleContexts(TypeBoundTypeContext.class);</span>
		}
		public TypeBoundTypeContext typeBoundType(int i) {
<span class="fc" id="L1842">			return getRuleContext(TypeBoundTypeContext.class,i);</span>
		}
<span class="fc" id="L1844">		public List&lt;TerminalNode&gt; BAND() { return getTokens(JavaLanguageParser.BAND); }</span>
		public TerminalNode BAND(int i) {
<span class="nc" id="L1846">			return getToken(JavaLanguageParser.BAND, i);</span>
		}
		public TypeBoundContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1849">			super(parent, invokingState);</span>
<span class="fc" id="L1850">		}</span>
<span class="nc" id="L1851">		@Override public int getRuleIndex() { return RULE_typeBound; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1854" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeBound(this);</span>
<span class="nc" id="L1855">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeBoundContext typeBound() throws RecognitionException {
<span class="fc" id="L1860">		TypeBoundContext _localctx = new TypeBoundContext(_ctx, getState());</span>
<span class="fc" id="L1861">		enterRule(_localctx, 42, RULE_typeBound);</span>
		int _la;
		try {
<span class="fc" id="L1864">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1866">			setState(465);</span>
<span class="fc" id="L1867">			typeBoundType();</span>
<span class="fc" id="L1868">			setState(470);</span>
<span class="fc" id="L1869">			_errHandler.sync(this);</span>
<span class="fc" id="L1870">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">			while (_la==BAND) {</span>
				{
				{
<span class="fc" id="L1874">				setState(466);</span>
<span class="fc" id="L1875">				match(BAND);</span>
<span class="fc" id="L1876">				setState(467);</span>
<span class="fc" id="L1877">				typeBoundType();</span>
				}
				}
<span class="fc" id="L1880">				setState(472);</span>
<span class="fc" id="L1881">				_errHandler.sync(this);</span>
<span class="fc" id="L1882">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L1886">		catch (RecognitionException re) {</span>
<span class="nc" id="L1887">			_localctx.exception = re;</span>
<span class="nc" id="L1888">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1889">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1892">			exitRule();</span>
		}
<span class="fc" id="L1894">		return _localctx;</span>
	}

	public static class TypeBoundTypeContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="nc" id="L1899">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() {
<span class="nc" id="L1902">			return getRuleContext(ClassOrInterfaceOrPrimitiveTypeContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L1905">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L1908">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
		public TypeBoundTypeContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L1911">			super(parent, invokingState);</span>
<span class="fc" id="L1912">		}</span>
<span class="nc" id="L1913">		@Override public int getRuleIndex() { return RULE_typeBoundType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1916" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeBoundType(this);</span>
<span class="nc" id="L1917">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeBoundTypeContext typeBoundType() throws RecognitionException {
<span class="fc" id="L1922">		TypeBoundTypeContext _localctx = new TypeBoundTypeContext(_ctx, getState());</span>
<span class="fc" id="L1923">		enterRule(_localctx, 44, RULE_typeBoundType);</span>
		int _la;
		try {
<span class="fc" id="L1926">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1928">			setState(473);</span>
<span class="fc" id="L1929">			annotations(false);</span>
<span class="fc" id="L1930">			setState(474);</span>
<span class="fc" id="L1931">			classOrInterfaceOrPrimitiveType();</span>
<span class="fc" id="L1932">			setState(478);</span>
<span class="fc" id="L1933">			_errHandler.sync(this);</span>
<span class="fc" id="L1934">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L1935" title="2 of 4 branches missed.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="nc" id="L1938">				setState(475);</span>
<span class="nc" id="L1939">				arrayDeclarator();</span>
				}
				}
<span class="nc" id="L1942">				setState(480);</span>
<span class="nc" id="L1943">				_errHandler.sync(this);</span>
<span class="nc" id="L1944">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L1948">		catch (RecognitionException re) {</span>
<span class="nc" id="L1949">			_localctx.exception = re;</span>
<span class="nc" id="L1950">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L1951">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L1954">			exitRule();</span>
		}
<span class="fc" id="L1956">		return _localctx;</span>
	}

	public static class EnumDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L1961">		public TerminalNode ENUM() { return getToken(JavaLanguageParser.ENUM, 0); }</span>
		public IdContext id() {
<span class="nc" id="L1963">			return getRuleContext(IdContext.class,0);</span>
		}
		public EnumBodyContext enumBody() {
<span class="nc" id="L1966">			return getRuleContext(EnumBodyContext.class,0);</span>
		}
		public ImplementsClauseContext implementsClause() {
<span class="nc" id="L1969">			return getRuleContext(ImplementsClauseContext.class,0);</span>
		}
<span class="nc" id="L1971">		public EnumDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public EnumDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L1973">			super(parent, invokingState);</span>
<span class="fc" id="L1974">			this.mods = mods;</span>
<span class="fc" id="L1975">		}</span>
<span class="nc" id="L1976">		@Override public int getRuleIndex() { return RULE_enumDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnumDeclaration(this);</span>
<span class="nc" id="L1980">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnumDeclarationContext enumDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L1985">		EnumDeclarationContext _localctx = new EnumDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L1986">		enterRule(_localctx, 46, RULE_enumDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L1989">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L1991">			setState(481);</span>
<span class="fc" id="L1992">			match(ENUM);</span>
<span class="fc" id="L1993">			setState(482);</span>
<span class="fc" id="L1994">			id();</span>
<span class="fc" id="L1995">			setState(484);</span>
<span class="fc" id="L1996">			_errHandler.sync(this);</span>
<span class="fc" id="L1997">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">			if (_la==LITERAL_IMPLEMENTS) {</span>
				{
<span class="fc" id="L2000">				setState(483);</span>
<span class="fc" id="L2001">				implementsClause();</span>
				}
			}

<span class="fc" id="L2005">			setState(486);</span>
<span class="fc" id="L2006">			enumBody();</span>
			}
		}
<span class="nc" id="L2009">		catch (RecognitionException re) {</span>
<span class="nc" id="L2010">			_localctx.exception = re;</span>
<span class="nc" id="L2011">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2012">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2015">			exitRule();</span>
		}
<span class="fc" id="L2017">		return _localctx;</span>
	}

	public static class EnumBodyContext extends ParserRuleContext {
<span class="nc" id="L2021">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L2022">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public EnumConstantsContext enumConstants() {
<span class="nc" id="L2024">			return getRuleContext(EnumConstantsContext.class,0);</span>
		}
<span class="nc" id="L2026">		public TerminalNode COMMA() { return getToken(JavaLanguageParser.COMMA, 0); }</span>
		public EnumBodyDeclarationsContext enumBodyDeclarations() {
<span class="nc" id="L2028">			return getRuleContext(EnumBodyDeclarationsContext.class,0);</span>
		}
		public EnumBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2031">			super(parent, invokingState);</span>
<span class="fc" id="L2032">		}</span>
<span class="nc" id="L2033">		@Override public int getRuleIndex() { return RULE_enumBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnumBody(this);</span>
<span class="nc" id="L2037">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnumBodyContext enumBody() throws RecognitionException {
<span class="fc" id="L2042">		EnumBodyContext _localctx = new EnumBodyContext(_ctx, getState());</span>
<span class="fc" id="L2043">		enterRule(_localctx, 48, RULE_enumBody);</span>
		int _la;
		try {
<span class="fc" id="L2046">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2048">			setState(488);</span>
<span class="fc" id="L2049">			match(LCURLY);</span>
<span class="fc" id="L2050">			setState(490);</span>
<span class="fc" id="L2051">			_errHandler.sync(this);</span>
<span class="fc" id="L2052">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L2053" title="1 of 6 branches missed.">			if (_la==IDENT || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)))) != 0)) {</span>
				{
<span class="fc" id="L2055">				setState(489);</span>
<span class="fc" id="L2056">				enumConstants();</span>
				}
			}

<span class="fc" id="L2060">			setState(493);</span>
<span class="fc" id="L2061">			_errHandler.sync(this);</span>
<span class="fc" id="L2062">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2063" title="All 2 branches covered.">			if (_la==COMMA) {</span>
				{
<span class="fc" id="L2065">				setState(492);</span>
<span class="fc" id="L2066">				match(COMMA);</span>
				}
			}

<span class="fc" id="L2070">			setState(496);</span>
<span class="fc" id="L2071">			_errHandler.sync(this);</span>
<span class="fc" id="L2072">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">			if (_la==SEMI) {</span>
				{
<span class="fc" id="L2075">				setState(495);</span>
<span class="fc" id="L2076">				enumBodyDeclarations();</span>
				}
			}

<span class="fc" id="L2080">			setState(498);</span>
<span class="fc" id="L2081">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L2084">		catch (RecognitionException re) {</span>
<span class="nc" id="L2085">			_localctx.exception = re;</span>
<span class="nc" id="L2086">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2087">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2090">			exitRule();</span>
		}
<span class="fc" id="L2092">		return _localctx;</span>
	}

	public static class EnumConstantsContext extends ParserRuleContext {
		public List&lt;EnumConstantContext&gt; enumConstant() {
<span class="nc" id="L2097">			return getRuleContexts(EnumConstantContext.class);</span>
		}
		public EnumConstantContext enumConstant(int i) {
<span class="nc" id="L2100">			return getRuleContext(EnumConstantContext.class,i);</span>
		}
<span class="nc" id="L2102">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L2104">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public EnumConstantsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2107">			super(parent, invokingState);</span>
<span class="fc" id="L2108">		}</span>
<span class="nc" id="L2109">		@Override public int getRuleIndex() { return RULE_enumConstants; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnumConstants(this);</span>
<span class="nc" id="L2113">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnumConstantsContext enumConstants() throws RecognitionException {
<span class="fc" id="L2118">		EnumConstantsContext _localctx = new EnumConstantsContext(_ctx, getState());</span>
<span class="fc" id="L2119">		enterRule(_localctx, 50, RULE_enumConstants);</span>
		try {
			int _alt;
<span class="fc" id="L2122">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2124">			setState(500);</span>
<span class="fc" id="L2125">			enumConstant();</span>
<span class="fc" id="L2126">			setState(505);</span>
<span class="fc" id="L2127">			_errHandler.sync(this);</span>
<span class="fc" id="L2128">			_alt = getInterpreter().adaptivePredict(_input,33,_ctx);</span>
<span class="pc bpc" id="L2129" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L2130" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L2133">					setState(501);</span>
<span class="fc" id="L2134">					match(COMMA);</span>
<span class="fc" id="L2135">					setState(502);</span>
<span class="fc" id="L2136">					enumConstant();</span>
					}
					} 
				}
<span class="fc" id="L2140">				setState(507);</span>
<span class="fc" id="L2141">				_errHandler.sync(this);</span>
<span class="fc" id="L2142">				_alt = getInterpreter().adaptivePredict(_input,33,_ctx);</span>
			}
			}
		}
<span class="nc" id="L2146">		catch (RecognitionException re) {</span>
<span class="nc" id="L2147">			_localctx.exception = re;</span>
<span class="nc" id="L2148">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2149">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2152">			exitRule();</span>
		}
<span class="fc" id="L2154">		return _localctx;</span>
	}

	public static class EnumConstantContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="nc" id="L2159">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L2162">			return getRuleContext(IdContext.class,0);</span>
		}
		public ArgumentsContext arguments() {
<span class="nc" id="L2165">			return getRuleContext(ArgumentsContext.class,0);</span>
		}
		public ClassBodyContext classBody() {
<span class="nc" id="L2168">			return getRuleContext(ClassBodyContext.class,0);</span>
		}
		public EnumConstantContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2171">			super(parent, invokingState);</span>
<span class="fc" id="L2172">		}</span>
<span class="nc" id="L2173">		@Override public int getRuleIndex() { return RULE_enumConstant; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2176" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnumConstant(this);</span>
<span class="nc" id="L2177">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnumConstantContext enumConstant() throws RecognitionException {
<span class="fc" id="L2182">		EnumConstantContext _localctx = new EnumConstantContext(_ctx, getState());</span>
<span class="fc" id="L2183">		enterRule(_localctx, 52, RULE_enumConstant);</span>
		int _la;
		try {
<span class="fc" id="L2186">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2188">			setState(508);</span>
<span class="fc" id="L2189">			annotations(true);</span>
<span class="fc" id="L2190">			setState(509);</span>
<span class="fc" id="L2191">			id();</span>
<span class="fc" id="L2192">			setState(511);</span>
<span class="fc" id="L2193">			_errHandler.sync(this);</span>
<span class="fc" id="L2194">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2195" title="All 2 branches covered.">			if (_la==LPAREN) {</span>
				{
<span class="fc" id="L2197">				setState(510);</span>
<span class="fc" id="L2198">				arguments();</span>
				}
			}

<span class="fc" id="L2202">			setState(514);</span>
<span class="fc" id="L2203">			_errHandler.sync(this);</span>
<span class="fc" id="L2204">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">			if (_la==LCURLY) {</span>
				{
<span class="fc" id="L2207">				setState(513);</span>
<span class="fc" id="L2208">				classBody();</span>
				}
			}

			}
		}
<span class="nc" id="L2214">		catch (RecognitionException re) {</span>
<span class="nc" id="L2215">			_localctx.exception = re;</span>
<span class="nc" id="L2216">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2217">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2220">			exitRule();</span>
		}
<span class="fc" id="L2222">		return _localctx;</span>
	}

	public static class EnumBodyDeclarationsContext extends ParserRuleContext {
<span class="nc" id="L2226">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public List&lt;ClassBodyDeclarationContext&gt; classBodyDeclaration() {
<span class="nc" id="L2228">			return getRuleContexts(ClassBodyDeclarationContext.class);</span>
		}
		public ClassBodyDeclarationContext classBodyDeclaration(int i) {
<span class="nc" id="L2231">			return getRuleContext(ClassBodyDeclarationContext.class,i);</span>
		}
		public EnumBodyDeclarationsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2234">			super(parent, invokingState);</span>
<span class="fc" id="L2235">		}</span>
<span class="nc" id="L2236">		@Override public int getRuleIndex() { return RULE_enumBodyDeclarations; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnumBodyDeclarations(this);</span>
<span class="nc" id="L2240">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnumBodyDeclarationsContext enumBodyDeclarations() throws RecognitionException {
<span class="fc" id="L2245">		EnumBodyDeclarationsContext _localctx = new EnumBodyDeclarationsContext(_ctx, getState());</span>
<span class="fc" id="L2246">		enterRule(_localctx, 54, RULE_enumBodyDeclarations);</span>
		int _la;
		try {
<span class="fc" id="L2249">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2251">			setState(516);</span>
<span class="fc" id="L2252">			match(SEMI);</span>
<span class="fc" id="L2253">			setState(520);</span>
<span class="fc" id="L2254">			_errHandler.sync(this);</span>
<span class="fc" id="L2255">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L2256" title="2 of 12 branches missed.">			while ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; ABSTRACT) | (1L &lt;&lt; STRICTFP) | (1L &lt;&lt; SEMI) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT) | (1L &lt;&lt; LITERAL_PRIVATE) | (1L &lt;&lt; LITERAL_PUBLIC) | (1L &lt;&lt; LITERAL_PROTECTED))) != 0) || ((((_la - 64)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 64)) &amp; ((1L &lt;&lt; (LITERAL_STATIC - 64)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 64)) | (1L &lt;&lt; (LITERAL_NATIVE - 64)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 64)) | (1L &lt;&lt; (LITERAL_VOLATILE - 64)) | (1L &lt;&lt; (LITERAL_CLASS - 64)) | (1L &lt;&lt; (LITERAL_INTERFACE - 64)) | (1L &lt;&lt; (LCURLY - 64)) | (1L &lt;&lt; (LITERAL_DEFAULT - 64)) | (1L &lt;&lt; (LT - 64)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_YIELD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)) | (1L &lt;&lt; (LITERAL_PERMITS - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L2259">				setState(517);</span>
<span class="fc" id="L2260">				classBodyDeclaration();</span>
				}
				}
<span class="fc" id="L2263">				setState(522);</span>
<span class="fc" id="L2264">				_errHandler.sync(this);</span>
<span class="fc" id="L2265">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L2269">		catch (RecognitionException re) {</span>
<span class="nc" id="L2270">			_localctx.exception = re;</span>
<span class="nc" id="L2271">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2272">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2275">			exitRule();</span>
		}
<span class="fc" id="L2277">		return _localctx;</span>
	}

	public static class InterfaceDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L2282">		public TerminalNode LITERAL_INTERFACE() { return getToken(JavaLanguageParser.LITERAL_INTERFACE, 0); }</span>
		public IdContext id() {
<span class="nc" id="L2284">			return getRuleContext(IdContext.class,0);</span>
		}
		public InterfaceBodyContext interfaceBody() {
<span class="nc" id="L2287">			return getRuleContext(InterfaceBodyContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L2290">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public InterfaceExtendsContext interfaceExtends() {
<span class="nc" id="L2293">			return getRuleContext(InterfaceExtendsContext.class,0);</span>
		}
		public PermittedSubclassesAndInterfacesContext permittedSubclassesAndInterfaces() {
<span class="nc" id="L2296">			return getRuleContext(PermittedSubclassesAndInterfacesContext.class,0);</span>
		}
<span class="nc" id="L2298">		public InterfaceDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public InterfaceDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L2300">			super(parent, invokingState);</span>
<span class="fc" id="L2301">			this.mods = mods;</span>
<span class="fc" id="L2302">		}</span>
<span class="nc" id="L2303">		@Override public int getRuleIndex() { return RULE_interfaceDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceDeclaration(this);</span>
<span class="nc" id="L2307">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceDeclarationContext interfaceDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L2312">		InterfaceDeclarationContext _localctx = new InterfaceDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L2313">		enterRule(_localctx, 56, RULE_interfaceDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L2316">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2318">			setState(523);</span>
<span class="fc" id="L2319">			match(LITERAL_INTERFACE);</span>
<span class="fc" id="L2320">			setState(524);</span>
<span class="fc" id="L2321">			id();</span>
<span class="fc" id="L2322">			setState(526);</span>
<span class="fc" id="L2323">			_errHandler.sync(this);</span>
<span class="fc" id="L2324">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2325" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L2327">				setState(525);</span>
<span class="fc" id="L2328">				typeParameters();</span>
				}
			}

<span class="fc" id="L2332">			setState(529);</span>
<span class="fc" id="L2333">			_errHandler.sync(this);</span>
<span class="fc" id="L2334">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">			if (_la==EXTENDS_CLAUSE) {</span>
				{
<span class="fc" id="L2337">				setState(528);</span>
<span class="fc" id="L2338">				interfaceExtends();</span>
				}
			}

<span class="fc" id="L2342">			setState(532);</span>
<span class="fc" id="L2343">			_errHandler.sync(this);</span>
<span class="fc" id="L2344">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2345" title="All 2 branches covered.">			if (_la==LITERAL_PERMITS) {</span>
				{
<span class="fc" id="L2347">				setState(531);</span>
<span class="fc" id="L2348">				permittedSubclassesAndInterfaces();</span>
				}
			}

<span class="fc" id="L2352">			setState(534);</span>
<span class="fc" id="L2353">			interfaceBody();</span>
			}
		}
<span class="nc" id="L2356">		catch (RecognitionException re) {</span>
<span class="nc" id="L2357">			_localctx.exception = re;</span>
<span class="nc" id="L2358">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2359">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2362">			exitRule();</span>
		}
<span class="fc" id="L2364">		return _localctx;</span>
	}

	public static class InterfaceExtendsContext extends ParserRuleContext {
<span class="fc" id="L2368">		public TerminalNode EXTENDS_CLAUSE() { return getToken(JavaLanguageParser.EXTENDS_CLAUSE, 0); }</span>
		public TypeListContext typeList() {
<span class="fc" id="L2370">			return getRuleContext(TypeListContext.class,0);</span>
		}
		public InterfaceExtendsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2373">			super(parent, invokingState);</span>
<span class="fc" id="L2374">		}</span>
<span class="nc" id="L2375">		@Override public int getRuleIndex() { return RULE_interfaceExtends; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceExtends(this);</span>
<span class="nc" id="L2379">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceExtendsContext interfaceExtends() throws RecognitionException {
<span class="fc" id="L2384">		InterfaceExtendsContext _localctx = new InterfaceExtendsContext(_ctx, getState());</span>
<span class="fc" id="L2385">		enterRule(_localctx, 58, RULE_interfaceExtends);</span>
		try {
<span class="fc" id="L2387">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2389">			setState(536);</span>
<span class="fc" id="L2390">			match(EXTENDS_CLAUSE);</span>
<span class="fc" id="L2391">			setState(537);</span>
<span class="fc" id="L2392">			typeList();</span>
			}
		}
<span class="nc" id="L2395">		catch (RecognitionException re) {</span>
<span class="nc" id="L2396">			_localctx.exception = re;</span>
<span class="nc" id="L2397">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2398">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2401">			exitRule();</span>
		}
<span class="fc" id="L2403">		return _localctx;</span>
	}

	public static class ClassBodyContext extends ParserRuleContext {
<span class="nc" id="L2407">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L2408">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;ClassBodyDeclarationContext&gt; classBodyDeclaration() {
<span class="nc" id="L2410">			return getRuleContexts(ClassBodyDeclarationContext.class);</span>
		}
		public ClassBodyDeclarationContext classBodyDeclaration(int i) {
<span class="nc" id="L2413">			return getRuleContext(ClassBodyDeclarationContext.class,i);</span>
		}
		public ClassBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2416">			super(parent, invokingState);</span>
<span class="fc" id="L2417">		}</span>
<span class="nc" id="L2418">		@Override public int getRuleIndex() { return RULE_classBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassBody(this);</span>
<span class="nc" id="L2422">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassBodyContext classBody() throws RecognitionException {
<span class="fc" id="L2427">		ClassBodyContext _localctx = new ClassBodyContext(_ctx, getState());</span>
<span class="fc" id="L2428">		enterRule(_localctx, 60, RULE_classBody);</span>
		int _la;
		try {
<span class="fc" id="L2431">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2433">			setState(539);</span>
<span class="fc" id="L2434">			match(LCURLY);</span>
<span class="fc" id="L2435">			setState(543);</span>
<span class="fc" id="L2436">			_errHandler.sync(this);</span>
<span class="fc" id="L2437">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L2438" title="2 of 12 branches missed.">			while ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; ABSTRACT) | (1L &lt;&lt; STRICTFP) | (1L &lt;&lt; SEMI) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT) | (1L &lt;&lt; LITERAL_PRIVATE) | (1L &lt;&lt; LITERAL_PUBLIC) | (1L &lt;&lt; LITERAL_PROTECTED))) != 0) || ((((_la - 64)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 64)) &amp; ((1L &lt;&lt; (LITERAL_STATIC - 64)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 64)) | (1L &lt;&lt; (LITERAL_NATIVE - 64)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 64)) | (1L &lt;&lt; (LITERAL_VOLATILE - 64)) | (1L &lt;&lt; (LITERAL_CLASS - 64)) | (1L &lt;&lt; (LITERAL_INTERFACE - 64)) | (1L &lt;&lt; (LCURLY - 64)) | (1L &lt;&lt; (LITERAL_DEFAULT - 64)) | (1L &lt;&lt; (LT - 64)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_YIELD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)) | (1L &lt;&lt; (LITERAL_PERMITS - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L2441">				setState(540);</span>
<span class="fc" id="L2442">				classBodyDeclaration();</span>
				}
				}
<span class="fc" id="L2445">				setState(545);</span>
<span class="fc" id="L2446">				_errHandler.sync(this);</span>
<span class="fc" id="L2447">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L2449">			setState(546);</span>
<span class="fc" id="L2450">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L2453">		catch (RecognitionException re) {</span>
<span class="nc" id="L2454">			_localctx.exception = re;</span>
<span class="nc" id="L2455">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2456">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2459">			exitRule();</span>
		}
<span class="fc" id="L2461">		return _localctx;</span>
	}

	public static class InterfaceBodyContext extends ParserRuleContext {
<span class="nc" id="L2465">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L2466">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;InterfaceBodyDeclarationContext&gt; interfaceBodyDeclaration() {
<span class="nc" id="L2468">			return getRuleContexts(InterfaceBodyDeclarationContext.class);</span>
		}
		public InterfaceBodyDeclarationContext interfaceBodyDeclaration(int i) {
<span class="nc" id="L2471">			return getRuleContext(InterfaceBodyDeclarationContext.class,i);</span>
		}
		public InterfaceBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2474">			super(parent, invokingState);</span>
<span class="fc" id="L2475">		}</span>
<span class="nc" id="L2476">		@Override public int getRuleIndex() { return RULE_interfaceBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2479" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceBody(this);</span>
<span class="nc" id="L2480">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceBodyContext interfaceBody() throws RecognitionException {
<span class="fc" id="L2485">		InterfaceBodyContext _localctx = new InterfaceBodyContext(_ctx, getState());</span>
<span class="fc" id="L2486">		enterRule(_localctx, 62, RULE_interfaceBody);</span>
		int _la;
		try {
<span class="fc" id="L2489">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2491">			setState(548);</span>
<span class="fc" id="L2492">			match(LCURLY);</span>
<span class="fc" id="L2493">			setState(552);</span>
<span class="fc" id="L2494">			_errHandler.sync(this);</span>
<span class="fc" id="L2495">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L2496" title="2 of 12 branches missed.">			while ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; ABSTRACT) | (1L &lt;&lt; STRICTFP) | (1L &lt;&lt; SEMI) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT) | (1L &lt;&lt; LITERAL_PRIVATE) | (1L &lt;&lt; LITERAL_PUBLIC) | (1L &lt;&lt; LITERAL_PROTECTED))) != 0) || ((((_la - 64)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 64)) &amp; ((1L &lt;&lt; (LITERAL_STATIC - 64)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 64)) | (1L &lt;&lt; (LITERAL_NATIVE - 64)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 64)) | (1L &lt;&lt; (LITERAL_VOLATILE - 64)) | (1L &lt;&lt; (LITERAL_CLASS - 64)) | (1L &lt;&lt; (LITERAL_INTERFACE - 64)) | (1L &lt;&lt; (LITERAL_DEFAULT - 64)) | (1L &lt;&lt; (LT - 64)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_YIELD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)) | (1L &lt;&lt; (LITERAL_PERMITS - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L2499">				setState(549);</span>
<span class="fc" id="L2500">				interfaceBodyDeclaration();</span>
				}
				}
<span class="fc" id="L2503">				setState(554);</span>
<span class="fc" id="L2504">				_errHandler.sync(this);</span>
<span class="fc" id="L2505">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L2507">			setState(555);</span>
<span class="fc" id="L2508">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L2511">		catch (RecognitionException re) {</span>
<span class="nc" id="L2512">			_localctx.exception = re;</span>
<span class="nc" id="L2513">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2514">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2517">			exitRule();</span>
		}
<span class="fc" id="L2519">		return _localctx;</span>
	}

	public static class ClassBodyDeclarationContext extends ParserRuleContext {
		public ClassBodyDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2524">			super(parent, invokingState);</span>
<span class="fc" id="L2525">		}</span>
<span class="nc" id="L2526">		@Override public int getRuleIndex() { return RULE_classBodyDeclaration; }</span>
	 
<span class="fc" id="L2528">		public ClassBodyDeclarationContext() { }</span>
		public void copyFrom(ClassBodyDeclarationContext ctx) {
<span class="fc" id="L2530">			super.copyFrom(ctx);</span>
<span class="fc" id="L2531">		}</span>
	}
	public static class ClassBlockContext extends ClassBodyDeclarationContext {
		public BlockContext block() {
<span class="fc" id="L2535">			return getRuleContext(BlockContext.class,0);</span>
		}
<span class="fc" id="L2537">		public TerminalNode LITERAL_STATIC() { return getToken(JavaLanguageParser.LITERAL_STATIC, 0); }</span>
<span class="fc" id="L2538">		public ClassBlockContext(ClassBodyDeclarationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2541" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassBlock(this);</span>
<span class="nc" id="L2542">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ClassDefContext extends ClassBodyDeclarationContext {
		public ModifierContext modifier;
<span class="fc" id="L2547">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public MemberDeclarationContext memberDeclaration() {
<span class="nc" id="L2549">			return getRuleContext(MemberDeclarationContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L2552">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L2555">			return getRuleContext(ModifierContext.class,i);</span>
		}
<span class="fc" id="L2557">		public ClassDefContext(ClassBodyDeclarationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2560" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassDef(this);</span>
<span class="nc" id="L2561">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class EmptyClassContext extends ClassBodyDeclarationContext {
<span class="nc" id="L2565">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L2566">		public EmptyClassContext(ClassBodyDeclarationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2569" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEmptyClass(this);</span>
<span class="nc" id="L2570">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassBodyDeclarationContext classBodyDeclaration() throws RecognitionException {
<span class="fc" id="L2575">		ClassBodyDeclarationContext _localctx = new ClassBodyDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L2576">		enterRule(_localctx, 64, RULE_classBodyDeclaration);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L2580">			setState(569);</span>
<span class="fc" id="L2581">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L2582" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,44,_ctx) ) {</span>
			case 1:
<span class="fc" id="L2584">				_localctx = new EmptyClassContext(_localctx);</span>
<span class="fc" id="L2585">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L2587">				setState(557);</span>
<span class="fc" id="L2588">				match(SEMI);</span>
				}
<span class="fc" id="L2590">				break;</span>
			case 2:
<span class="fc" id="L2592">				_localctx = new ClassBlockContext(_localctx);</span>
<span class="fc" id="L2593">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L2595">				setState(559);</span>
<span class="fc" id="L2596">				_errHandler.sync(this);</span>
<span class="fc" id="L2597">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">				if (_la==LITERAL_STATIC) {</span>
					{
<span class="fc" id="L2600">					setState(558);</span>
<span class="fc" id="L2601">					match(LITERAL_STATIC);</span>
					}
				}

<span class="fc" id="L2605">				setState(561);</span>
<span class="fc" id="L2606">				block();</span>
				}
<span class="fc" id="L2608">				break;</span>
			case 3:
<span class="fc" id="L2610">				_localctx = new ClassDefContext(_localctx);</span>
<span class="fc" id="L2611">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L2613">				setState(565);</span>
<span class="fc" id="L2614">				_errHandler.sync(this);</span>
<span class="fc" id="L2615">				_alt = getInterpreter().adaptivePredict(_input,43,_ctx);</span>
<span class="pc bpc" id="L2616" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L2617" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L2620">						setState(562);</span>
<span class="fc" id="L2621">						((ClassDefContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L2622">						((ClassDefContext)_localctx).mods.add(((ClassDefContext)_localctx).modifier);</span>
						}
						} 
					}
<span class="fc" id="L2626">					setState(567);</span>
<span class="fc" id="L2627">					_errHandler.sync(this);</span>
<span class="fc" id="L2628">					_alt = getInterpreter().adaptivePredict(_input,43,_ctx);</span>
				}
<span class="fc" id="L2630">				setState(568);</span>
<span class="fc" id="L2631">				memberDeclaration(((ClassDefContext) _localctx).mods);</span>
				}
				break;
			}
		}
<span class="nc" id="L2636">		catch (RecognitionException re) {</span>
<span class="nc" id="L2637">			_localctx.exception = re;</span>
<span class="nc" id="L2638">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2639">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2642">			exitRule();</span>
		}
<span class="fc" id="L2644">		return _localctx;</span>
	}

	public static class MemberDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public RecordDeclarationContext recordDeclaration() {
<span class="nc" id="L2650">			return getRuleContext(RecordDeclarationContext.class,0);</span>
		}
		public MethodDeclarationContext methodDeclaration() {
<span class="nc" id="L2653">			return getRuleContext(MethodDeclarationContext.class,0);</span>
		}
		public FieldDeclarationContext fieldDeclaration() {
<span class="nc" id="L2656">			return getRuleContext(FieldDeclarationContext.class,0);</span>
		}
		public ConstructorDeclarationContext constructorDeclaration() {
<span class="nc" id="L2659">			return getRuleContext(ConstructorDeclarationContext.class,0);</span>
		}
		public InterfaceDeclarationContext interfaceDeclaration() {
<span class="nc" id="L2662">			return getRuleContext(InterfaceDeclarationContext.class,0);</span>
		}
		public AnnotationTypeDeclarationContext annotationTypeDeclaration() {
<span class="nc" id="L2665">			return getRuleContext(AnnotationTypeDeclarationContext.class,0);</span>
		}
		public ClassDeclarationContext classDeclaration() {
<span class="nc" id="L2668">			return getRuleContext(ClassDeclarationContext.class,0);</span>
		}
		public EnumDeclarationContext enumDeclaration() {
<span class="nc" id="L2671">			return getRuleContext(EnumDeclarationContext.class,0);</span>
		}
<span class="nc" id="L2673">		public MemberDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public MemberDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L2675">			super(parent, invokingState);</span>
<span class="fc" id="L2676">			this.mods = mods;</span>
<span class="fc" id="L2677">		}</span>
<span class="nc" id="L2678">		@Override public int getRuleIndex() { return RULE_memberDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2681" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMemberDeclaration(this);</span>
<span class="nc" id="L2682">			else return visitor.visitChildren(this);</span>
		}
	}

	public final MemberDeclarationContext memberDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L2687">		MemberDeclarationContext _localctx = new MemberDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L2688">		enterRule(_localctx, 66, RULE_memberDeclaration);</span>
		try {
<span class="fc" id="L2690">			setState(579);</span>
<span class="fc" id="L2691">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L2692" title="1 of 9 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,45,_ctx) ) {</span>
			case 1:
<span class="fc" id="L2694">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L2696">				setState(571);</span>
<span class="fc" id="L2697">				recordDeclaration(mods);</span>
				}
<span class="fc" id="L2699">				break;</span>
			case 2:
<span class="fc" id="L2701">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L2703">				setState(572);</span>
<span class="fc" id="L2704">				methodDeclaration(mods);</span>
				}
<span class="fc" id="L2706">				break;</span>
			case 3:
<span class="fc" id="L2708">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L2710">				setState(573);</span>
<span class="fc" id="L2711">				fieldDeclaration(mods);</span>
				}
<span class="fc" id="L2713">				break;</span>
			case 4:
<span class="fc" id="L2715">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L2717">				setState(574);</span>
<span class="fc" id="L2718">				constructorDeclaration(mods);</span>
				}
<span class="fc" id="L2720">				break;</span>
			case 5:
<span class="fc" id="L2722">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L2724">				setState(575);</span>
<span class="fc" id="L2725">				interfaceDeclaration(mods);</span>
				}
<span class="fc" id="L2727">				break;</span>
			case 6:
<span class="fc" id="L2729">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L2731">				setState(576);</span>
<span class="fc" id="L2732">				annotationTypeDeclaration(mods);</span>
				}
<span class="fc" id="L2734">				break;</span>
			case 7:
<span class="fc" id="L2736">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L2738">				setState(577);</span>
<span class="fc" id="L2739">				classDeclaration(mods);</span>
				}
<span class="fc" id="L2741">				break;</span>
			case 8:
<span class="fc" id="L2743">				enterOuterAlt(_localctx, 8);</span>
				{
<span class="fc" id="L2745">				setState(578);</span>
<span class="fc" id="L2746">				enumDeclaration(mods);</span>
				}
				break;
			}
		}
<span class="nc" id="L2751">		catch (RecognitionException re) {</span>
<span class="nc" id="L2752">			_localctx.exception = re;</span>
<span class="nc" id="L2753">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2754">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2757">			exitRule();</span>
		}
<span class="fc" id="L2759">		return _localctx;</span>
	}

	public static class MethodDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeParametersContext typeParams;
		public TypeTypeContext type;
		public ArrayDeclaratorContext arrayDeclarator;
<span class="pc" id="L2767">		public List&lt;ArrayDeclaratorContext&gt; cStyleArrDec = new ArrayList&lt;ArrayDeclaratorContext&gt;();</span>
		public IdContext id() {
<span class="nc" id="L2769">			return getRuleContext(IdContext.class,0);</span>
		}
		public FormalParametersContext formalParameters() {
<span class="nc" id="L2772">			return getRuleContext(FormalParametersContext.class,0);</span>
		}
		public MethodBodyContext methodBody() {
<span class="nc" id="L2775">			return getRuleContext(MethodBodyContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L2778">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public ThrowsListContext throwsList() {
<span class="nc" id="L2781">			return getRuleContext(ThrowsListContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L2784">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L2787">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L2790">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="nc" id="L2792">		public MethodDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public MethodDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L2794">			super(parent, invokingState);</span>
<span class="fc" id="L2795">			this.mods = mods;</span>
<span class="fc" id="L2796">		}</span>
<span class="nc" id="L2797">		@Override public int getRuleIndex() { return RULE_methodDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2800" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMethodDeclaration(this);</span>
<span class="nc" id="L2801">			else return visitor.visitChildren(this);</span>
		}
	}

	public final MethodDeclarationContext methodDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L2806">		MethodDeclarationContext _localctx = new MethodDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L2807">		enterRule(_localctx, 68, RULE_methodDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L2810">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2812">			setState(582);</span>
<span class="fc" id="L2813">			_errHandler.sync(this);</span>
<span class="fc" id="L2814">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2815" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L2817">				setState(581);</span>
<span class="fc" id="L2818">				((MethodDeclarationContext)_localctx).typeParams = typeParameters();</span>
				}
			}

<span class="fc" id="L2822">			setState(584);</span>
<span class="fc" id="L2823">			((MethodDeclarationContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L2824">			setState(585);</span>
<span class="fc" id="L2825">			id();</span>
<span class="fc" id="L2826">			setState(586);</span>
<span class="fc" id="L2827">			formalParameters();</span>
			{
<span class="fc" id="L2829">			setState(590);</span>
<span class="fc" id="L2830">			_errHandler.sync(this);</span>
<span class="fc" id="L2831">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2832" title="All 4 branches covered.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="fc" id="L2835">				setState(587);</span>
<span class="fc" id="L2836">				((MethodDeclarationContext)_localctx).arrayDeclarator = arrayDeclarator();</span>
<span class="fc" id="L2837">				((MethodDeclarationContext)_localctx).cStyleArrDec.add(((MethodDeclarationContext)_localctx).arrayDeclarator);</span>
				}
				}
<span class="fc" id="L2840">				setState(592);</span>
<span class="fc" id="L2841">				_errHandler.sync(this);</span>
<span class="fc" id="L2842">				_la = _input.LA(1);</span>
			}
			}
<span class="fc" id="L2845">			setState(594);</span>
<span class="fc" id="L2846">			_errHandler.sync(this);</span>
<span class="fc" id="L2847">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L2848" title="All 2 branches covered.">			if (_la==LITERAL_THROWS) {</span>
				{
<span class="fc" id="L2850">				setState(593);</span>
<span class="fc" id="L2851">				throwsList();</span>
				}
			}

<span class="fc" id="L2855">			setState(596);</span>
<span class="fc" id="L2856">			methodBody();</span>
			}
		}
<span class="nc" id="L2859">		catch (RecognitionException re) {</span>
<span class="nc" id="L2860">			_localctx.exception = re;</span>
<span class="nc" id="L2861">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2862">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2865">			exitRule();</span>
		}
<span class="fc" id="L2867">		return _localctx;</span>
	}

	public static class MethodBodyContext extends ParserRuleContext {
		public BlockContext block() {
<span class="nc" id="L2872">			return getRuleContext(BlockContext.class,0);</span>
		}
<span class="nc" id="L2874">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public MethodBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2876">			super(parent, invokingState);</span>
<span class="fc" id="L2877">		}</span>
<span class="nc" id="L2878">		@Override public int getRuleIndex() { return RULE_methodBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2881" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMethodBody(this);</span>
<span class="nc" id="L2882">			else return visitor.visitChildren(this);</span>
		}
	}

	public final MethodBodyContext methodBody() throws RecognitionException {
<span class="fc" id="L2887">		MethodBodyContext _localctx = new MethodBodyContext(_ctx, getState());</span>
<span class="fc" id="L2888">		enterRule(_localctx, 70, RULE_methodBody);</span>
		try {
<span class="fc" id="L2890">			setState(600);</span>
<span class="fc" id="L2891">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L2892" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LCURLY:
<span class="fc" id="L2894">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L2896">				setState(598);</span>
<span class="fc" id="L2897">				block();</span>
				}
<span class="fc" id="L2899">				break;</span>
			case SEMI:
<span class="fc" id="L2901">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L2903">				setState(599);</span>
<span class="fc" id="L2904">				match(SEMI);</span>
				}
<span class="fc" id="L2906">				break;</span>
			default:
<span class="nc" id="L2908">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L2911">		catch (RecognitionException re) {</span>
<span class="nc" id="L2912">			_localctx.exception = re;</span>
<span class="nc" id="L2913">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2914">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2917">			exitRule();</span>
		}
<span class="fc" id="L2919">		return _localctx;</span>
	}

	public static class ThrowsListContext extends ParserRuleContext {
<span class="fc" id="L2923">		public TerminalNode LITERAL_THROWS() { return getToken(JavaLanguageParser.LITERAL_THROWS, 0); }</span>
		public QualifiedNameListContext qualifiedNameList() {
<span class="fc" id="L2925">			return getRuleContext(QualifiedNameListContext.class,0);</span>
		}
		public ThrowsListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L2928">			super(parent, invokingState);</span>
<span class="fc" id="L2929">		}</span>
<span class="nc" id="L2930">		@Override public int getRuleIndex() { return RULE_throwsList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2933" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitThrowsList(this);</span>
<span class="nc" id="L2934">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ThrowsListContext throwsList() throws RecognitionException {
<span class="fc" id="L2939">		ThrowsListContext _localctx = new ThrowsListContext(_ctx, getState());</span>
<span class="fc" id="L2940">		enterRule(_localctx, 72, RULE_throwsList);</span>
		try {
<span class="fc" id="L2942">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2944">			setState(602);</span>
<span class="fc" id="L2945">			match(LITERAL_THROWS);</span>
<span class="fc" id="L2946">			setState(603);</span>
<span class="fc" id="L2947">			qualifiedNameList();</span>
			}
		}
<span class="nc" id="L2950">		catch (RecognitionException re) {</span>
<span class="nc" id="L2951">			_localctx.exception = re;</span>
<span class="nc" id="L2952">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L2953">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L2956">			exitRule();</span>
		}
<span class="fc" id="L2958">		return _localctx;</span>
	}

	public static class ConstructorDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public ConstructorBlockContext constructorBody;
		public IdContext id() {
<span class="nc" id="L2965">			return getRuleContext(IdContext.class,0);</span>
		}
		public FormalParametersContext formalParameters() {
<span class="nc" id="L2968">			return getRuleContext(FormalParametersContext.class,0);</span>
		}
		public ConstructorBlockContext constructorBlock() {
<span class="nc" id="L2971">			return getRuleContext(ConstructorBlockContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L2974">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public ThrowsListContext throwsList() {
<span class="nc" id="L2977">			return getRuleContext(ThrowsListContext.class,0);</span>
		}
<span class="nc" id="L2979">		public ConstructorDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public ConstructorDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L2981">			super(parent, invokingState);</span>
<span class="fc" id="L2982">			this.mods = mods;</span>
<span class="fc" id="L2983">		}</span>
<span class="nc" id="L2984">		@Override public int getRuleIndex() { return RULE_constructorDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L2987" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitConstructorDeclaration(this);</span>
<span class="nc" id="L2988">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ConstructorDeclarationContext constructorDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L2993">		ConstructorDeclarationContext _localctx = new ConstructorDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L2994">		enterRule(_localctx, 74, RULE_constructorDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L2997">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L2999">			setState(606);</span>
<span class="fc" id="L3000">			_errHandler.sync(this);</span>
<span class="fc" id="L3001">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3002" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L3004">				setState(605);</span>
<span class="fc" id="L3005">				typeParameters();</span>
				}
			}

<span class="fc" id="L3009">			setState(608);</span>
<span class="fc" id="L3010">			id();</span>
<span class="fc" id="L3011">			setState(609);</span>
<span class="fc" id="L3012">			formalParameters();</span>
<span class="fc" id="L3013">			setState(611);</span>
<span class="fc" id="L3014">			_errHandler.sync(this);</span>
<span class="fc" id="L3015">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3016" title="All 2 branches covered.">			if (_la==LITERAL_THROWS) {</span>
				{
<span class="fc" id="L3018">				setState(610);</span>
<span class="fc" id="L3019">				throwsList();</span>
				}
			}

<span class="fc" id="L3023">			setState(613);</span>
<span class="fc" id="L3024">			((ConstructorDeclarationContext)_localctx).constructorBody = constructorBlock();</span>
			}
		}
<span class="nc" id="L3027">		catch (RecognitionException re) {</span>
<span class="nc" id="L3028">			_localctx.exception = re;</span>
<span class="nc" id="L3029">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3030">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3033">			exitRule();</span>
		}
<span class="fc" id="L3035">		return _localctx;</span>
	}

	public static class FieldDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public VariableDeclaratorsContext variableDeclarators() {
<span class="nc" id="L3042">			return getRuleContext(VariableDeclaratorsContext.class,0);</span>
		}
<span class="fc" id="L3044">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public TypeTypeContext typeType() {
<span class="nc" id="L3046">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
<span class="nc" id="L3048">		public FieldDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public FieldDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L3050">			super(parent, invokingState);</span>
<span class="fc" id="L3051">			this.mods = mods;</span>
<span class="fc" id="L3052">		}</span>
<span class="nc" id="L3053">		@Override public int getRuleIndex() { return RULE_fieldDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFieldDeclaration(this);</span>
<span class="nc" id="L3057">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FieldDeclarationContext fieldDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L3062">		FieldDeclarationContext _localctx = new FieldDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L3063">		enterRule(_localctx, 76, RULE_fieldDeclaration);</span>
		try {
<span class="fc" id="L3065">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3067">			setState(615);</span>
<span class="fc" id="L3068">			((FieldDeclarationContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L3069">			setState(616);</span>
<span class="fc" id="L3070">			variableDeclarators(_localctx.mods, _localctx.type);</span>
<span class="fc" id="L3071">			setState(617);</span>
<span class="fc" id="L3072">			match(SEMI);</span>
			}
		}
<span class="nc" id="L3075">		catch (RecognitionException re) {</span>
<span class="nc" id="L3076">			_localctx.exception = re;</span>
<span class="nc" id="L3077">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3078">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3081">			exitRule();</span>
		}
<span class="fc" id="L3083">		return _localctx;</span>
	}

	public static class InterfaceBodyDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L3088">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public InterfaceMemberDeclarationContext interfaceMemberDeclaration() {
<span class="fc" id="L3090">			return getRuleContext(InterfaceMemberDeclarationContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L3093">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L3096">			return getRuleContext(ModifierContext.class,i);</span>
		}
<span class="fc" id="L3098">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public InterfaceBodyDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L3100">			super(parent, invokingState);</span>
<span class="fc" id="L3101">		}</span>
<span class="nc" id="L3102">		@Override public int getRuleIndex() { return RULE_interfaceBodyDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3105" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceBodyDeclaration(this);</span>
<span class="nc" id="L3106">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceBodyDeclarationContext interfaceBodyDeclaration() throws RecognitionException {
<span class="fc" id="L3111">		InterfaceBodyDeclarationContext _localctx = new InterfaceBodyDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L3112">		enterRule(_localctx, 78, RULE_interfaceBodyDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L3115">			setState(627);</span>
<span class="fc" id="L3116">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L3117" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
			case ABSTRACT:
			case STRICTFP:
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LITERAL_PRIVATE:
			case LITERAL_PUBLIC:
			case LITERAL_PROTECTED:
			case LITERAL_STATIC:
			case LITERAL_TRANSIENT:
			case LITERAL_NATIVE:
			case LITERAL_SYNCHRONIZED:
			case LITERAL_VOLATILE:
			case LITERAL_CLASS:
			case LITERAL_INTERFACE:
			case LITERAL_DEFAULT:
			case LT:
			case ENUM:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
<span class="fc" id="L3150">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L3152">				setState(622);</span>
<span class="fc" id="L3153">				_errHandler.sync(this);</span>
<span class="fc" id="L3154">				_alt = getInterpreter().adaptivePredict(_input,52,_ctx);</span>
<span class="pc bpc" id="L3155" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L3156" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L3159">						setState(619);</span>
<span class="fc" id="L3160">						((InterfaceBodyDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L3161">						((InterfaceBodyDeclarationContext)_localctx).mods.add(((InterfaceBodyDeclarationContext)_localctx).modifier);</span>
						}
						} 
					}
<span class="fc" id="L3165">					setState(624);</span>
<span class="fc" id="L3166">					_errHandler.sync(this);</span>
<span class="fc" id="L3167">					_alt = getInterpreter().adaptivePredict(_input,52,_ctx);</span>
				}
<span class="fc" id="L3169">				setState(625);</span>
<span class="fc" id="L3170">				interfaceMemberDeclaration(_localctx.mods);</span>
				}
<span class="fc" id="L3172">				break;</span>
			case SEMI:
<span class="fc" id="L3174">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L3176">				setState(626);</span>
<span class="fc" id="L3177">				match(SEMI);</span>
				}
<span class="fc" id="L3179">				break;</span>
			default:
<span class="nc" id="L3181">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L3184">		catch (RecognitionException re) {</span>
<span class="nc" id="L3185">			_localctx.exception = re;</span>
<span class="nc" id="L3186">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3187">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3190">			exitRule();</span>
		}
<span class="fc" id="L3192">		return _localctx;</span>
	}

	public static class InterfaceMemberDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public FieldDeclarationContext fieldDeclaration() {
<span class="nc" id="L3198">			return getRuleContext(FieldDeclarationContext.class,0);</span>
		}
		public RecordDeclarationContext recordDeclaration() {
<span class="nc" id="L3201">			return getRuleContext(RecordDeclarationContext.class,0);</span>
		}
		public InterfaceMethodDeclarationContext interfaceMethodDeclaration() {
<span class="nc" id="L3204">			return getRuleContext(InterfaceMethodDeclarationContext.class,0);</span>
		}
		public InterfaceDeclarationContext interfaceDeclaration() {
<span class="nc" id="L3207">			return getRuleContext(InterfaceDeclarationContext.class,0);</span>
		}
		public AnnotationTypeDeclarationContext annotationTypeDeclaration() {
<span class="nc" id="L3210">			return getRuleContext(AnnotationTypeDeclarationContext.class,0);</span>
		}
		public ClassDeclarationContext classDeclaration() {
<span class="nc" id="L3213">			return getRuleContext(ClassDeclarationContext.class,0);</span>
		}
		public EnumDeclarationContext enumDeclaration() {
<span class="nc" id="L3216">			return getRuleContext(EnumDeclarationContext.class,0);</span>
		}
<span class="nc" id="L3218">		public InterfaceMemberDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public InterfaceMemberDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L3220">			super(parent, invokingState);</span>
<span class="fc" id="L3221">			this.mods = mods;</span>
<span class="fc" id="L3222">		}</span>
<span class="nc" id="L3223">		@Override public int getRuleIndex() { return RULE_interfaceMemberDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3226" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceMemberDeclaration(this);</span>
<span class="nc" id="L3227">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceMemberDeclarationContext interfaceMemberDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L3232">		InterfaceMemberDeclarationContext _localctx = new InterfaceMemberDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L3233">		enterRule(_localctx, 80, RULE_interfaceMemberDeclaration);</span>
		try {
<span class="fc" id="L3235">			setState(636);</span>
<span class="fc" id="L3236">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L3237" title="1 of 8 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,54,_ctx) ) {</span>
			case 1:
<span class="fc" id="L3239">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L3241">				setState(629);</span>
<span class="fc" id="L3242">				fieldDeclaration(mods);</span>
				}
<span class="fc" id="L3244">				break;</span>
			case 2:
<span class="fc" id="L3246">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L3248">				setState(630);</span>
<span class="fc" id="L3249">				recordDeclaration(mods);</span>
				}
<span class="fc" id="L3251">				break;</span>
			case 3:
<span class="fc" id="L3253">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L3255">				setState(631);</span>
<span class="fc" id="L3256">				interfaceMethodDeclaration(mods);</span>
				}
<span class="fc" id="L3258">				break;</span>
			case 4:
<span class="fc" id="L3260">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L3262">				setState(632);</span>
<span class="fc" id="L3263">				interfaceDeclaration(mods);</span>
				}
<span class="fc" id="L3265">				break;</span>
			case 5:
<span class="fc" id="L3267">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L3269">				setState(633);</span>
<span class="fc" id="L3270">				annotationTypeDeclaration(mods);</span>
				}
<span class="fc" id="L3272">				break;</span>
			case 6:
<span class="fc" id="L3274">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L3276">				setState(634);</span>
<span class="fc" id="L3277">				classDeclaration(mods);</span>
				}
<span class="fc" id="L3279">				break;</span>
			case 7:
<span class="fc" id="L3281">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L3283">				setState(635);</span>
<span class="fc" id="L3284">				enumDeclaration(mods);</span>
				}
				break;
			}
		}
<span class="nc" id="L3289">		catch (RecognitionException re) {</span>
<span class="nc" id="L3290">			_localctx.exception = re;</span>
<span class="nc" id="L3291">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3292">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3295">			exitRule();</span>
		}
<span class="fc" id="L3297">		return _localctx;</span>
	}

	public static class InterfaceMethodDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public ArrayDeclaratorContext arrayDeclarator;
<span class="pc" id="L3304">		public List&lt;ArrayDeclaratorContext&gt; cStyleArrDec = new ArrayList&lt;ArrayDeclaratorContext&gt;();</span>
		public IdContext id() {
<span class="nc" id="L3306">			return getRuleContext(IdContext.class,0);</span>
		}
		public FormalParametersContext formalParameters() {
<span class="nc" id="L3309">			return getRuleContext(FormalParametersContext.class,0);</span>
		}
		public MethodBodyContext methodBody() {
<span class="nc" id="L3312">			return getRuleContext(MethodBodyContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L3315">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public TypeParametersContext typeParameters() {
<span class="nc" id="L3318">			return getRuleContext(TypeParametersContext.class,0);</span>
		}
		public ThrowsListContext throwsList() {
<span class="nc" id="L3321">			return getRuleContext(ThrowsListContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L3324">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L3327">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="nc" id="L3329">		public InterfaceMethodDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public InterfaceMethodDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L3331">			super(parent, invokingState);</span>
<span class="fc" id="L3332">			this.mods = mods;</span>
<span class="fc" id="L3333">		}</span>
<span class="nc" id="L3334">		@Override public int getRuleIndex() { return RULE_interfaceMethodDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3337" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInterfaceMethodDeclaration(this);</span>
<span class="nc" id="L3338">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InterfaceMethodDeclarationContext interfaceMethodDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L3343">		InterfaceMethodDeclarationContext _localctx = new InterfaceMethodDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L3344">		enterRule(_localctx, 82, RULE_interfaceMethodDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L3347">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3349">			setState(639);</span>
<span class="fc" id="L3350">			_errHandler.sync(this);</span>
<span class="fc" id="L3351">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3352" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L3354">				setState(638);</span>
<span class="fc" id="L3355">				typeParameters();</span>
				}
			}

<span class="fc" id="L3359">			setState(641);</span>
<span class="fc" id="L3360">			((InterfaceMethodDeclarationContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L3361">			setState(642);</span>
<span class="fc" id="L3362">			id();</span>
<span class="fc" id="L3363">			setState(643);</span>
<span class="fc" id="L3364">			formalParameters();</span>
<span class="fc" id="L3365">			setState(647);</span>
<span class="fc" id="L3366">			_errHandler.sync(this);</span>
<span class="fc" id="L3367">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L3368" title="1 of 4 branches missed.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="fc" id="L3371">				setState(644);</span>
<span class="fc" id="L3372">				((InterfaceMethodDeclarationContext)_localctx).arrayDeclarator = arrayDeclarator();</span>
<span class="fc" id="L3373">				((InterfaceMethodDeclarationContext)_localctx).cStyleArrDec.add(((InterfaceMethodDeclarationContext)_localctx).arrayDeclarator);</span>
				}
				}
<span class="fc" id="L3376">				setState(649);</span>
<span class="fc" id="L3377">				_errHandler.sync(this);</span>
<span class="fc" id="L3378">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L3380">			setState(651);</span>
<span class="fc" id="L3381">			_errHandler.sync(this);</span>
<span class="fc" id="L3382">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3383" title="All 2 branches covered.">			if (_la==LITERAL_THROWS) {</span>
				{
<span class="fc" id="L3385">				setState(650);</span>
<span class="fc" id="L3386">				throwsList();</span>
				}
			}

<span class="fc" id="L3390">			setState(653);</span>
<span class="fc" id="L3391">			methodBody();</span>
			}
		}
<span class="nc" id="L3394">		catch (RecognitionException re) {</span>
<span class="nc" id="L3395">			_localctx.exception = re;</span>
<span class="nc" id="L3396">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3397">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3400">			exitRule();</span>
		}
<span class="fc" id="L3402">		return _localctx;</span>
	}

	public static class VariableDeclaratorsContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public List&lt;VariableDeclaratorContext&gt; variableDeclarator() {
<span class="nc" id="L3409">			return getRuleContexts(VariableDeclaratorContext.class);</span>
		}
		public VariableDeclaratorContext variableDeclarator(int i) {
<span class="nc" id="L3412">			return getRuleContext(VariableDeclaratorContext.class,i);</span>
		}
<span class="nc" id="L3414">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L3416">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
<span class="nc" id="L3418">		public VariableDeclaratorsContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public VariableDeclaratorsContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods, TypeTypeContext type) {
<span class="fc" id="L3420">			super(parent, invokingState);</span>
<span class="fc" id="L3421">			this.mods = mods;</span>
<span class="fc" id="L3422">			this.type = type;</span>
<span class="fc" id="L3423">		}</span>
<span class="nc" id="L3424">		@Override public int getRuleIndex() { return RULE_variableDeclarators; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3427" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableDeclarators(this);</span>
<span class="nc" id="L3428">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableDeclaratorsContext variableDeclarators(List&lt;ModifierContext&gt; mods,TypeTypeContext type) throws RecognitionException {
<span class="fc" id="L3433">		VariableDeclaratorsContext _localctx = new VariableDeclaratorsContext(_ctx, getState(), mods, type);</span>
<span class="fc" id="L3434">		enterRule(_localctx, 84, RULE_variableDeclarators);</span>
		int _la;
		try {
<span class="fc" id="L3437">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3439">			setState(655);</span>
<span class="fc" id="L3440">			variableDeclarator(mods, type);</span>
<span class="fc" id="L3441">			setState(660);</span>
<span class="fc" id="L3442">			_errHandler.sync(this);</span>
<span class="fc" id="L3443">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3444" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L3447">				setState(656);</span>
<span class="fc" id="L3448">				match(COMMA);</span>
<span class="fc" id="L3449">				setState(657);</span>
<span class="fc" id="L3450">				variableDeclarator(mods, type);</span>
				}
				}
<span class="fc" id="L3453">				setState(662);</span>
<span class="fc" id="L3454">				_errHandler.sync(this);</span>
<span class="fc" id="L3455">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L3459">		catch (RecognitionException re) {</span>
<span class="nc" id="L3460">			_localctx.exception = re;</span>
<span class="nc" id="L3461">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3462">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3465">			exitRule();</span>
		}
<span class="fc" id="L3467">		return _localctx;</span>
	}

	public static class VariableDeclaratorContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public IdContext id() {
<span class="fc" id="L3474">			return getRuleContext(IdContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="fc" id="L3477">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L3480">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="fc" id="L3482">		public TerminalNode ASSIGN() { return getToken(JavaLanguageParser.ASSIGN, 0); }</span>
		public VariableInitializerContext variableInitializer() {
<span class="fc" id="L3484">			return getRuleContext(VariableInitializerContext.class,0);</span>
		}
<span class="nc" id="L3486">		public VariableDeclaratorContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public VariableDeclaratorContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods, TypeTypeContext type) {
<span class="fc" id="L3488">			super(parent, invokingState);</span>
<span class="fc" id="L3489">			this.mods = mods;</span>
<span class="fc" id="L3490">			this.type = type;</span>
<span class="fc" id="L3491">		}</span>
<span class="nc" id="L3492">		@Override public int getRuleIndex() { return RULE_variableDeclarator; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3495" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableDeclarator(this);</span>
<span class="nc" id="L3496">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableDeclaratorContext variableDeclarator(List&lt;ModifierContext&gt; mods,TypeTypeContext type) throws RecognitionException {
<span class="fc" id="L3501">		VariableDeclaratorContext _localctx = new VariableDeclaratorContext(_ctx, getState(), mods, type);</span>
<span class="fc" id="L3502">		enterRule(_localctx, 86, RULE_variableDeclarator);</span>
		int _la;
		try {
<span class="fc" id="L3505">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3507">			setState(663);</span>
<span class="fc" id="L3508">			id();</span>
<span class="fc" id="L3509">			setState(667);</span>
<span class="fc" id="L3510">			_errHandler.sync(this);</span>
<span class="fc" id="L3511">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3512" title="All 4 branches covered.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="fc" id="L3515">				setState(664);</span>
<span class="fc" id="L3516">				arrayDeclarator();</span>
				}
				}
<span class="fc" id="L3519">				setState(669);</span>
<span class="fc" id="L3520">				_errHandler.sync(this);</span>
<span class="fc" id="L3521">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L3523">			setState(672);</span>
<span class="fc" id="L3524">			_errHandler.sync(this);</span>
<span class="fc" id="L3525">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3526" title="All 2 branches covered.">			if (_la==ASSIGN) {</span>
				{
<span class="fc" id="L3528">				setState(670);</span>
<span class="fc" id="L3529">				match(ASSIGN);</span>
<span class="fc" id="L3530">				setState(671);</span>
<span class="fc" id="L3531">				variableInitializer();</span>
				}
			}

			}
		}
<span class="nc" id="L3537">		catch (RecognitionException re) {</span>
<span class="nc" id="L3538">			_localctx.exception = re;</span>
<span class="nc" id="L3539">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3540">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3543">			exitRule();</span>
		}
<span class="fc" id="L3545">		return _localctx;</span>
	}

	public static class VariableDeclaratorIdContext extends ParserRuleContext {
		public List&lt;VariableModifierContext&gt; mods;
		public ParserRuleContext type;
<span class="fc" id="L3551">		public TerminalNode LITERAL_THIS() { return getToken(JavaLanguageParser.LITERAL_THIS, 0); }</span>
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="fc" id="L3553">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L3556">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
		public QualifiedNameContext qualifiedName() {
<span class="fc" id="L3559">			return getRuleContext(QualifiedNameContext.class,0);</span>
		}
<span class="fc" id="L3561">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="nc" id="L3562">		public VariableDeclaratorIdContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public VariableDeclaratorIdContext(ParserRuleContext parent, int invokingState, List&lt;VariableModifierContext&gt; mods, ParserRuleContext type) {
<span class="fc" id="L3564">			super(parent, invokingState);</span>
<span class="fc" id="L3565">			this.mods = mods;</span>
<span class="fc" id="L3566">			this.type = type;</span>
<span class="fc" id="L3567">		}</span>
<span class="nc" id="L3568">		@Override public int getRuleIndex() { return RULE_variableDeclaratorId; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3571" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableDeclaratorId(this);</span>
<span class="nc" id="L3572">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableDeclaratorIdContext variableDeclaratorId(List&lt;VariableModifierContext&gt; mods,ParserRuleContext type) throws RecognitionException {
<span class="fc" id="L3577">		VariableDeclaratorIdContext _localctx = new VariableDeclaratorIdContext(_ctx, getState(), mods, type);</span>
<span class="fc" id="L3578">		enterRule(_localctx, 88, RULE_variableDeclaratorId);</span>
		int _la;
		try {
<span class="fc" id="L3581">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3583">			setState(680);</span>
<span class="fc" id="L3584">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L3585" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LITERAL_THIS:
				{
<span class="fc" id="L3588">				setState(674);</span>
<span class="fc" id="L3589">				match(LITERAL_THIS);</span>
				}
<span class="fc" id="L3591">				break;</span>
			case IDENT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
				{
				{
<span class="fc" id="L3600">				setState(675);</span>
<span class="fc" id="L3601">				qualifiedName();</span>
<span class="fc" id="L3602">				setState(678);</span>
<span class="fc" id="L3603">				_errHandler.sync(this);</span>
<span class="fc" id="L3604">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L3605" title="All 2 branches covered.">				if (_la==DOT) {</span>
					{
<span class="fc" id="L3607">					setState(676);</span>
<span class="fc" id="L3608">					match(DOT);</span>
<span class="fc" id="L3609">					setState(677);</span>
<span class="fc" id="L3610">					match(LITERAL_THIS);</span>
					}
				}

				}
				}
				break;
			default:
<span class="nc" id="L3618">				throw new NoViableAltException(this);</span>
			}
<span class="fc" id="L3620">			setState(685);</span>
<span class="fc" id="L3621">			_errHandler.sync(this);</span>
<span class="fc" id="L3622">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3623" title="All 4 branches covered.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="fc" id="L3626">				setState(682);</span>
<span class="fc" id="L3627">				arrayDeclarator();</span>
				}
				}
<span class="fc" id="L3630">				setState(687);</span>
<span class="fc" id="L3631">				_errHandler.sync(this);</span>
<span class="fc" id="L3632">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L3636">		catch (RecognitionException re) {</span>
<span class="nc" id="L3637">			_localctx.exception = re;</span>
<span class="nc" id="L3638">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3639">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3642">			exitRule();</span>
		}
<span class="fc" id="L3644">		return _localctx;</span>
	}

	public static class VariableInitializerContext extends ParserRuleContext {
		public ArrayInitializerContext arrayInitializer() {
<span class="nc" id="L3649">			return getRuleContext(ArrayInitializerContext.class,0);</span>
		}
		public ExpressionContext expression() {
<span class="nc" id="L3652">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public VariableInitializerContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L3655">			super(parent, invokingState);</span>
<span class="fc" id="L3656">		}</span>
<span class="nc" id="L3657">		@Override public int getRuleIndex() { return RULE_variableInitializer; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3660" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableInitializer(this);</span>
<span class="nc" id="L3661">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableInitializerContext variableInitializer() throws RecognitionException {
<span class="fc" id="L3666">		VariableInitializerContext _localctx = new VariableInitializerContext(_ctx, getState());</span>
<span class="fc" id="L3667">		enterRule(_localctx, 90, RULE_variableInitializer);</span>
		try {
<span class="fc" id="L3669">			setState(690);</span>
<span class="fc" id="L3670">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L3671" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LCURLY:
<span class="fc" id="L3673">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L3675">				setState(688);</span>
<span class="fc" id="L3676">				arrayInitializer();</span>
				}
<span class="fc" id="L3678">				break;</span>
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LPAREN:
			case LITERAL_THIS:
			case LITERAL_SUPER:
			case LITERAL_SWITCH:
			case PLUS:
			case MINUS:
			case INC:
			case DEC:
			case BNOT:
			case LNOT:
			case LITERAL_TRUE:
			case LITERAL_FALSE:
			case LITERAL_NULL:
			case LITERAL_NEW:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case AT:
			case FLOAT_LITERAL:
			case DOUBLE_LITERAL:
			case HEX_FLOAT_LITERAL:
			case HEX_DOUBLE_LITERAL:
			case LITERAL_RECORD:
			case TEXT_BLOCK_LITERAL_BEGIN:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
			case DECIMAL_LITERAL_LONG:
			case DECIMAL_LITERAL:
			case HEX_LITERAL_LONG:
			case HEX_LITERAL:
			case OCT_LITERAL_LONG:
			case OCT_LITERAL:
			case BINARY_LITERAL_LONG:
			case BINARY_LITERAL:
<span class="fc" id="L3724">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L3726">				setState(689);</span>
<span class="fc" id="L3727">				expression();</span>
				}
<span class="fc" id="L3729">				break;</span>
			default:
<span class="nc" id="L3731">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L3734">		catch (RecognitionException re) {</span>
<span class="nc" id="L3735">			_localctx.exception = re;</span>
<span class="nc" id="L3736">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3737">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3740">			exitRule();</span>
		}
<span class="fc" id="L3742">		return _localctx;</span>
	}

	public static class ArrayInitializerContext extends ParserRuleContext {
<span class="nc" id="L3746">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L3747">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;VariableInitializerContext&gt; variableInitializer() {
<span class="nc" id="L3749">			return getRuleContexts(VariableInitializerContext.class);</span>
		}
		public VariableInitializerContext variableInitializer(int i) {
<span class="nc" id="L3752">			return getRuleContext(VariableInitializerContext.class,i);</span>
		}
<span class="nc" id="L3754">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L3756">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public ArrayInitializerContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L3759">			super(parent, invokingState);</span>
<span class="fc" id="L3760">		}</span>
<span class="nc" id="L3761">		@Override public int getRuleIndex() { return RULE_arrayInitializer; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3764" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitArrayInitializer(this);</span>
<span class="nc" id="L3765">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ArrayInitializerContext arrayInitializer() throws RecognitionException {
<span class="fc" id="L3770">		ArrayInitializerContext _localctx = new ArrayInitializerContext(_ctx, getState());</span>
<span class="fc" id="L3771">		enterRule(_localctx, 92, RULE_arrayInitializer);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L3775">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3777">			setState(692);</span>
<span class="fc" id="L3778">			match(LCURLY);</span>
<span class="fc" id="L3779">			setState(701);</span>
<span class="fc" id="L3780">			_errHandler.sync(this);</span>
<span class="fc" id="L3781">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L3782" title="2 of 12 branches missed.">			if (((((_la - 49)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 49)) &amp; ((1L &lt;&lt; (LITERAL_VOID - 49)) | (1L &lt;&lt; (LITERAL_BOOLEAN - 49)) | (1L &lt;&lt; (LITERAL_BYTE - 49)) | (1L &lt;&lt; (LITERAL_CHAR - 49)) | (1L &lt;&lt; (LITERAL_SHORT - 49)) | (1L &lt;&lt; (LITERAL_INT - 49)) | (1L &lt;&lt; (LITERAL_FLOAT - 49)) | (1L &lt;&lt; (LITERAL_LONG - 49)) | (1L &lt;&lt; (LITERAL_DOUBLE - 49)) | (1L &lt;&lt; (IDENT - 49)) | (1L &lt;&lt; (LCURLY - 49)) | (1L &lt;&lt; (LPAREN - 49)) | (1L &lt;&lt; (LITERAL_THIS - 49)) | (1L &lt;&lt; (LITERAL_SUPER - 49)) | (1L &lt;&lt; (LITERAL_SWITCH - 49)))) != 0) || ((((_la - 125)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 125)) &amp; ((1L &lt;&lt; (PLUS - 125)) | (1L &lt;&lt; (MINUS - 125)) | (1L &lt;&lt; (INC - 125)) | (1L &lt;&lt; (DEC - 125)) | (1L &lt;&lt; (BNOT - 125)) | (1L &lt;&lt; (LNOT - 125)) | (1L &lt;&lt; (LITERAL_TRUE - 125)) | (1L &lt;&lt; (LITERAL_FALSE - 125)) | (1L &lt;&lt; (LITERAL_NULL - 125)) | (1L &lt;&lt; (LITERAL_NEW - 125)) | (1L &lt;&lt; (CHAR_LITERAL - 125)) | (1L &lt;&lt; (STRING_LITERAL - 125)) | (1L &lt;&lt; (AT - 125)))) != 0) || ((((_la - 192)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 192)) &amp; ((1L &lt;&lt; (FLOAT_LITERAL - 192)) | (1L &lt;&lt; (DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 192)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (LITERAL_RECORD - 192)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 192)) | (1L &lt;&lt; (LITERAL_YIELD - 192)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 192)) | (1L &lt;&lt; (LITERAL_SEALED - 192)) | (1L &lt;&lt; (LITERAL_PERMITS - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL - 192)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 192)) | (1L &lt;&lt; (HEX_LITERAL - 192)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 192)) | (1L &lt;&lt; (OCT_LITERAL - 192)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 192)) | (1L &lt;&lt; (BINARY_LITERAL - 192)))) != 0)) {</span>
				{
<span class="fc" id="L3784">				setState(693);</span>
<span class="fc" id="L3785">				variableInitializer();</span>
<span class="fc" id="L3786">				setState(698);</span>
<span class="fc" id="L3787">				_errHandler.sync(this);</span>
<span class="fc" id="L3788">				_alt = getInterpreter().adaptivePredict(_input,65,_ctx);</span>
<span class="pc bpc" id="L3789" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L3790" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L3793">						setState(694);</span>
<span class="fc" id="L3794">						match(COMMA);</span>
<span class="fc" id="L3795">						setState(695);</span>
<span class="fc" id="L3796">						variableInitializer();</span>
						}
						} 
					}
<span class="fc" id="L3800">					setState(700);</span>
<span class="fc" id="L3801">					_errHandler.sync(this);</span>
<span class="fc" id="L3802">					_alt = getInterpreter().adaptivePredict(_input,65,_ctx);</span>
				}
				}
			}

<span class="fc" id="L3807">			setState(704);</span>
<span class="fc" id="L3808">			_errHandler.sync(this);</span>
<span class="fc" id="L3809">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L3810" title="All 2 branches covered.">			if (_la==COMMA) {</span>
				{
<span class="fc" id="L3812">				setState(703);</span>
<span class="fc" id="L3813">				match(COMMA);</span>
				}
			}

<span class="fc" id="L3817">			setState(706);</span>
<span class="fc" id="L3818">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L3821">		catch (RecognitionException re) {</span>
<span class="nc" id="L3822">			_localctx.exception = re;</span>
<span class="nc" id="L3823">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3824">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3827">			exitRule();</span>
		}
<span class="fc" id="L3829">		return _localctx;</span>
	}

	public static class ClassOrInterfaceTypeContext extends ParserRuleContext {
		public boolean createImaginaryNode;
		public ClassOrInterfaceTypeExtendedContext classOrInterfaceTypeExtended;
<span class="pc" id="L3835">		public List&lt;ClassOrInterfaceTypeExtendedContext&gt; extended = new ArrayList&lt;ClassOrInterfaceTypeExtendedContext&gt;();</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L3837">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="fc" id="L3840">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeArgumentsContext typeArguments() {
<span class="fc" id="L3843">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
		public List&lt;ClassOrInterfaceTypeExtendedContext&gt; classOrInterfaceTypeExtended() {
<span class="nc" id="L3846">			return getRuleContexts(ClassOrInterfaceTypeExtendedContext.class);</span>
		}
		public ClassOrInterfaceTypeExtendedContext classOrInterfaceTypeExtended(int i) {
<span class="nc" id="L3849">			return getRuleContext(ClassOrInterfaceTypeExtendedContext.class,i);</span>
		}
<span class="nc" id="L3851">		public ClassOrInterfaceTypeContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public ClassOrInterfaceTypeContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {
<span class="fc" id="L3853">			super(parent, invokingState);</span>
<span class="fc" id="L3854">			this.createImaginaryNode = createImaginaryNode;</span>
<span class="fc" id="L3855">		}</span>
<span class="nc" id="L3856">		@Override public int getRuleIndex() { return RULE_classOrInterfaceType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3859" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassOrInterfaceType(this);</span>
<span class="nc" id="L3860">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassOrInterfaceTypeContext classOrInterfaceType(boolean createImaginaryNode) throws RecognitionException {
<span class="fc" id="L3865">		ClassOrInterfaceTypeContext _localctx = new ClassOrInterfaceTypeContext(_ctx, getState(), createImaginaryNode);</span>
<span class="fc" id="L3866">		enterRule(_localctx, 94, RULE_classOrInterfaceType);</span>
		try {
			int _alt;
<span class="fc" id="L3869">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3871">			setState(708);</span>
<span class="fc" id="L3872">			annotations(false);</span>
<span class="fc" id="L3873">			setState(709);</span>
<span class="fc" id="L3874">			id();</span>
<span class="fc" id="L3875">			setState(711);</span>
<span class="fc" id="L3876">			_errHandler.sync(this);</span>
<span class="fc bfc" id="L3877" title="All 2 branches covered.">			switch ( getInterpreter().adaptivePredict(_input,68,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L3880">				setState(710);</span>
<span class="fc" id="L3881">				typeArguments();</span>
				}
				break;
			}
<span class="fc" id="L3885">			setState(716);</span>
<span class="fc" id="L3886">			_errHandler.sync(this);</span>
<span class="fc" id="L3887">			_alt = getInterpreter().adaptivePredict(_input,69,_ctx);</span>
<span class="pc bpc" id="L3888" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L3889" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L3892">					setState(713);</span>
<span class="fc" id="L3893">					((ClassOrInterfaceTypeContext)_localctx).classOrInterfaceTypeExtended = classOrInterfaceTypeExtended();</span>
<span class="fc" id="L3894">					((ClassOrInterfaceTypeContext)_localctx).extended.add(((ClassOrInterfaceTypeContext)_localctx).classOrInterfaceTypeExtended);</span>
					}
					} 
				}
<span class="fc" id="L3898">				setState(718);</span>
<span class="fc" id="L3899">				_errHandler.sync(this);</span>
<span class="fc" id="L3900">				_alt = getInterpreter().adaptivePredict(_input,69,_ctx);</span>
			}
			}
		}
<span class="nc" id="L3904">		catch (RecognitionException re) {</span>
<span class="nc" id="L3905">			_localctx.exception = re;</span>
<span class="nc" id="L3906">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3907">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3910">			exitRule();</span>
		}
<span class="fc" id="L3912">		return _localctx;</span>
	}

	public static class ClassOrInterfaceTypeExtendedContext extends ParserRuleContext {
<span class="nc" id="L3916">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L3918">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L3921">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeArgumentsContext typeArguments() {
<span class="nc" id="L3924">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
		public ClassOrInterfaceTypeExtendedContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L3927">			super(parent, invokingState);</span>
<span class="fc" id="L3928">		}</span>
<span class="nc" id="L3929">		@Override public int getRuleIndex() { return RULE_classOrInterfaceTypeExtended; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L3932" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassOrInterfaceTypeExtended(this);</span>
<span class="nc" id="L3933">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassOrInterfaceTypeExtendedContext classOrInterfaceTypeExtended() throws RecognitionException {
<span class="fc" id="L3938">		ClassOrInterfaceTypeExtendedContext _localctx = new ClassOrInterfaceTypeExtendedContext(_ctx, getState());</span>
<span class="fc" id="L3939">		enterRule(_localctx, 96, RULE_classOrInterfaceTypeExtended);</span>
		try {
<span class="fc" id="L3941">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L3943">			setState(719);</span>
<span class="fc" id="L3944">			match(DOT);</span>
<span class="fc" id="L3945">			setState(720);</span>
<span class="fc" id="L3946">			annotations(false);</span>
<span class="fc" id="L3947">			setState(721);</span>
<span class="fc" id="L3948">			id();</span>
<span class="fc" id="L3949">			setState(723);</span>
<span class="fc" id="L3950">			_errHandler.sync(this);</span>
<span class="fc bfc" id="L3951" title="All 2 branches covered.">			switch ( getInterpreter().adaptivePredict(_input,70,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L3954">				setState(722);</span>
<span class="fc" id="L3955">				typeArguments();</span>
				}
				break;
			}
			}
		}
<span class="nc" id="L3961">		catch (RecognitionException re) {</span>
<span class="nc" id="L3962">			_localctx.exception = re;</span>
<span class="nc" id="L3963">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L3964">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L3967">			exitRule();</span>
		}
<span class="fc" id="L3969">		return _localctx;</span>
	}

	public static class TypeArgumentContext extends ParserRuleContext {
		public TypeArgumentContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L3974">			super(parent, invokingState);</span>
<span class="fc" id="L3975">		}</span>
<span class="nc" id="L3976">		@Override public int getRuleIndex() { return RULE_typeArgument; }</span>
	 
<span class="fc" id="L3978">		public TypeArgumentContext() { }</span>
		public void copyFrom(TypeArgumentContext ctx) {
<span class="fc" id="L3980">			super.copyFrom(ctx);</span>
<span class="fc" id="L3981">		}</span>
	}
	public static class WildCardTypeArgumentContext extends TypeArgumentContext {
		public Token upperBound;
		public Token lowerBound;
		public AnnotationsContext annotations() {
<span class="fc" id="L3987">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
<span class="fc" id="L3989">		public TerminalNode QUESTION() { return getToken(JavaLanguageParser.QUESTION, 0); }</span>
		public TypeTypeContext typeType() {
<span class="fc" id="L3991">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
<span class="nc" id="L3993">		public TerminalNode EXTENDS_CLAUSE() { return getToken(JavaLanguageParser.EXTENDS_CLAUSE, 0); }</span>
<span class="nc" id="L3994">		public TerminalNode LITERAL_SUPER() { return getToken(JavaLanguageParser.LITERAL_SUPER, 0); }</span>
<span class="fc" id="L3995">		public WildCardTypeArgumentContext(TypeArgumentContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L3998" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitWildCardTypeArgument(this);</span>
<span class="nc" id="L3999">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SimpleTypeArgumentContext extends TypeArgumentContext {
		public TypeTypeContext typeType() {
<span class="fc" id="L4004">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
<span class="fc" id="L4006">		public SimpleTypeArgumentContext(TypeArgumentContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4009" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSimpleTypeArgument(this);</span>
<span class="nc" id="L4010">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeArgumentContext typeArgument() throws RecognitionException {
<span class="fc" id="L4015">		TypeArgumentContext _localctx = new TypeArgumentContext(_ctx, getState());</span>
<span class="fc" id="L4016">		enterRule(_localctx, 98, RULE_typeArgument);</span>
		int _la;
		try {
<span class="fc" id="L4019">			setState(735);</span>
<span class="fc" id="L4020">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L4021" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,73,_ctx) ) {</span>
			case 1:
<span class="fc" id="L4023">				_localctx = new SimpleTypeArgumentContext(_localctx);</span>
<span class="fc" id="L4024">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L4026">				setState(725);</span>
<span class="fc" id="L4027">				typeType(false);</span>
				}
<span class="fc" id="L4029">				break;</span>
			case 2:
<span class="fc" id="L4031">				_localctx = new WildCardTypeArgumentContext(_localctx);</span>
<span class="fc" id="L4032">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L4034">				setState(726);</span>
<span class="fc" id="L4035">				annotations(false);</span>
<span class="fc" id="L4036">				setState(727);</span>
<span class="fc" id="L4037">				match(QUESTION);</span>
<span class="fc" id="L4038">				setState(733);</span>
<span class="fc" id="L4039">				_errHandler.sync(this);</span>
<span class="fc" id="L4040">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L4041" title="All 4 branches covered.">				if (_la==EXTENDS_CLAUSE || _la==LITERAL_SUPER) {</span>
					{
<span class="fc" id="L4043">					setState(730);</span>
<span class="fc" id="L4044">					_errHandler.sync(this);</span>
<span class="pc bpc" id="L4045" title="1 of 3 branches missed.">					switch (_input.LA(1)) {</span>
					case EXTENDS_CLAUSE:
						{
<span class="fc" id="L4048">						setState(728);</span>
<span class="fc" id="L4049">						((WildCardTypeArgumentContext)_localctx).upperBound = match(EXTENDS_CLAUSE);</span>
						}
<span class="fc" id="L4051">						break;</span>
					case LITERAL_SUPER:
						{
<span class="fc" id="L4054">						setState(729);</span>
<span class="fc" id="L4055">						((WildCardTypeArgumentContext)_localctx).lowerBound = match(LITERAL_SUPER);</span>
						}
<span class="fc" id="L4057">						break;</span>
					default:
<span class="nc" id="L4059">						throw new NoViableAltException(this);</span>
					}
<span class="fc" id="L4061">					setState(732);</span>
<span class="fc" id="L4062">					typeType(false);</span>
					}
				}

				}
				break;
			}
		}
<span class="nc" id="L4070">		catch (RecognitionException re) {</span>
<span class="nc" id="L4071">			_localctx.exception = re;</span>
<span class="nc" id="L4072">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4073">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4076">			exitRule();</span>
		}
<span class="fc" id="L4078">		return _localctx;</span>
	}

	public static class QualifiedNameListContext extends ParserRuleContext {
		public List&lt;AnnotationsContext&gt; annotations() {
<span class="nc" id="L4083">			return getRuleContexts(AnnotationsContext.class);</span>
		}
		public AnnotationsContext annotations(int i) {
<span class="nc" id="L4086">			return getRuleContext(AnnotationsContext.class,i);</span>
		}
		public List&lt;QualifiedNameContext&gt; qualifiedName() {
<span class="nc" id="L4089">			return getRuleContexts(QualifiedNameContext.class);</span>
		}
		public QualifiedNameContext qualifiedName(int i) {
<span class="nc" id="L4092">			return getRuleContext(QualifiedNameContext.class,i);</span>
		}
<span class="nc" id="L4094">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L4096">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public QualifiedNameListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4099">			super(parent, invokingState);</span>
<span class="fc" id="L4100">		}</span>
<span class="nc" id="L4101">		@Override public int getRuleIndex() { return RULE_qualifiedNameList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4104" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitQualifiedNameList(this);</span>
<span class="nc" id="L4105">			else return visitor.visitChildren(this);</span>
		}
	}

	public final QualifiedNameListContext qualifiedNameList() throws RecognitionException {
<span class="fc" id="L4110">		QualifiedNameListContext _localctx = new QualifiedNameListContext(_ctx, getState());</span>
<span class="fc" id="L4111">		enterRule(_localctx, 100, RULE_qualifiedNameList);</span>
		int _la;
		try {
<span class="fc" id="L4114">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4116">			setState(737);</span>
<span class="fc" id="L4117">			annotations(false);</span>
<span class="fc" id="L4118">			setState(738);</span>
<span class="fc" id="L4119">			qualifiedName();</span>
<span class="fc" id="L4120">			setState(745);</span>
<span class="fc" id="L4121">			_errHandler.sync(this);</span>
<span class="fc" id="L4122">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L4123" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L4126">				setState(739);</span>
<span class="fc" id="L4127">				match(COMMA);</span>
<span class="fc" id="L4128">				setState(740);</span>
<span class="fc" id="L4129">				annotations(false);</span>
<span class="fc" id="L4130">				setState(741);</span>
<span class="fc" id="L4131">				qualifiedName();</span>
				}
				}
<span class="fc" id="L4134">				setState(747);</span>
<span class="fc" id="L4135">				_errHandler.sync(this);</span>
<span class="fc" id="L4136">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L4140">		catch (RecognitionException re) {</span>
<span class="nc" id="L4141">			_localctx.exception = re;</span>
<span class="nc" id="L4142">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4143">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4146">			exitRule();</span>
		}
<span class="fc" id="L4148">		return _localctx;</span>
	}

	public static class FormalParametersContext extends ParserRuleContext {
<span class="fc" id="L4152">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L4153">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public FormalParameterListContext formalParameterList() {
<span class="fc" id="L4155">			return getRuleContext(FormalParameterListContext.class,0);</span>
		}
		public FormalParametersContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4158">			super(parent, invokingState);</span>
<span class="fc" id="L4159">		}</span>
<span class="nc" id="L4160">		@Override public int getRuleIndex() { return RULE_formalParameters; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4163" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFormalParameters(this);</span>
<span class="nc" id="L4164">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FormalParametersContext formalParameters() throws RecognitionException {
<span class="fc" id="L4169">		FormalParametersContext _localctx = new FormalParametersContext(_ctx, getState());</span>
<span class="fc" id="L4170">		enterRule(_localctx, 102, RULE_formalParameters);</span>
		int _la;
		try {
<span class="fc" id="L4173">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4175">			setState(748);</span>
<span class="fc" id="L4176">			match(LPAREN);</span>
<span class="fc" id="L4177">			setState(750);</span>
<span class="fc" id="L4178">			_errHandler.sync(this);</span>
<span class="fc" id="L4179">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L4180" title="2 of 8 branches missed.">			if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)))) != 0)) {</span>
				{
<span class="fc" id="L4182">				setState(749);</span>
<span class="fc" id="L4183">				formalParameterList();</span>
				}
			}

<span class="fc" id="L4187">			setState(752);</span>
<span class="fc" id="L4188">			match(RPAREN);</span>
			}
		}
<span class="nc" id="L4191">		catch (RecognitionException re) {</span>
<span class="nc" id="L4192">			_localctx.exception = re;</span>
<span class="nc" id="L4193">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4194">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4197">			exitRule();</span>
		}
<span class="fc" id="L4199">		return _localctx;</span>
	}

	public static class FormalParameterListContext extends ParserRuleContext {
		public List&lt;FormalParameterContext&gt; formalParameter() {
<span class="nc" id="L4204">			return getRuleContexts(FormalParameterContext.class);</span>
		}
		public FormalParameterContext formalParameter(int i) {
<span class="nc" id="L4207">			return getRuleContext(FormalParameterContext.class,i);</span>
		}
<span class="nc" id="L4209">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L4211">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public LastFormalParameterContext lastFormalParameter() {
<span class="nc" id="L4214">			return getRuleContext(LastFormalParameterContext.class,0);</span>
		}
		public FormalParameterListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4217">			super(parent, invokingState);</span>
<span class="fc" id="L4218">		}</span>
<span class="nc" id="L4219">		@Override public int getRuleIndex() { return RULE_formalParameterList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4222" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFormalParameterList(this);</span>
<span class="nc" id="L4223">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FormalParameterListContext formalParameterList() throws RecognitionException {
<span class="fc" id="L4228">		FormalParameterListContext _localctx = new FormalParameterListContext(_ctx, getState());</span>
<span class="fc" id="L4229">		enterRule(_localctx, 104, RULE_formalParameterList);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L4233">			setState(767);</span>
<span class="fc" id="L4234">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L4235" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,78,_ctx) ) {</span>
			case 1:
<span class="fc" id="L4237">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L4239">				setState(754);</span>
<span class="fc" id="L4240">				formalParameter();</span>
<span class="fc" id="L4241">				setState(759);</span>
<span class="fc" id="L4242">				_errHandler.sync(this);</span>
<span class="fc" id="L4243">				_alt = getInterpreter().adaptivePredict(_input,76,_ctx);</span>
<span class="pc bpc" id="L4244" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L4245" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L4248">						setState(755);</span>
<span class="fc" id="L4249">						match(COMMA);</span>
<span class="fc" id="L4250">						setState(756);</span>
<span class="fc" id="L4251">						formalParameter();</span>
						}
						} 
					}
<span class="fc" id="L4255">					setState(761);</span>
<span class="fc" id="L4256">					_errHandler.sync(this);</span>
<span class="fc" id="L4257">					_alt = getInterpreter().adaptivePredict(_input,76,_ctx);</span>
				}
<span class="fc" id="L4259">				setState(764);</span>
<span class="fc" id="L4260">				_errHandler.sync(this);</span>
<span class="fc" id="L4261">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L4262" title="All 2 branches covered.">				if (_la==COMMA) {</span>
					{
<span class="fc" id="L4264">					setState(762);</span>
<span class="fc" id="L4265">					match(COMMA);</span>
<span class="fc" id="L4266">					setState(763);</span>
<span class="fc" id="L4267">					lastFormalParameter();</span>
					}
				}

				}
				break;
			case 2:
<span class="fc" id="L4274">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L4276">				setState(766);</span>
<span class="fc" id="L4277">				lastFormalParameter();</span>
				}
				break;
			}
		}
<span class="nc" id="L4282">		catch (RecognitionException re) {</span>
<span class="nc" id="L4283">			_localctx.exception = re;</span>
<span class="nc" id="L4284">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4285">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4288">			exitRule();</span>
		}
<span class="fc" id="L4290">		return _localctx;</span>
	}

	public static class FormalParameterContext extends ParserRuleContext {
		public VariableModifierContext variableModifier;
<span class="fc" id="L4295">		public List&lt;VariableModifierContext&gt; mods = new ArrayList&lt;VariableModifierContext&gt;();</span>
		public TypeTypeContext type;
		public VariableDeclaratorIdContext variableDeclaratorId() {
<span class="fc" id="L4298">			return getRuleContext(VariableDeclaratorIdContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L4301">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public List&lt;VariableModifierContext&gt; variableModifier() {
<span class="nc" id="L4304">			return getRuleContexts(VariableModifierContext.class);</span>
		}
		public VariableModifierContext variableModifier(int i) {
<span class="nc" id="L4307">			return getRuleContext(VariableModifierContext.class,i);</span>
		}
		public FormalParameterContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4310">			super(parent, invokingState);</span>
<span class="fc" id="L4311">		}</span>
<span class="nc" id="L4312">		@Override public int getRuleIndex() { return RULE_formalParameter; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4315" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFormalParameter(this);</span>
<span class="nc" id="L4316">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FormalParameterContext formalParameter() throws RecognitionException {
<span class="fc" id="L4321">		FormalParameterContext _localctx = new FormalParameterContext(_ctx, getState());</span>
<span class="fc" id="L4322">		enterRule(_localctx, 106, RULE_formalParameter);</span>
		try {
			int _alt;
<span class="fc" id="L4325">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4327">			setState(772);</span>
<span class="fc" id="L4328">			_errHandler.sync(this);</span>
<span class="fc" id="L4329">			_alt = getInterpreter().adaptivePredict(_input,79,_ctx);</span>
<span class="pc bpc" id="L4330" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L4331" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L4334">					setState(769);</span>
<span class="fc" id="L4335">					((FormalParameterContext)_localctx).variableModifier = variableModifier();</span>
<span class="fc" id="L4336">					((FormalParameterContext)_localctx).mods.add(((FormalParameterContext)_localctx).variableModifier);</span>
					}
					} 
				}
<span class="fc" id="L4340">				setState(774);</span>
<span class="fc" id="L4341">				_errHandler.sync(this);</span>
<span class="fc" id="L4342">				_alt = getInterpreter().adaptivePredict(_input,79,_ctx);</span>
			}
<span class="fc" id="L4344">			setState(775);</span>
<span class="fc" id="L4345">			((FormalParameterContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L4346">			setState(776);</span>
<span class="fc" id="L4347">			variableDeclaratorId(_localctx.mods, _localctx.type);</span>
			}
		}
<span class="nc" id="L4350">		catch (RecognitionException re) {</span>
<span class="nc" id="L4351">			_localctx.exception = re;</span>
<span class="nc" id="L4352">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4353">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4356">			exitRule();</span>
		}
<span class="fc" id="L4358">		return _localctx;</span>
	}

	public static class LastFormalParameterContext extends ParserRuleContext {
		public VariableModifierContext variableModifier;
<span class="fc" id="L4363">		public List&lt;VariableModifierContext&gt; mods = new ArrayList&lt;VariableModifierContext&gt;();</span>
		public TypeTypeContext type;
		public AnnotationsContext annotations() {
<span class="fc" id="L4366">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
<span class="fc" id="L4368">		public TerminalNode ELLIPSIS() { return getToken(JavaLanguageParser.ELLIPSIS, 0); }</span>
		public VariableDeclaratorIdContext variableDeclaratorId() {
<span class="fc" id="L4370">			return getRuleContext(VariableDeclaratorIdContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L4373">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public List&lt;VariableModifierContext&gt; variableModifier() {
<span class="nc" id="L4376">			return getRuleContexts(VariableModifierContext.class);</span>
		}
		public VariableModifierContext variableModifier(int i) {
<span class="nc" id="L4379">			return getRuleContext(VariableModifierContext.class,i);</span>
		}
		public LastFormalParameterContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4382">			super(parent, invokingState);</span>
<span class="fc" id="L4383">		}</span>
<span class="nc" id="L4384">		@Override public int getRuleIndex() { return RULE_lastFormalParameter; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4387" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLastFormalParameter(this);</span>
<span class="nc" id="L4388">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LastFormalParameterContext lastFormalParameter() throws RecognitionException {
<span class="fc" id="L4393">		LastFormalParameterContext _localctx = new LastFormalParameterContext(_ctx, getState());</span>
<span class="fc" id="L4394">		enterRule(_localctx, 108, RULE_lastFormalParameter);</span>
		try {
			int _alt;
<span class="fc" id="L4397">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4399">			setState(781);</span>
<span class="fc" id="L4400">			_errHandler.sync(this);</span>
<span class="fc" id="L4401">			_alt = getInterpreter().adaptivePredict(_input,80,_ctx);</span>
<span class="pc bpc" id="L4402" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L4403" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L4406">					setState(778);</span>
<span class="fc" id="L4407">					((LastFormalParameterContext)_localctx).variableModifier = variableModifier();</span>
<span class="fc" id="L4408">					((LastFormalParameterContext)_localctx).mods.add(((LastFormalParameterContext)_localctx).variableModifier);</span>
					}
					} 
				}
<span class="fc" id="L4412">				setState(783);</span>
<span class="fc" id="L4413">				_errHandler.sync(this);</span>
<span class="fc" id="L4414">				_alt = getInterpreter().adaptivePredict(_input,80,_ctx);</span>
			}
<span class="fc" id="L4416">			setState(784);</span>
<span class="fc" id="L4417">			((LastFormalParameterContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L4418">			setState(785);</span>
<span class="fc" id="L4419">			annotations(false);</span>
<span class="fc" id="L4420">			setState(786);</span>
<span class="fc" id="L4421">			match(ELLIPSIS);</span>
<span class="fc" id="L4422">			setState(787);</span>
<span class="fc" id="L4423">			variableDeclaratorId(_localctx.mods, _localctx.type);</span>
			}
		}
<span class="nc" id="L4426">		catch (RecognitionException re) {</span>
<span class="nc" id="L4427">			_localctx.exception = re;</span>
<span class="nc" id="L4428">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4429">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4432">			exitRule();</span>
		}
<span class="fc" id="L4434">		return _localctx;</span>
	}

	public static class QualifiedNameContext extends ParserRuleContext {
		public QualifiedNameExtendedContext qualifiedNameExtended;
<span class="fc" id="L4439">		public List&lt;QualifiedNameExtendedContext&gt; extended = new ArrayList&lt;QualifiedNameExtendedContext&gt;();</span>
		public IdContext id() {
<span class="fc" id="L4441">			return getRuleContext(IdContext.class,0);</span>
		}
		public List&lt;QualifiedNameExtendedContext&gt; qualifiedNameExtended() {
<span class="nc" id="L4444">			return getRuleContexts(QualifiedNameExtendedContext.class);</span>
		}
		public QualifiedNameExtendedContext qualifiedNameExtended(int i) {
<span class="nc" id="L4447">			return getRuleContext(QualifiedNameExtendedContext.class,i);</span>
		}
		public QualifiedNameContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4450">			super(parent, invokingState);</span>
<span class="fc" id="L4451">		}</span>
<span class="nc" id="L4452">		@Override public int getRuleIndex() { return RULE_qualifiedName; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4455" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitQualifiedName(this);</span>
<span class="nc" id="L4456">			else return visitor.visitChildren(this);</span>
		}
	}

	public final QualifiedNameContext qualifiedName() throws RecognitionException {
<span class="fc" id="L4461">		QualifiedNameContext _localctx = new QualifiedNameContext(_ctx, getState());</span>
<span class="fc" id="L4462">		enterRule(_localctx, 110, RULE_qualifiedName);</span>
		try {
			int _alt;
<span class="fc" id="L4465">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4467">			setState(789);</span>
<span class="fc" id="L4468">			id();</span>
<span class="fc" id="L4469">			setState(793);</span>
<span class="fc" id="L4470">			_errHandler.sync(this);</span>
<span class="fc" id="L4471">			_alt = getInterpreter().adaptivePredict(_input,81,_ctx);</span>
<span class="pc bpc" id="L4472" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L4473" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L4476">					setState(790);</span>
<span class="fc" id="L4477">					((QualifiedNameContext)_localctx).qualifiedNameExtended = qualifiedNameExtended();</span>
<span class="fc" id="L4478">					((QualifiedNameContext)_localctx).extended.add(((QualifiedNameContext)_localctx).qualifiedNameExtended);</span>
					}
					} 
				}
<span class="fc" id="L4482">				setState(795);</span>
<span class="fc" id="L4483">				_errHandler.sync(this);</span>
<span class="fc" id="L4484">				_alt = getInterpreter().adaptivePredict(_input,81,_ctx);</span>
			}
			}
		}
<span class="nc" id="L4488">		catch (RecognitionException re) {</span>
<span class="nc" id="L4489">			_localctx.exception = re;</span>
<span class="nc" id="L4490">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4491">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4494">			exitRule();</span>
		}
<span class="fc" id="L4496">		return _localctx;</span>
	}

	public static class QualifiedNameExtendedContext extends ParserRuleContext {
<span class="nc" id="L4500">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L4502">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L4505">			return getRuleContext(IdContext.class,0);</span>
		}
		public QualifiedNameExtendedContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4508">			super(parent, invokingState);</span>
<span class="fc" id="L4509">		}</span>
<span class="nc" id="L4510">		@Override public int getRuleIndex() { return RULE_qualifiedNameExtended; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L4513" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitQualifiedNameExtended(this);</span>
<span class="nc" id="L4514">			else return visitor.visitChildren(this);</span>
		}
	}

	public final QualifiedNameExtendedContext qualifiedNameExtended() throws RecognitionException {
<span class="fc" id="L4519">		QualifiedNameExtendedContext _localctx = new QualifiedNameExtendedContext(_ctx, getState());</span>
<span class="fc" id="L4520">		enterRule(_localctx, 112, RULE_qualifiedNameExtended);</span>
		try {
<span class="fc" id="L4522">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4524">			setState(796);</span>
<span class="fc" id="L4525">			match(DOT);</span>
<span class="fc" id="L4526">			setState(797);</span>
<span class="fc" id="L4527">			annotations(false);</span>
<span class="fc" id="L4528">			setState(798);</span>
<span class="fc" id="L4529">			id();</span>
			}
		}
<span class="nc" id="L4532">		catch (RecognitionException re) {</span>
<span class="nc" id="L4533">			_localctx.exception = re;</span>
<span class="nc" id="L4534">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4535">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4538">			exitRule();</span>
		}
<span class="fc" id="L4540">		return _localctx;</span>
	}

	public static class LiteralContext extends ParserRuleContext {
		public IntegerLiteralContext integerLiteral() {
<span class="nc" id="L4545">			return getRuleContext(IntegerLiteralContext.class,0);</span>
		}
		public FloatLiteralContext floatLiteral() {
<span class="nc" id="L4548">			return getRuleContext(FloatLiteralContext.class,0);</span>
		}
		public TextBlockLiteralContext textBlockLiteral() {
<span class="nc" id="L4551">			return getRuleContext(TextBlockLiteralContext.class,0);</span>
		}
<span class="nc" id="L4553">		public TerminalNode CHAR_LITERAL() { return getToken(JavaLanguageParser.CHAR_LITERAL, 0); }</span>
<span class="nc" id="L4554">		public TerminalNode STRING_LITERAL() { return getToken(JavaLanguageParser.STRING_LITERAL, 0); }</span>
<span class="nc" id="L4555">		public TerminalNode LITERAL_TRUE() { return getToken(JavaLanguageParser.LITERAL_TRUE, 0); }</span>
<span class="nc" id="L4556">		public TerminalNode LITERAL_FALSE() { return getToken(JavaLanguageParser.LITERAL_FALSE, 0); }</span>
<span class="nc" id="L4557">		public TerminalNode LITERAL_NULL() { return getToken(JavaLanguageParser.LITERAL_NULL, 0); }</span>
		public LiteralContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4559">			super(parent, invokingState);</span>
<span class="fc" id="L4560">		}</span>
<span class="nc" id="L4561">		@Override public int getRuleIndex() { return RULE_literal; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4564" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLiteral(this);</span>
<span class="nc" id="L4565">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LiteralContext literal() throws RecognitionException {
<span class="fc" id="L4570">		LiteralContext _localctx = new LiteralContext(_ctx, getState());</span>
<span class="fc" id="L4571">		enterRule(_localctx, 114, RULE_literal);</span>
		try {
<span class="fc" id="L4573">			setState(808);</span>
<span class="fc" id="L4574">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L4575" title="1 of 9 branches missed.">			switch (_input.LA(1)) {</span>
			case DECIMAL_LITERAL_LONG:
			case DECIMAL_LITERAL:
			case HEX_LITERAL_LONG:
			case HEX_LITERAL:
			case OCT_LITERAL_LONG:
			case OCT_LITERAL:
			case BINARY_LITERAL_LONG:
			case BINARY_LITERAL:
<span class="fc" id="L4584">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L4586">				setState(800);</span>
<span class="fc" id="L4587">				integerLiteral();</span>
				}
<span class="fc" id="L4589">				break;</span>
			case FLOAT_LITERAL:
			case DOUBLE_LITERAL:
			case HEX_FLOAT_LITERAL:
			case HEX_DOUBLE_LITERAL:
<span class="fc" id="L4594">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L4596">				setState(801);</span>
<span class="fc" id="L4597">				floatLiteral();</span>
				}
<span class="fc" id="L4599">				break;</span>
			case TEXT_BLOCK_LITERAL_BEGIN:
<span class="fc" id="L4601">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L4603">				setState(802);</span>
<span class="fc" id="L4604">				textBlockLiteral();</span>
				}
<span class="fc" id="L4606">				break;</span>
			case CHAR_LITERAL:
<span class="fc" id="L4608">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L4610">				setState(803);</span>
<span class="fc" id="L4611">				match(CHAR_LITERAL);</span>
				}
<span class="fc" id="L4613">				break;</span>
			case STRING_LITERAL:
<span class="fc" id="L4615">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L4617">				setState(804);</span>
<span class="fc" id="L4618">				match(STRING_LITERAL);</span>
				}
<span class="fc" id="L4620">				break;</span>
			case LITERAL_TRUE:
<span class="fc" id="L4622">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L4624">				setState(805);</span>
<span class="fc" id="L4625">				match(LITERAL_TRUE);</span>
				}
<span class="fc" id="L4627">				break;</span>
			case LITERAL_FALSE:
<span class="fc" id="L4629">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L4631">				setState(806);</span>
<span class="fc" id="L4632">				match(LITERAL_FALSE);</span>
				}
<span class="fc" id="L4634">				break;</span>
			case LITERAL_NULL:
<span class="fc" id="L4636">				enterOuterAlt(_localctx, 8);</span>
				{
<span class="fc" id="L4638">				setState(807);</span>
<span class="fc" id="L4639">				match(LITERAL_NULL);</span>
				}
<span class="fc" id="L4641">				break;</span>
			default:
<span class="nc" id="L4643">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L4646">		catch (RecognitionException re) {</span>
<span class="nc" id="L4647">			_localctx.exception = re;</span>
<span class="nc" id="L4648">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4649">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4652">			exitRule();</span>
		}
<span class="fc" id="L4654">		return _localctx;</span>
	}

	public static class IntegerLiteralContext extends ParserRuleContext {
<span class="nc" id="L4658">		public TerminalNode DECIMAL_LITERAL_LONG() { return getToken(JavaLanguageParser.DECIMAL_LITERAL_LONG, 0); }</span>
<span class="nc" id="L4659">		public TerminalNode DECIMAL_LITERAL() { return getToken(JavaLanguageParser.DECIMAL_LITERAL, 0); }</span>
<span class="nc" id="L4660">		public TerminalNode HEX_LITERAL_LONG() { return getToken(JavaLanguageParser.HEX_LITERAL_LONG, 0); }</span>
<span class="nc" id="L4661">		public TerminalNode HEX_LITERAL() { return getToken(JavaLanguageParser.HEX_LITERAL, 0); }</span>
<span class="nc" id="L4662">		public TerminalNode OCT_LITERAL_LONG() { return getToken(JavaLanguageParser.OCT_LITERAL_LONG, 0); }</span>
<span class="nc" id="L4663">		public TerminalNode OCT_LITERAL() { return getToken(JavaLanguageParser.OCT_LITERAL, 0); }</span>
<span class="nc" id="L4664">		public TerminalNode BINARY_LITERAL_LONG() { return getToken(JavaLanguageParser.BINARY_LITERAL_LONG, 0); }</span>
<span class="nc" id="L4665">		public TerminalNode BINARY_LITERAL() { return getToken(JavaLanguageParser.BINARY_LITERAL, 0); }</span>
		public IntegerLiteralContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4667">			super(parent, invokingState);</span>
<span class="fc" id="L4668">		}</span>
<span class="nc" id="L4669">		@Override public int getRuleIndex() { return RULE_integerLiteral; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4672" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitIntegerLiteral(this);</span>
<span class="nc" id="L4673">			else return visitor.visitChildren(this);</span>
		}
	}

	public final IntegerLiteralContext integerLiteral() throws RecognitionException {
<span class="fc" id="L4678">		IntegerLiteralContext _localctx = new IntegerLiteralContext(_ctx, getState());</span>
<span class="fc" id="L4679">		enterRule(_localctx, 116, RULE_integerLiteral);</span>
		int _la;
		try {
<span class="fc" id="L4682">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4684">			setState(810);</span>
<span class="fc" id="L4685">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L4686" title="2 of 4 branches missed.">			if ( !(((((_la - 216)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 216)) &amp; ((1L &lt;&lt; (DECIMAL_LITERAL_LONG - 216)) | (1L &lt;&lt; (DECIMAL_LITERAL - 216)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 216)) | (1L &lt;&lt; (HEX_LITERAL - 216)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 216)) | (1L &lt;&lt; (OCT_LITERAL - 216)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 216)) | (1L &lt;&lt; (BINARY_LITERAL - 216)))) != 0)) ) {</span>
<span class="nc" id="L4687">			_errHandler.recoverInline(this);</span>
			}
			else {
<span class="pc bpc" id="L4690" title="1 of 2 branches missed.">				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L4691">				_errHandler.reportMatch(this);</span>
<span class="fc" id="L4692">				consume();</span>
			}
			}
		}
<span class="nc" id="L4696">		catch (RecognitionException re) {</span>
<span class="nc" id="L4697">			_localctx.exception = re;</span>
<span class="nc" id="L4698">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4699">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4702">			exitRule();</span>
		}
<span class="fc" id="L4704">		return _localctx;</span>
	}

	public static class FloatLiteralContext extends ParserRuleContext {
<span class="nc" id="L4708">		public TerminalNode DOUBLE_LITERAL() { return getToken(JavaLanguageParser.DOUBLE_LITERAL, 0); }</span>
<span class="nc" id="L4709">		public TerminalNode FLOAT_LITERAL() { return getToken(JavaLanguageParser.FLOAT_LITERAL, 0); }</span>
<span class="nc" id="L4710">		public TerminalNode HEX_DOUBLE_LITERAL() { return getToken(JavaLanguageParser.HEX_DOUBLE_LITERAL, 0); }</span>
<span class="nc" id="L4711">		public TerminalNode HEX_FLOAT_LITERAL() { return getToken(JavaLanguageParser.HEX_FLOAT_LITERAL, 0); }</span>
		public FloatLiteralContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4713">			super(parent, invokingState);</span>
<span class="fc" id="L4714">		}</span>
<span class="nc" id="L4715">		@Override public int getRuleIndex() { return RULE_floatLiteral; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4718" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFloatLiteral(this);</span>
<span class="nc" id="L4719">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FloatLiteralContext floatLiteral() throws RecognitionException {
<span class="fc" id="L4724">		FloatLiteralContext _localctx = new FloatLiteralContext(_ctx, getState());</span>
<span class="fc" id="L4725">		enterRule(_localctx, 118, RULE_floatLiteral);</span>
		int _la;
		try {
<span class="fc" id="L4728">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4730">			setState(812);</span>
<span class="fc" id="L4731">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L4732" title="2 of 4 branches missed.">			if ( !(((((_la - 192)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 192)) &amp; ((1L &lt;&lt; (FLOAT_LITERAL - 192)) | (1L &lt;&lt; (DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 192)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 192)))) != 0)) ) {</span>
<span class="nc" id="L4733">			_errHandler.recoverInline(this);</span>
			}
			else {
<span class="pc bpc" id="L4736" title="1 of 2 branches missed.">				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L4737">				_errHandler.reportMatch(this);</span>
<span class="fc" id="L4738">				consume();</span>
			}
			}
		}
<span class="nc" id="L4742">		catch (RecognitionException re) {</span>
<span class="nc" id="L4743">			_localctx.exception = re;</span>
<span class="nc" id="L4744">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4745">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4748">			exitRule();</span>
		}
<span class="fc" id="L4750">		return _localctx;</span>
	}

	public static class TextBlockLiteralContext extends ParserRuleContext {
<span class="fc" id="L4754">		public TerminalNode TEXT_BLOCK_LITERAL_BEGIN() { return getToken(JavaLanguageParser.TEXT_BLOCK_LITERAL_BEGIN, 0); }</span>
<span class="fc" id="L4755">		public TerminalNode TEXT_BLOCK_CONTENT() { return getToken(JavaLanguageParser.TEXT_BLOCK_CONTENT, 0); }</span>
<span class="fc" id="L4756">		public TerminalNode TEXT_BLOCK_LITERAL_END() { return getToken(JavaLanguageParser.TEXT_BLOCK_LITERAL_END, 0); }</span>
		public TextBlockLiteralContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4758">			super(parent, invokingState);</span>
<span class="fc" id="L4759">		}</span>
<span class="nc" id="L4760">		@Override public int getRuleIndex() { return RULE_textBlockLiteral; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4763" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTextBlockLiteral(this);</span>
<span class="nc" id="L4764">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TextBlockLiteralContext textBlockLiteral() throws RecognitionException {
<span class="fc" id="L4769">		TextBlockLiteralContext _localctx = new TextBlockLiteralContext(_ctx, getState());</span>
<span class="fc" id="L4770">		enterRule(_localctx, 120, RULE_textBlockLiteral);</span>
		try {
<span class="fc" id="L4772">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4774">			setState(814);</span>
<span class="fc" id="L4775">			match(TEXT_BLOCK_LITERAL_BEGIN);</span>
<span class="fc" id="L4776">			setState(815);</span>
<span class="fc" id="L4777">			match(TEXT_BLOCK_CONTENT);</span>
<span class="fc" id="L4778">			setState(816);</span>
<span class="fc" id="L4779">			match(TEXT_BLOCK_LITERAL_END);</span>
			}
		}
<span class="nc" id="L4782">		catch (RecognitionException re) {</span>
<span class="nc" id="L4783">			_localctx.exception = re;</span>
<span class="nc" id="L4784">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4785">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4788">			exitRule();</span>
		}
<span class="fc" id="L4790">		return _localctx;</span>
	}

	public static class AnnotationsContext extends ParserRuleContext {
		public boolean createImaginaryNode;
		public AnnotationContext annotation;
<span class="pc" id="L4796">		public List&lt;AnnotationContext&gt; anno = new ArrayList&lt;AnnotationContext&gt;();</span>
		public List&lt;AnnotationContext&gt; annotation() {
<span class="nc" id="L4798">			return getRuleContexts(AnnotationContext.class);</span>
		}
		public AnnotationContext annotation(int i) {
<span class="nc" id="L4801">			return getRuleContext(AnnotationContext.class,i);</span>
		}
<span class="nc" id="L4803">		public AnnotationsContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public AnnotationsContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {
<span class="fc" id="L4805">			super(parent, invokingState);</span>
<span class="fc" id="L4806">			this.createImaginaryNode = createImaginaryNode;</span>
<span class="fc" id="L4807">		}</span>
<span class="nc" id="L4808">		@Override public int getRuleIndex() { return RULE_annotations; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4811" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotations(this);</span>
<span class="nc" id="L4812">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationsContext annotations(boolean createImaginaryNode) throws RecognitionException {
<span class="fc" id="L4817">		AnnotationsContext _localctx = new AnnotationsContext(_ctx, getState(), createImaginaryNode);</span>
<span class="fc" id="L4818">		enterRule(_localctx, 122, RULE_annotations);</span>
		try {
			int _alt;
<span class="fc" id="L4821">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4823">			setState(821);</span>
<span class="fc" id="L4824">			_errHandler.sync(this);</span>
<span class="fc" id="L4825">			_alt = getInterpreter().adaptivePredict(_input,83,_ctx);</span>
<span class="pc bpc" id="L4826" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L4827" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L4830">					setState(818);</span>
<span class="fc" id="L4831">					((AnnotationsContext)_localctx).annotation = annotation();</span>
<span class="fc" id="L4832">					((AnnotationsContext)_localctx).anno.add(((AnnotationsContext)_localctx).annotation);</span>
					}
					} 
				}
<span class="fc" id="L4836">				setState(823);</span>
<span class="fc" id="L4837">				_errHandler.sync(this);</span>
<span class="fc" id="L4838">				_alt = getInterpreter().adaptivePredict(_input,83,_ctx);</span>
			}
			}
		}
<span class="nc" id="L4842">		catch (RecognitionException re) {</span>
<span class="nc" id="L4843">			_localctx.exception = re;</span>
<span class="nc" id="L4844">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4845">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4848">			exitRule();</span>
		}
<span class="fc" id="L4850">		return _localctx;</span>
	}

	public static class AnnotationContext extends ParserRuleContext {
<span class="nc" id="L4854">		public TerminalNode AT() { return getToken(JavaLanguageParser.AT, 0); }</span>
		public QualifiedNameContext qualifiedName() {
<span class="nc" id="L4856">			return getRuleContext(QualifiedNameContext.class,0);</span>
		}
<span class="nc" id="L4858">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="nc" id="L4859">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ElementValuePairsContext elementValuePairs() {
<span class="nc" id="L4861">			return getRuleContext(ElementValuePairsContext.class,0);</span>
		}
		public ElementValueContext elementValue() {
<span class="nc" id="L4864">			return getRuleContext(ElementValueContext.class,0);</span>
		}
		public AnnotationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4867">			super(parent, invokingState);</span>
<span class="fc" id="L4868">		}</span>
<span class="nc" id="L4869">		@Override public int getRuleIndex() { return RULE_annotation; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4872" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotation(this);</span>
<span class="nc" id="L4873">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationContext annotation() throws RecognitionException {
<span class="fc" id="L4878">		AnnotationContext _localctx = new AnnotationContext(_ctx, getState());</span>
<span class="fc" id="L4879">		enterRule(_localctx, 124, RULE_annotation);</span>
		int _la;
		try {
<span class="fc" id="L4882">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4884">			setState(824);</span>
<span class="fc" id="L4885">			match(AT);</span>
<span class="fc" id="L4886">			setState(825);</span>
<span class="fc" id="L4887">			qualifiedName();</span>
<span class="fc" id="L4888">			setState(832);</span>
<span class="fc" id="L4889">			_errHandler.sync(this);</span>
<span class="fc" id="L4890">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L4891" title="All 2 branches covered.">			if (_la==LPAREN) {</span>
				{
<span class="fc" id="L4893">				setState(826);</span>
<span class="fc" id="L4894">				match(LPAREN);</span>
<span class="fc" id="L4895">				setState(829);</span>
<span class="fc" id="L4896">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L4897" title="All 3 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,84,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L4900">					setState(827);</span>
<span class="fc" id="L4901">					elementValuePairs();</span>
					}
<span class="fc" id="L4903">					break;</span>
				case 2:
					{
<span class="fc" id="L4906">					setState(828);</span>
<span class="fc" id="L4907">					elementValue();</span>
					}
					break;
				}
<span class="fc" id="L4911">				setState(831);</span>
<span class="fc" id="L4912">				match(RPAREN);</span>
				}
			}

			}
		}
<span class="nc" id="L4918">		catch (RecognitionException re) {</span>
<span class="nc" id="L4919">			_localctx.exception = re;</span>
<span class="nc" id="L4920">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4921">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4924">			exitRule();</span>
		}
<span class="fc" id="L4926">		return _localctx;</span>
	}

	public static class ElementValuePairsContext extends ParserRuleContext {
		public List&lt;ElementValuePairContext&gt; elementValuePair() {
<span class="nc" id="L4931">			return getRuleContexts(ElementValuePairContext.class);</span>
		}
		public ElementValuePairContext elementValuePair(int i) {
<span class="nc" id="L4934">			return getRuleContext(ElementValuePairContext.class,i);</span>
		}
<span class="nc" id="L4936">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L4938">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public ElementValuePairsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4941">			super(parent, invokingState);</span>
<span class="fc" id="L4942">		}</span>
<span class="nc" id="L4943">		@Override public int getRuleIndex() { return RULE_elementValuePairs; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L4946" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitElementValuePairs(this);</span>
<span class="nc" id="L4947">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ElementValuePairsContext elementValuePairs() throws RecognitionException {
<span class="fc" id="L4952">		ElementValuePairsContext _localctx = new ElementValuePairsContext(_ctx, getState());</span>
<span class="fc" id="L4953">		enterRule(_localctx, 126, RULE_elementValuePairs);</span>
		int _la;
		try {
<span class="fc" id="L4956">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L4958">			setState(834);</span>
<span class="fc" id="L4959">			elementValuePair();</span>
<span class="fc" id="L4960">			setState(839);</span>
<span class="fc" id="L4961">			_errHandler.sync(this);</span>
<span class="fc" id="L4962">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L4963" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L4966">				setState(835);</span>
<span class="fc" id="L4967">				match(COMMA);</span>
<span class="fc" id="L4968">				setState(836);</span>
<span class="fc" id="L4969">				elementValuePair();</span>
				}
				}
<span class="fc" id="L4972">				setState(841);</span>
<span class="fc" id="L4973">				_errHandler.sync(this);</span>
<span class="fc" id="L4974">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L4978">		catch (RecognitionException re) {</span>
<span class="nc" id="L4979">			_localctx.exception = re;</span>
<span class="nc" id="L4980">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L4981">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L4984">			exitRule();</span>
		}
<span class="fc" id="L4986">		return _localctx;</span>
	}

	public static class ElementValuePairContext extends ParserRuleContext {
		public IdContext id() {
<span class="nc" id="L4991">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="nc" id="L4993">		public TerminalNode ASSIGN() { return getToken(JavaLanguageParser.ASSIGN, 0); }</span>
		public ElementValueContext elementValue() {
<span class="nc" id="L4995">			return getRuleContext(ElementValueContext.class,0);</span>
		}
		public ElementValuePairContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L4998">			super(parent, invokingState);</span>
<span class="fc" id="L4999">		}</span>
<span class="nc" id="L5000">		@Override public int getRuleIndex() { return RULE_elementValuePair; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5003" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitElementValuePair(this);</span>
<span class="nc" id="L5004">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ElementValuePairContext elementValuePair() throws RecognitionException {
<span class="fc" id="L5009">		ElementValuePairContext _localctx = new ElementValuePairContext(_ctx, getState());</span>
<span class="fc" id="L5010">		enterRule(_localctx, 128, RULE_elementValuePair);</span>
		try {
<span class="fc" id="L5012">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5014">			setState(842);</span>
<span class="fc" id="L5015">			id();</span>
<span class="fc" id="L5016">			setState(843);</span>
<span class="fc" id="L5017">			match(ASSIGN);</span>
<span class="fc" id="L5018">			setState(844);</span>
<span class="fc" id="L5019">			elementValue();</span>
			}
		}
<span class="nc" id="L5022">		catch (RecognitionException re) {</span>
<span class="nc" id="L5023">			_localctx.exception = re;</span>
<span class="nc" id="L5024">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5025">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5028">			exitRule();</span>
		}
<span class="fc" id="L5030">		return _localctx;</span>
	}

	public static class ElementValueContext extends ParserRuleContext {
		public ExpressionContext expression() {
<span class="nc" id="L5035">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public AnnotationContext annotation() {
<span class="nc" id="L5038">			return getRuleContext(AnnotationContext.class,0);</span>
		}
		public ElementValueArrayInitializerContext elementValueArrayInitializer() {
<span class="nc" id="L5041">			return getRuleContext(ElementValueArrayInitializerContext.class,0);</span>
		}
		public ElementValueContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5044">			super(parent, invokingState);</span>
<span class="fc" id="L5045">		}</span>
<span class="nc" id="L5046">		@Override public int getRuleIndex() { return RULE_elementValue; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5049" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitElementValue(this);</span>
<span class="nc" id="L5050">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ElementValueContext elementValue() throws RecognitionException {
<span class="fc" id="L5055">		ElementValueContext _localctx = new ElementValueContext(_ctx, getState());</span>
<span class="fc" id="L5056">		enterRule(_localctx, 130, RULE_elementValue);</span>
		try {
<span class="fc" id="L5058">			setState(849);</span>
<span class="fc" id="L5059">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L5060" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,87,_ctx) ) {</span>
			case 1:
<span class="fc" id="L5062">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L5064">				setState(846);</span>
<span class="fc" id="L5065">				expression();</span>
				}
<span class="fc" id="L5067">				break;</span>
			case 2:
<span class="fc" id="L5069">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L5071">				setState(847);</span>
<span class="fc" id="L5072">				annotation();</span>
				}
<span class="fc" id="L5074">				break;</span>
			case 3:
<span class="fc" id="L5076">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L5078">				setState(848);</span>
<span class="fc" id="L5079">				elementValueArrayInitializer();</span>
				}
				break;
			}
		}
<span class="nc" id="L5084">		catch (RecognitionException re) {</span>
<span class="nc" id="L5085">			_localctx.exception = re;</span>
<span class="nc" id="L5086">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5087">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5090">			exitRule();</span>
		}
<span class="fc" id="L5092">		return _localctx;</span>
	}

	public static class ElementValueArrayInitializerContext extends ParserRuleContext {
<span class="fc" id="L5096">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L5097">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;ElementValueContext&gt; elementValue() {
<span class="nc" id="L5099">			return getRuleContexts(ElementValueContext.class);</span>
		}
		public ElementValueContext elementValue(int i) {
<span class="nc" id="L5102">			return getRuleContext(ElementValueContext.class,i);</span>
		}
<span class="nc" id="L5104">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L5106">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public ElementValueArrayInitializerContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5109">			super(parent, invokingState);</span>
<span class="fc" id="L5110">		}</span>
<span class="nc" id="L5111">		@Override public int getRuleIndex() { return RULE_elementValueArrayInitializer; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5114" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitElementValueArrayInitializer(this);</span>
<span class="nc" id="L5115">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ElementValueArrayInitializerContext elementValueArrayInitializer() throws RecognitionException {
<span class="fc" id="L5120">		ElementValueArrayInitializerContext _localctx = new ElementValueArrayInitializerContext(_ctx, getState());</span>
<span class="fc" id="L5121">		enterRule(_localctx, 132, RULE_elementValueArrayInitializer);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L5125">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5127">			setState(851);</span>
<span class="fc" id="L5128">			match(LCURLY);</span>
<span class="fc" id="L5129">			setState(860);</span>
<span class="fc" id="L5130">			_errHandler.sync(this);</span>
<span class="fc" id="L5131">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L5132" title="2 of 12 branches missed.">			if (((((_la - 49)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 49)) &amp; ((1L &lt;&lt; (LITERAL_VOID - 49)) | (1L &lt;&lt; (LITERAL_BOOLEAN - 49)) | (1L &lt;&lt; (LITERAL_BYTE - 49)) | (1L &lt;&lt; (LITERAL_CHAR - 49)) | (1L &lt;&lt; (LITERAL_SHORT - 49)) | (1L &lt;&lt; (LITERAL_INT - 49)) | (1L &lt;&lt; (LITERAL_FLOAT - 49)) | (1L &lt;&lt; (LITERAL_LONG - 49)) | (1L &lt;&lt; (LITERAL_DOUBLE - 49)) | (1L &lt;&lt; (IDENT - 49)) | (1L &lt;&lt; (LCURLY - 49)) | (1L &lt;&lt; (LPAREN - 49)) | (1L &lt;&lt; (LITERAL_THIS - 49)) | (1L &lt;&lt; (LITERAL_SUPER - 49)) | (1L &lt;&lt; (LITERAL_SWITCH - 49)))) != 0) || ((((_la - 125)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 125)) &amp; ((1L &lt;&lt; (PLUS - 125)) | (1L &lt;&lt; (MINUS - 125)) | (1L &lt;&lt; (INC - 125)) | (1L &lt;&lt; (DEC - 125)) | (1L &lt;&lt; (BNOT - 125)) | (1L &lt;&lt; (LNOT - 125)) | (1L &lt;&lt; (LITERAL_TRUE - 125)) | (1L &lt;&lt; (LITERAL_FALSE - 125)) | (1L &lt;&lt; (LITERAL_NULL - 125)) | (1L &lt;&lt; (LITERAL_NEW - 125)) | (1L &lt;&lt; (CHAR_LITERAL - 125)) | (1L &lt;&lt; (STRING_LITERAL - 125)) | (1L &lt;&lt; (AT - 125)))) != 0) || ((((_la - 192)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 192)) &amp; ((1L &lt;&lt; (FLOAT_LITERAL - 192)) | (1L &lt;&lt; (DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 192)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (LITERAL_RECORD - 192)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 192)) | (1L &lt;&lt; (LITERAL_YIELD - 192)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 192)) | (1L &lt;&lt; (LITERAL_SEALED - 192)) | (1L &lt;&lt; (LITERAL_PERMITS - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL - 192)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 192)) | (1L &lt;&lt; (HEX_LITERAL - 192)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 192)) | (1L &lt;&lt; (OCT_LITERAL - 192)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 192)) | (1L &lt;&lt; (BINARY_LITERAL - 192)))) != 0)) {</span>
				{
<span class="fc" id="L5134">				setState(852);</span>
<span class="fc" id="L5135">				elementValue();</span>
<span class="fc" id="L5136">				setState(857);</span>
<span class="fc" id="L5137">				_errHandler.sync(this);</span>
<span class="fc" id="L5138">				_alt = getInterpreter().adaptivePredict(_input,88,_ctx);</span>
<span class="pc bpc" id="L5139" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L5140" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L5143">						setState(853);</span>
<span class="fc" id="L5144">						match(COMMA);</span>
<span class="fc" id="L5145">						setState(854);</span>
<span class="fc" id="L5146">						elementValue();</span>
						}
						} 
					}
<span class="fc" id="L5150">					setState(859);</span>
<span class="fc" id="L5151">					_errHandler.sync(this);</span>
<span class="fc" id="L5152">					_alt = getInterpreter().adaptivePredict(_input,88,_ctx);</span>
				}
				}
			}

<span class="fc" id="L5157">			setState(863);</span>
<span class="fc" id="L5158">			_errHandler.sync(this);</span>
<span class="fc" id="L5159">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L5160" title="All 2 branches covered.">			if (_la==COMMA) {</span>
				{
<span class="fc" id="L5162">				setState(862);</span>
<span class="fc" id="L5163">				match(COMMA);</span>
				}
			}

<span class="fc" id="L5167">			setState(865);</span>
<span class="fc" id="L5168">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L5171">		catch (RecognitionException re) {</span>
<span class="nc" id="L5172">			_localctx.exception = re;</span>
<span class="nc" id="L5173">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5174">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5177">			exitRule();</span>
		}
<span class="fc" id="L5179">		return _localctx;</span>
	}

	public static class AnnotationTypeDeclarationContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L5184">		public TerminalNode AT() { return getToken(JavaLanguageParser.AT, 0); }</span>
<span class="nc" id="L5185">		public TerminalNode LITERAL_INTERFACE() { return getToken(JavaLanguageParser.LITERAL_INTERFACE, 0); }</span>
		public IdContext id() {
<span class="nc" id="L5187">			return getRuleContext(IdContext.class,0);</span>
		}
		public AnnotationTypeBodyContext annotationTypeBody() {
<span class="nc" id="L5190">			return getRuleContext(AnnotationTypeBodyContext.class,0);</span>
		}
<span class="nc" id="L5192">		public AnnotationTypeDeclarationContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public AnnotationTypeDeclarationContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L5194">			super(parent, invokingState);</span>
<span class="fc" id="L5195">			this.mods = mods;</span>
<span class="fc" id="L5196">		}</span>
<span class="nc" id="L5197">		@Override public int getRuleIndex() { return RULE_annotationTypeDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5200" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationTypeDeclaration(this);</span>
<span class="nc" id="L5201">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationTypeDeclarationContext annotationTypeDeclaration(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L5206">		AnnotationTypeDeclarationContext _localctx = new AnnotationTypeDeclarationContext(_ctx, getState(), mods);</span>
<span class="fc" id="L5207">		enterRule(_localctx, 134, RULE_annotationTypeDeclaration);</span>
		try {
<span class="fc" id="L5209">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5211">			setState(867);</span>
<span class="fc" id="L5212">			match(AT);</span>
<span class="fc" id="L5213">			setState(868);</span>
<span class="fc" id="L5214">			match(LITERAL_INTERFACE);</span>
<span class="fc" id="L5215">			setState(869);</span>
<span class="fc" id="L5216">			id();</span>
<span class="fc" id="L5217">			setState(870);</span>
<span class="fc" id="L5218">			annotationTypeBody();</span>
			}
		}
<span class="nc" id="L5221">		catch (RecognitionException re) {</span>
<span class="nc" id="L5222">			_localctx.exception = re;</span>
<span class="nc" id="L5223">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5224">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5227">			exitRule();</span>
		}
<span class="fc" id="L5229">		return _localctx;</span>
	}

	public static class AnnotationTypeBodyContext extends ParserRuleContext {
<span class="nc" id="L5233">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L5234">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;AnnotationTypeElementDeclarationContext&gt; annotationTypeElementDeclaration() {
<span class="nc" id="L5236">			return getRuleContexts(AnnotationTypeElementDeclarationContext.class);</span>
		}
		public AnnotationTypeElementDeclarationContext annotationTypeElementDeclaration(int i) {
<span class="nc" id="L5239">			return getRuleContext(AnnotationTypeElementDeclarationContext.class,i);</span>
		}
		public AnnotationTypeBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5242">			super(parent, invokingState);</span>
<span class="fc" id="L5243">		}</span>
<span class="nc" id="L5244">		@Override public int getRuleIndex() { return RULE_annotationTypeBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5247" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationTypeBody(this);</span>
<span class="nc" id="L5248">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationTypeBodyContext annotationTypeBody() throws RecognitionException {
<span class="fc" id="L5253">		AnnotationTypeBodyContext _localctx = new AnnotationTypeBodyContext(_ctx, getState());</span>
<span class="fc" id="L5254">		enterRule(_localctx, 136, RULE_annotationTypeBody);</span>
		int _la;
		try {
<span class="fc" id="L5257">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5259">			setState(872);</span>
<span class="fc" id="L5260">			match(LCURLY);</span>
<span class="fc" id="L5261">			setState(876);</span>
<span class="fc" id="L5262">			_errHandler.sync(this);</span>
<span class="fc" id="L5263">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L5264" title="1 of 8 branches missed.">			while (((((_la - 39)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 39)) &amp; ((1L &lt;&lt; (FINAL - 39)) | (1L &lt;&lt; (ABSTRACT - 39)) | (1L &lt;&lt; (STRICTFP - 39)) | (1L &lt;&lt; (SEMI - 39)) | (1L &lt;&lt; (LITERAL_VOID - 39)) | (1L &lt;&lt; (LITERAL_BOOLEAN - 39)) | (1L &lt;&lt; (LITERAL_BYTE - 39)) | (1L &lt;&lt; (LITERAL_CHAR - 39)) | (1L &lt;&lt; (LITERAL_SHORT - 39)) | (1L &lt;&lt; (LITERAL_INT - 39)) | (1L &lt;&lt; (LITERAL_FLOAT - 39)) | (1L &lt;&lt; (LITERAL_LONG - 39)) | (1L &lt;&lt; (LITERAL_DOUBLE - 39)) | (1L &lt;&lt; (IDENT - 39)) | (1L &lt;&lt; (LITERAL_PRIVATE - 39)) | (1L &lt;&lt; (LITERAL_PUBLIC - 39)) | (1L &lt;&lt; (LITERAL_PROTECTED - 39)) | (1L &lt;&lt; (LITERAL_STATIC - 39)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 39)) | (1L &lt;&lt; (LITERAL_NATIVE - 39)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 39)) | (1L &lt;&lt; (LITERAL_VOLATILE - 39)) | (1L &lt;&lt; (LITERAL_CLASS - 39)) | (1L &lt;&lt; (LITERAL_INTERFACE - 39)) | (1L &lt;&lt; (LITERAL_DEFAULT - 39)))) != 0) || ((((_la - 153)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 153)) &amp; ((1L &lt;&lt; (ENUM - 153)) | (1L &lt;&lt; (AT - 153)) | (1L &lt;&lt; (LITERAL_RECORD - 153)) | (1L &lt;&lt; (LITERAL_YIELD - 153)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 153)) | (1L &lt;&lt; (LITERAL_SEALED - 153)) | (1L &lt;&lt; (LITERAL_PERMITS - 153)))) != 0)) {</span>
				{
				{
<span class="fc" id="L5267">				setState(873);</span>
<span class="fc" id="L5268">				annotationTypeElementDeclaration();</span>
				}
				}
<span class="fc" id="L5271">				setState(878);</span>
<span class="fc" id="L5272">				_errHandler.sync(this);</span>
<span class="fc" id="L5273">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L5275">			setState(879);</span>
<span class="fc" id="L5276">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L5279">		catch (RecognitionException re) {</span>
<span class="nc" id="L5280">			_localctx.exception = re;</span>
<span class="nc" id="L5281">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5282">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5285">			exitRule();</span>
		}
<span class="fc" id="L5287">		return _localctx;</span>
	}

	public static class AnnotationTypeElementDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L5292">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public AnnotationTypeElementRestContext annotationTypeElementRest() {
<span class="fc" id="L5294">			return getRuleContext(AnnotationTypeElementRestContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L5297">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L5300">			return getRuleContext(ModifierContext.class,i);</span>
		}
<span class="fc" id="L5302">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public AnnotationTypeElementDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5304">			super(parent, invokingState);</span>
<span class="fc" id="L5305">		}</span>
<span class="nc" id="L5306">		@Override public int getRuleIndex() { return RULE_annotationTypeElementDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5309" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationTypeElementDeclaration(this);</span>
<span class="nc" id="L5310">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationTypeElementDeclarationContext annotationTypeElementDeclaration() throws RecognitionException {
<span class="fc" id="L5315">		AnnotationTypeElementDeclarationContext _localctx = new AnnotationTypeElementDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L5316">		enterRule(_localctx, 138, RULE_annotationTypeElementDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L5319">			setState(889);</span>
<span class="fc" id="L5320">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L5321" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
			case ABSTRACT:
			case STRICTFP:
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LITERAL_PRIVATE:
			case LITERAL_PUBLIC:
			case LITERAL_PROTECTED:
			case LITERAL_STATIC:
			case LITERAL_TRANSIENT:
			case LITERAL_NATIVE:
			case LITERAL_SYNCHRONIZED:
			case LITERAL_VOLATILE:
			case LITERAL_CLASS:
			case LITERAL_INTERFACE:
			case LITERAL_DEFAULT:
			case ENUM:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
<span class="fc" id="L5353">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L5355">				setState(884);</span>
<span class="fc" id="L5356">				_errHandler.sync(this);</span>
<span class="fc" id="L5357">				_alt = getInterpreter().adaptivePredict(_input,92,_ctx);</span>
<span class="pc bpc" id="L5358" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L5359" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L5362">						setState(881);</span>
<span class="fc" id="L5363">						((AnnotationTypeElementDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L5364">						((AnnotationTypeElementDeclarationContext)_localctx).mods.add(((AnnotationTypeElementDeclarationContext)_localctx).modifier);</span>
						}
						} 
					}
<span class="fc" id="L5368">					setState(886);</span>
<span class="fc" id="L5369">					_errHandler.sync(this);</span>
<span class="fc" id="L5370">					_alt = getInterpreter().adaptivePredict(_input,92,_ctx);</span>
				}
<span class="fc" id="L5372">				setState(887);</span>
<span class="fc" id="L5373">				annotationTypeElementRest(_localctx.mods);</span>
				}
<span class="fc" id="L5375">				break;</span>
			case SEMI:
<span class="fc" id="L5377">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L5379">				setState(888);</span>
<span class="fc" id="L5380">				match(SEMI);</span>
				}
<span class="fc" id="L5382">				break;</span>
			default:
<span class="nc" id="L5384">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L5387">		catch (RecognitionException re) {</span>
<span class="nc" id="L5388">			_localctx.exception = re;</span>
<span class="nc" id="L5389">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5390">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5393">			exitRule();</span>
		}
<span class="fc" id="L5395">		return _localctx;</span>
	}

	public static class AnnotationTypeElementRestContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
<span class="nc" id="L5400">		public AnnotationTypeElementRestContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public AnnotationTypeElementRestContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods) {
<span class="fc" id="L5402">			super(parent, invokingState);</span>
<span class="fc" id="L5403">			this.mods = mods;</span>
<span class="fc" id="L5404">		}</span>
<span class="nc" id="L5405">		@Override public int getRuleIndex() { return RULE_annotationTypeElementRest; }</span>
	 
<span class="fc" id="L5407">		public AnnotationTypeElementRestContext() { }</span>
		public void copyFrom(AnnotationTypeElementRestContext ctx) {
<span class="fc" id="L5409">			super.copyFrom(ctx);</span>
<span class="fc" id="L5410">			this.mods = ctx.mods;</span>
<span class="fc" id="L5411">		}</span>
	}
	public static class AnnotationFieldContext extends AnnotationTypeElementRestContext {
		public TypeTypeContext type;
<span class="fc" id="L5415">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public TypeTypeContext typeType() {
<span class="nc" id="L5417">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public AnnotationMethodRestContext annotationMethodRest() {
<span class="nc" id="L5420">			return getRuleContext(AnnotationMethodRestContext.class,0);</span>
		}
		public AnnotationConstantRestContext annotationConstantRest() {
<span class="nc" id="L5423">			return getRuleContext(AnnotationConstantRestContext.class,0);</span>
		}
<span class="fc" id="L5425">		public AnnotationFieldContext(AnnotationTypeElementRestContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5428" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationField(this);</span>
<span class="nc" id="L5429">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class AnnotationTypeContext extends AnnotationTypeElementRestContext {
		public TypeTypeContext type;
<span class="nc" id="L5434">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public TypeTypeContext typeType() {
<span class="nc" id="L5436">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public ClassDeclarationContext classDeclaration() {
<span class="nc" id="L5439">			return getRuleContext(ClassDeclarationContext.class,0);</span>
		}
		public RecordDeclarationContext recordDeclaration() {
<span class="nc" id="L5442">			return getRuleContext(RecordDeclarationContext.class,0);</span>
		}
		public InterfaceDeclarationContext interfaceDeclaration() {
<span class="nc" id="L5445">			return getRuleContext(InterfaceDeclarationContext.class,0);</span>
		}
		public EnumDeclarationContext enumDeclaration() {
<span class="nc" id="L5448">			return getRuleContext(EnumDeclarationContext.class,0);</span>
		}
		public AnnotationTypeDeclarationContext annotationTypeDeclaration() {
<span class="nc" id="L5451">			return getRuleContext(AnnotationTypeDeclarationContext.class,0);</span>
		}
<span class="fc" id="L5453">		public AnnotationTypeContext(AnnotationTypeElementRestContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5456" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationType(this);</span>
<span class="nc" id="L5457">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationTypeElementRestContext annotationTypeElementRest(List&lt;ModifierContext&gt; mods) throws RecognitionException {
<span class="fc" id="L5462">		AnnotationTypeElementRestContext _localctx = new AnnotationTypeElementRestContext(_ctx, getState(), mods);</span>
<span class="fc" id="L5463">		enterRule(_localctx, 140, RULE_annotationTypeElementRest);</span>
		try {
<span class="fc" id="L5465">			setState(921);</span>
<span class="fc" id="L5466">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L5467" title="2 of 8 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,100,_ctx) ) {</span>
			case 1:
<span class="fc" id="L5469">				_localctx = new AnnotationFieldContext(_localctx);</span>
<span class="fc" id="L5470">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L5472">				setState(891);</span>
<span class="fc" id="L5473">				((AnnotationFieldContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L5474">				setState(894);</span>
<span class="fc" id="L5475">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5476" title="1 of 3 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,94,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L5479">					setState(892);</span>
<span class="fc" id="L5480">					annotationMethodRest(mods, ((AnnotationFieldContext) _localctx).type);</span>
					}
<span class="fc" id="L5482">					break;</span>
				case 2:
					{
<span class="fc" id="L5485">					setState(893);</span>
<span class="fc" id="L5486">					annotationConstantRest(mods, ((AnnotationFieldContext) _localctx).type);</span>
					}
					break;
				}
<span class="fc" id="L5490">				setState(896);</span>
<span class="fc" id="L5491">				match(SEMI);</span>
				}
<span class="fc" id="L5493">				break;</span>
			case 2:
<span class="nc" id="L5495">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="nc" id="L5496">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="nc" id="L5498">				setState(898);</span>
<span class="nc" id="L5499">				((AnnotationTypeContext)_localctx).type = typeType(true);</span>
<span class="nc" id="L5500">				setState(899);</span>
<span class="nc" id="L5501">				match(SEMI);</span>
				}
<span class="nc" id="L5503">				break;</span>
			case 3:
<span class="fc" id="L5505">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="fc" id="L5506">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L5508">				setState(901);</span>
<span class="fc" id="L5509">				classDeclaration(mods);</span>
<span class="fc" id="L5510">				setState(903);</span>
<span class="fc" id="L5511">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5512" title="1 of 2 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,95,_ctx) ) {</span>
				case 1:
					{
<span class="nc" id="L5515">					setState(902);</span>
<span class="nc" id="L5516">					match(SEMI);</span>
					}
					break;
				}
				}
<span class="fc" id="L5521">				break;</span>
			case 4:
<span class="fc" id="L5523">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="fc" id="L5524">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L5526">				setState(905);</span>
<span class="fc" id="L5527">				recordDeclaration(mods);</span>
<span class="fc" id="L5528">				setState(907);</span>
<span class="fc" id="L5529">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5530" title="1 of 2 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,96,_ctx) ) {</span>
				case 1:
					{
<span class="nc" id="L5533">					setState(906);</span>
<span class="nc" id="L5534">					match(SEMI);</span>
					}
					break;
				}
				}
<span class="fc" id="L5539">				break;</span>
			case 5:
<span class="fc" id="L5541">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="fc" id="L5542">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L5544">				setState(909);</span>
<span class="fc" id="L5545">				interfaceDeclaration(mods);</span>
<span class="fc" id="L5546">				setState(911);</span>
<span class="fc" id="L5547">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5548" title="1 of 2 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,97,_ctx) ) {</span>
				case 1:
					{
<span class="nc" id="L5551">					setState(910);</span>
<span class="nc" id="L5552">					match(SEMI);</span>
					}
					break;
				}
				}
<span class="fc" id="L5557">				break;</span>
			case 6:
<span class="fc" id="L5559">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="fc" id="L5560">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L5562">				setState(913);</span>
<span class="fc" id="L5563">				enumDeclaration(mods);</span>
<span class="fc" id="L5564">				setState(915);</span>
<span class="fc" id="L5565">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5566" title="1 of 2 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,98,_ctx) ) {</span>
				case 1:
					{
<span class="nc" id="L5569">					setState(914);</span>
<span class="nc" id="L5570">					match(SEMI);</span>
					}
					break;
				}
				}
<span class="fc" id="L5575">				break;</span>
			case 7:
<span class="fc" id="L5577">				_localctx = new AnnotationTypeContext(_localctx);</span>
<span class="fc" id="L5578">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L5580">				setState(917);</span>
<span class="fc" id="L5581">				annotationTypeDeclaration(mods);</span>
<span class="fc" id="L5582">				setState(919);</span>
<span class="fc" id="L5583">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L5584" title="1 of 2 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,99,_ctx) ) {</span>
				case 1:
					{
<span class="nc" id="L5587">					setState(918);</span>
<span class="nc" id="L5588">					match(SEMI);</span>
					}
					break;
				}
				}
				break;
			}
		}
<span class="nc" id="L5596">		catch (RecognitionException re) {</span>
<span class="nc" id="L5597">			_localctx.exception = re;</span>
<span class="nc" id="L5598">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5599">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5602">			exitRule();</span>
		}
<span class="fc" id="L5604">		return _localctx;</span>
	}

	public static class AnnotationMethodRestContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public ArrayDeclaratorContext arrayDeclarator;
<span class="pc" id="L5611">		public List&lt;ArrayDeclaratorContext&gt; cStyleArrDec = new ArrayList&lt;ArrayDeclaratorContext&gt;();</span>
		public IdContext id() {
<span class="nc" id="L5613">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="nc" id="L5615">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="nc" id="L5616">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public DefaultValueContext defaultValue() {
<span class="nc" id="L5618">			return getRuleContext(DefaultValueContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L5621">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L5624">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="nc" id="L5626">		public AnnotationMethodRestContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public AnnotationMethodRestContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods, TypeTypeContext type) {
<span class="fc" id="L5628">			super(parent, invokingState);</span>
<span class="fc" id="L5629">			this.mods = mods;</span>
<span class="fc" id="L5630">			this.type = type;</span>
<span class="fc" id="L5631">		}</span>
<span class="nc" id="L5632">		@Override public int getRuleIndex() { return RULE_annotationMethodRest; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5635" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationMethodRest(this);</span>
<span class="nc" id="L5636">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationMethodRestContext annotationMethodRest(List&lt;ModifierContext&gt; mods,TypeTypeContext type) throws RecognitionException {
<span class="fc" id="L5641">		AnnotationMethodRestContext _localctx = new AnnotationMethodRestContext(_ctx, getState(), mods, type);</span>
<span class="fc" id="L5642">		enterRule(_localctx, 142, RULE_annotationMethodRest);</span>
		int _la;
		try {
<span class="fc" id="L5645">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5647">			setState(923);</span>
<span class="fc" id="L5648">			id();</span>
<span class="fc" id="L5649">			setState(924);</span>
<span class="fc" id="L5650">			match(LPAREN);</span>
<span class="fc" id="L5651">			setState(925);</span>
<span class="fc" id="L5652">			match(RPAREN);</span>
<span class="fc" id="L5653">			setState(929);</span>
<span class="fc" id="L5654">			_errHandler.sync(this);</span>
<span class="fc" id="L5655">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L5656" title="1 of 4 branches missed.">			while (_la==LBRACK || _la==AT) {</span>
				{
				{
<span class="fc" id="L5659">				setState(926);</span>
<span class="fc" id="L5660">				((AnnotationMethodRestContext)_localctx).arrayDeclarator = arrayDeclarator();</span>
<span class="fc" id="L5661">				((AnnotationMethodRestContext)_localctx).cStyleArrDec.add(((AnnotationMethodRestContext)_localctx).arrayDeclarator);</span>
				}
				}
<span class="fc" id="L5664">				setState(931);</span>
<span class="fc" id="L5665">				_errHandler.sync(this);</span>
<span class="fc" id="L5666">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L5668">			setState(933);</span>
<span class="fc" id="L5669">			_errHandler.sync(this);</span>
<span class="fc" id="L5670">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L5671" title="All 2 branches covered.">			if (_la==LITERAL_DEFAULT) {</span>
				{
<span class="fc" id="L5673">				setState(932);</span>
<span class="fc" id="L5674">				defaultValue();</span>
				}
			}

			}
		}
<span class="nc" id="L5680">		catch (RecognitionException re) {</span>
<span class="nc" id="L5681">			_localctx.exception = re;</span>
<span class="nc" id="L5682">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5683">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5686">			exitRule();</span>
		}
<span class="fc" id="L5688">		return _localctx;</span>
	}

	public static class AnnotationConstantRestContext extends ParserRuleContext {
		public List&lt;ModifierContext&gt; mods;
		public TypeTypeContext type;
		public VariableDeclaratorsContext variableDeclarators() {
<span class="nc" id="L5695">			return getRuleContext(VariableDeclaratorsContext.class,0);</span>
		}
<span class="nc" id="L5697">		public AnnotationConstantRestContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public AnnotationConstantRestContext(ParserRuleContext parent, int invokingState, List&lt;ModifierContext&gt; mods, TypeTypeContext type) {
<span class="fc" id="L5699">			super(parent, invokingState);</span>
<span class="fc" id="L5700">			this.mods = mods;</span>
<span class="fc" id="L5701">			this.type = type;</span>
<span class="fc" id="L5702">		}</span>
<span class="nc" id="L5703">		@Override public int getRuleIndex() { return RULE_annotationConstantRest; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5706" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAnnotationConstantRest(this);</span>
<span class="nc" id="L5707">			else return visitor.visitChildren(this);</span>
		}
	}

	public final AnnotationConstantRestContext annotationConstantRest(List&lt;ModifierContext&gt; mods,TypeTypeContext type) throws RecognitionException {
<span class="fc" id="L5712">		AnnotationConstantRestContext _localctx = new AnnotationConstantRestContext(_ctx, getState(), mods, type);</span>
<span class="fc" id="L5713">		enterRule(_localctx, 144, RULE_annotationConstantRest);</span>
		try {
<span class="fc" id="L5715">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5717">			setState(935);</span>
<span class="fc" id="L5718">			variableDeclarators(mods, type);</span>
			}
		}
<span class="nc" id="L5721">		catch (RecognitionException re) {</span>
<span class="nc" id="L5722">			_localctx.exception = re;</span>
<span class="nc" id="L5723">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5724">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5727">			exitRule();</span>
		}
<span class="fc" id="L5729">		return _localctx;</span>
	}

	public static class DefaultValueContext extends ParserRuleContext {
<span class="fc" id="L5733">		public TerminalNode LITERAL_DEFAULT() { return getToken(JavaLanguageParser.LITERAL_DEFAULT, 0); }</span>
		public ElementValueContext elementValue() {
<span class="fc" id="L5735">			return getRuleContext(ElementValueContext.class,0);</span>
		}
		public DefaultValueContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5738">			super(parent, invokingState);</span>
<span class="fc" id="L5739">		}</span>
<span class="nc" id="L5740">		@Override public int getRuleIndex() { return RULE_defaultValue; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5743" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitDefaultValue(this);</span>
<span class="nc" id="L5744">			else return visitor.visitChildren(this);</span>
		}
	}

	public final DefaultValueContext defaultValue() throws RecognitionException {
<span class="fc" id="L5749">		DefaultValueContext _localctx = new DefaultValueContext(_ctx, getState());</span>
<span class="fc" id="L5750">		enterRule(_localctx, 146, RULE_defaultValue);</span>
		try {
<span class="fc" id="L5752">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5754">			setState(937);</span>
<span class="fc" id="L5755">			match(LITERAL_DEFAULT);</span>
<span class="fc" id="L5756">			setState(938);</span>
<span class="fc" id="L5757">			elementValue();</span>
			}
		}
<span class="nc" id="L5760">		catch (RecognitionException re) {</span>
<span class="nc" id="L5761">			_localctx.exception = re;</span>
<span class="nc" id="L5762">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5763">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5766">			exitRule();</span>
		}
<span class="fc" id="L5768">		return _localctx;</span>
	}

	public static class ConstructorBlockContext extends ParserRuleContext {
<span class="nc" id="L5772">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L5773">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public ExplicitConstructorInvocationContext explicitConstructorInvocation() {
<span class="nc" id="L5775">			return getRuleContext(ExplicitConstructorInvocationContext.class,0);</span>
		}
		public List&lt;BlockStatementContext&gt; blockStatement() {
<span class="nc" id="L5778">			return getRuleContexts(BlockStatementContext.class);</span>
		}
		public BlockStatementContext blockStatement(int i) {
<span class="nc" id="L5781">			return getRuleContext(BlockStatementContext.class,i);</span>
		}
		public ConstructorBlockContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5784">			super(parent, invokingState);</span>
<span class="fc" id="L5785">		}</span>
<span class="nc" id="L5786">		@Override public int getRuleIndex() { return RULE_constructorBlock; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5789" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitConstructorBlock(this);</span>
<span class="nc" id="L5790">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ConstructorBlockContext constructorBlock() throws RecognitionException {
<span class="fc" id="L5795">		ConstructorBlockContext _localctx = new ConstructorBlockContext(_ctx, getState());</span>
<span class="fc" id="L5796">		enterRule(_localctx, 148, RULE_constructorBlock);</span>
		try {
			int _alt;
<span class="fc" id="L5799">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5801">			setState(940);</span>
<span class="fc" id="L5802">			match(LCURLY);</span>
<span class="fc" id="L5803">			setState(942);</span>
<span class="fc" id="L5804">			_errHandler.sync(this);</span>
<span class="fc bfc" id="L5805" title="All 2 branches covered.">			switch ( getInterpreter().adaptivePredict(_input,103,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L5808">				setState(941);</span>
<span class="fc" id="L5809">				explicitConstructorInvocation();</span>
				}
				break;
			}
<span class="fc" id="L5813">			setState(947);</span>
<span class="fc" id="L5814">			_errHandler.sync(this);</span>
<span class="fc" id="L5815">			_alt = getInterpreter().adaptivePredict(_input,104,_ctx);</span>
<span class="pc bpc" id="L5816" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L5817" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L5820">					setState(944);</span>
<span class="fc" id="L5821">					blockStatement();</span>
					}
					} 
				}
<span class="fc" id="L5825">				setState(949);</span>
<span class="fc" id="L5826">				_errHandler.sync(this);</span>
<span class="fc" id="L5827">				_alt = getInterpreter().adaptivePredict(_input,104,_ctx);</span>
			}
<span class="fc" id="L5829">			setState(950);</span>
<span class="fc" id="L5830">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L5833">		catch (RecognitionException re) {</span>
<span class="nc" id="L5834">			_localctx.exception = re;</span>
<span class="nc" id="L5835">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5836">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5839">			exitRule();</span>
		}
<span class="fc" id="L5841">		return _localctx;</span>
	}

	public static class ExplicitConstructorInvocationContext extends ParserRuleContext {
		public ExplicitConstructorInvocationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5846">			super(parent, invokingState);</span>
<span class="fc" id="L5847">		}</span>
<span class="nc" id="L5848">		@Override public int getRuleIndex() { return RULE_explicitConstructorInvocation; }</span>
	 
<span class="fc" id="L5850">		public ExplicitConstructorInvocationContext() { }</span>
		public void copyFrom(ExplicitConstructorInvocationContext ctx) {
<span class="fc" id="L5852">			super.copyFrom(ctx);</span>
<span class="fc" id="L5853">		}</span>
	}
	public static class ExplicitCtorCallContext extends ExplicitConstructorInvocationContext {
		public ArgumentsContext arguments() {
<span class="fc" id="L5857">			return getRuleContext(ArgumentsContext.class,0);</span>
		}
<span class="fc" id="L5859">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L5860">		public TerminalNode LITERAL_THIS() { return getToken(JavaLanguageParser.LITERAL_THIS, 0); }</span>
<span class="fc" id="L5861">		public TerminalNode LITERAL_SUPER() { return getToken(JavaLanguageParser.LITERAL_SUPER, 0); }</span>
		public TypeArgumentsContext typeArguments() {
<span class="fc" id="L5863">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
<span class="fc" id="L5865">		public ExplicitCtorCallContext(ExplicitConstructorInvocationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5868" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitExplicitCtorCall(this);</span>
<span class="nc" id="L5869">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class PrimaryCtorCallContext extends ExplicitConstructorInvocationContext {
		public ExprContext expr() {
<span class="nc" id="L5874">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="nc" id="L5876">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L5877">		public TerminalNode LITERAL_SUPER() { return getToken(JavaLanguageParser.LITERAL_SUPER, 0); }</span>
		public ArgumentsContext arguments() {
<span class="nc" id="L5879">			return getRuleContext(ArgumentsContext.class,0);</span>
		}
<span class="nc" id="L5881">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public TypeArgumentsContext typeArguments() {
<span class="nc" id="L5883">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
<span class="fc" id="L5885">		public PrimaryCtorCallContext(ExplicitConstructorInvocationContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5888" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPrimaryCtorCall(this);</span>
<span class="nc" id="L5889">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ExplicitConstructorInvocationContext explicitConstructorInvocation() throws RecognitionException {
<span class="fc" id="L5894">		ExplicitConstructorInvocationContext _localctx = new ExplicitConstructorInvocationContext(_ctx, getState());</span>
<span class="fc" id="L5895">		enterRule(_localctx, 150, RULE_explicitConstructorInvocation);</span>
		int _la;
		try {
<span class="fc" id="L5898">			setState(968);</span>
<span class="fc" id="L5899">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L5900" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,107,_ctx) ) {</span>
			case 1:
<span class="fc" id="L5902">				_localctx = new ExplicitCtorCallContext(_localctx);</span>
<span class="fc" id="L5903">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L5905">				setState(953);</span>
<span class="fc" id="L5906">				_errHandler.sync(this);</span>
<span class="fc" id="L5907">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L5908" title="All 2 branches covered.">				if (_la==LT) {</span>
					{
<span class="fc" id="L5910">					setState(952);</span>
<span class="fc" id="L5911">					typeArguments();</span>
					}
				}

<span class="fc" id="L5915">				setState(955);</span>
<span class="fc" id="L5916">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L5917" title="1 of 4 branches missed.">				if ( !(_la==LITERAL_THIS || _la==LITERAL_SUPER) ) {</span>
<span class="nc" id="L5918">				_errHandler.recoverInline(this);</span>
				}
				else {
<span class="pc bpc" id="L5921" title="1 of 2 branches missed.">					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L5922">					_errHandler.reportMatch(this);</span>
<span class="fc" id="L5923">					consume();</span>
				}
<span class="fc" id="L5925">				setState(956);</span>
<span class="fc" id="L5926">				arguments();</span>
<span class="fc" id="L5927">				setState(957);</span>
<span class="fc" id="L5928">				match(SEMI);</span>
				}
<span class="fc" id="L5930">				break;</span>
			case 2:
<span class="fc" id="L5932">				_localctx = new PrimaryCtorCallContext(_localctx);</span>
<span class="fc" id="L5933">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L5935">				setState(959);</span>
<span class="fc" id="L5936">				expr(0);</span>
<span class="fc" id="L5937">				setState(960);</span>
<span class="fc" id="L5938">				match(DOT);</span>
<span class="fc" id="L5939">				setState(962);</span>
<span class="fc" id="L5940">				_errHandler.sync(this);</span>
<span class="fc" id="L5941">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L5942" title="All 2 branches covered.">				if (_la==LT) {</span>
					{
<span class="fc" id="L5944">					setState(961);</span>
<span class="fc" id="L5945">					typeArguments();</span>
					}
				}

<span class="fc" id="L5949">				setState(964);</span>
<span class="fc" id="L5950">				match(LITERAL_SUPER);</span>
<span class="fc" id="L5951">				setState(965);</span>
<span class="fc" id="L5952">				arguments();</span>
<span class="fc" id="L5953">				setState(966);</span>
<span class="fc" id="L5954">				match(SEMI);</span>
				}
				break;
			}
		}
<span class="nc" id="L5959">		catch (RecognitionException re) {</span>
<span class="nc" id="L5960">			_localctx.exception = re;</span>
<span class="nc" id="L5961">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L5962">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L5965">			exitRule();</span>
		}
<span class="fc" id="L5967">		return _localctx;</span>
	}

	public static class BlockContext extends ParserRuleContext {
<span class="nc" id="L5971">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
<span class="nc" id="L5972">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public List&lt;BlockStatementContext&gt; blockStatement() {
<span class="nc" id="L5974">			return getRuleContexts(BlockStatementContext.class);</span>
		}
		public BlockStatementContext blockStatement(int i) {
<span class="nc" id="L5977">			return getRuleContext(BlockStatementContext.class,i);</span>
		}
		public BlockContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L5980">			super(parent, invokingState);</span>
<span class="fc" id="L5981">		}</span>
<span class="nc" id="L5982">		@Override public int getRuleIndex() { return RULE_block; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L5985" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBlock(this);</span>
<span class="nc" id="L5986">			else return visitor.visitChildren(this);</span>
		}
	}

	public final BlockContext block() throws RecognitionException {
<span class="fc" id="L5991">		BlockContext _localctx = new BlockContext(_ctx, getState());</span>
<span class="fc" id="L5992">		enterRule(_localctx, 152, RULE_block);</span>
		try {
			int _alt;
<span class="fc" id="L5995">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L5997">			setState(970);</span>
<span class="fc" id="L5998">			match(LCURLY);</span>
<span class="fc" id="L5999">			setState(974);</span>
<span class="fc" id="L6000">			_errHandler.sync(this);</span>
<span class="fc" id="L6001">			_alt = getInterpreter().adaptivePredict(_input,108,_ctx);</span>
<span class="pc bpc" id="L6002" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L6003" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L6006">					setState(971);</span>
<span class="fc" id="L6007">					blockStatement();</span>
					}
					} 
				}
<span class="fc" id="L6011">				setState(976);</span>
<span class="fc" id="L6012">				_errHandler.sync(this);</span>
<span class="fc" id="L6013">				_alt = getInterpreter().adaptivePredict(_input,108,_ctx);</span>
			}
<span class="fc" id="L6015">			setState(977);</span>
<span class="fc" id="L6016">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L6019">		catch (RecognitionException re) {</span>
<span class="nc" id="L6020">			_localctx.exception = re;</span>
<span class="nc" id="L6021">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6022">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6025">			exitRule();</span>
		}
<span class="fc" id="L6027">		return _localctx;</span>
	}

	public static class BlockStatementContext extends ParserRuleContext {
		public BlockStatementContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L6032">			super(parent, invokingState);</span>
<span class="fc" id="L6033">		}</span>
<span class="nc" id="L6034">		@Override public int getRuleIndex() { return RULE_blockStatement; }</span>
	 
<span class="fc" id="L6036">		public BlockStatementContext() { }</span>
		public void copyFrom(BlockStatementContext ctx) {
<span class="fc" id="L6038">			super.copyFrom(ctx);</span>
<span class="fc" id="L6039">		}</span>
	}
	public static class StatContext extends BlockStatementContext {
		public StatementContext statement() {
<span class="nc" id="L6043">			return getRuleContext(StatementContext.class,0);</span>
		}
<span class="fc" id="L6045">		public StatContext(BlockStatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6048" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitStat(this);</span>
<span class="nc" id="L6049">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class LocalVarContext extends BlockStatementContext {
		public LocalVariableDeclarationContext localVariableDeclaration() {
<span class="nc" id="L6054">			return getRuleContext(LocalVariableDeclarationContext.class,0);</span>
		}
<span class="nc" id="L6056">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L6057">		public LocalVarContext(BlockStatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6060" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLocalVar(this);</span>
<span class="nc" id="L6061">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class LocalTypeContext extends BlockStatementContext {
		public LocalTypeDeclarationContext localTypeDeclaration() {
<span class="nc" id="L6066">			return getRuleContext(LocalTypeDeclarationContext.class,0);</span>
		}
<span class="fc" id="L6068">		public LocalTypeContext(BlockStatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6071" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLocalType(this);</span>
<span class="nc" id="L6072">			else return visitor.visitChildren(this);</span>
		}
	}

	public final BlockStatementContext blockStatement() throws RecognitionException {
<span class="fc" id="L6077">		BlockStatementContext _localctx = new BlockStatementContext(_ctx, getState());</span>
<span class="fc" id="L6078">		enterRule(_localctx, 154, RULE_blockStatement);</span>
		try {
<span class="fc" id="L6080">			setState(985);</span>
<span class="fc" id="L6081">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L6082" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,109,_ctx) ) {</span>
			case 1:
<span class="fc" id="L6084">				_localctx = new LocalVarContext(_localctx);</span>
<span class="fc" id="L6085">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L6087">				setState(979);</span>
<span class="pc bpc" id="L6088" title="1 of 2 branches missed.">				if (!(!isYieldStatement())) throw new FailedPredicateException(this, &quot;!isYieldStatement()&quot;);</span>
<span class="fc" id="L6089">				setState(980);</span>
<span class="fc" id="L6090">				localVariableDeclaration();</span>
<span class="fc" id="L6091">				setState(981);</span>
<span class="fc" id="L6092">				match(SEMI);</span>
				}
<span class="fc" id="L6094">				break;</span>
			case 2:
<span class="fc" id="L6096">				_localctx = new StatContext(_localctx);</span>
<span class="fc" id="L6097">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L6099">				setState(983);</span>
<span class="fc" id="L6100">				statement();</span>
				}
<span class="fc" id="L6102">				break;</span>
			case 3:
<span class="fc" id="L6104">				_localctx = new LocalTypeContext(_localctx);</span>
<span class="fc" id="L6105">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L6107">				setState(984);</span>
<span class="fc" id="L6108">				localTypeDeclaration();</span>
				}
				break;
			}
		}
<span class="nc" id="L6113">		catch (RecognitionException re) {</span>
<span class="nc" id="L6114">			_localctx.exception = re;</span>
<span class="nc" id="L6115">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6116">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6119">			exitRule();</span>
		}
<span class="fc" id="L6121">		return _localctx;</span>
	}

	public static class LocalVariableDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L6126">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public TypeTypeContext type;
		public VariableDeclaratorsContext variableDeclarators() {
<span class="nc" id="L6129">			return getRuleContext(VariableDeclaratorsContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L6132">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L6135">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L6138">			return getRuleContext(ModifierContext.class,i);</span>
		}
		public LocalVariableDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L6141">			super(parent, invokingState);</span>
<span class="fc" id="L6142">		}</span>
<span class="nc" id="L6143">		@Override public int getRuleIndex() { return RULE_localVariableDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6146" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLocalVariableDeclaration(this);</span>
<span class="nc" id="L6147">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LocalVariableDeclarationContext localVariableDeclaration() throws RecognitionException {
<span class="fc" id="L6152">		LocalVariableDeclarationContext _localctx = new LocalVariableDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L6153">		enterRule(_localctx, 156, RULE_localVariableDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L6156">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L6158">			setState(990);</span>
<span class="fc" id="L6159">			_errHandler.sync(this);</span>
<span class="fc" id="L6160">			_alt = getInterpreter().adaptivePredict(_input,110,_ctx);</span>
<span class="pc bpc" id="L6161" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L6162" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L6165">					setState(987);</span>
<span class="fc" id="L6166">					((LocalVariableDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L6167">					((LocalVariableDeclarationContext)_localctx).mods.add(((LocalVariableDeclarationContext)_localctx).modifier);</span>
					}
					} 
				}
<span class="fc" id="L6171">				setState(992);</span>
<span class="fc" id="L6172">				_errHandler.sync(this);</span>
<span class="fc" id="L6173">				_alt = getInterpreter().adaptivePredict(_input,110,_ctx);</span>
			}
<span class="fc" id="L6175">			setState(993);</span>
<span class="fc" id="L6176">			((LocalVariableDeclarationContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L6177">			setState(994);</span>
<span class="fc" id="L6178">			variableDeclarators(_localctx.mods, _localctx.type);</span>
			}
		}
<span class="nc" id="L6181">		catch (RecognitionException re) {</span>
<span class="nc" id="L6182">			_localctx.exception = re;</span>
<span class="nc" id="L6183">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6184">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6187">			exitRule();</span>
		}
<span class="fc" id="L6189">		return _localctx;</span>
	}

	public static class LocalTypeDeclarationContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L6194">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public ClassDeclarationContext classDeclaration() {
<span class="nc" id="L6196">			return getRuleContext(ClassDeclarationContext.class,0);</span>
		}
		public EnumDeclarationContext enumDeclaration() {
<span class="nc" id="L6199">			return getRuleContext(EnumDeclarationContext.class,0);</span>
		}
		public InterfaceDeclarationContext interfaceDeclaration() {
<span class="nc" id="L6202">			return getRuleContext(InterfaceDeclarationContext.class,0);</span>
		}
		public RecordDeclarationContext recordDeclaration() {
<span class="nc" id="L6205">			return getRuleContext(RecordDeclarationContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L6208">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L6211">			return getRuleContext(ModifierContext.class,i);</span>
		}
<span class="nc" id="L6213">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public LocalTypeDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L6215">			super(parent, invokingState);</span>
<span class="fc" id="L6216">		}</span>
<span class="nc" id="L6217">		@Override public int getRuleIndex() { return RULE_localTypeDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6220" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLocalTypeDeclaration(this);</span>
<span class="nc" id="L6221">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LocalTypeDeclarationContext localTypeDeclaration() throws RecognitionException {
<span class="fc" id="L6226">		LocalTypeDeclarationContext _localctx = new LocalTypeDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L6227">		enterRule(_localctx, 158, RULE_localTypeDeclaration);</span>
		int _la;
		try {
<span class="fc" id="L6230">			setState(1009);</span>
<span class="fc" id="L6231">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L6232" title="2 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
			case ABSTRACT:
			case STRICTFP:
			case LITERAL_PRIVATE:
			case LITERAL_PUBLIC:
			case LITERAL_PROTECTED:
			case LITERAL_STATIC:
			case LITERAL_TRANSIENT:
			case LITERAL_NATIVE:
			case LITERAL_SYNCHRONIZED:
			case LITERAL_VOLATILE:
			case LITERAL_CLASS:
			case LITERAL_INTERFACE:
			case LITERAL_DEFAULT:
			case ENUM:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
<span class="fc" id="L6252">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L6254">				setState(999);</span>
<span class="fc" id="L6255">				_errHandler.sync(this);</span>
<span class="fc" id="L6256">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L6257" title="All 8 branches covered.">				while (((((_la - 39)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 39)) &amp; ((1L &lt;&lt; (FINAL - 39)) | (1L &lt;&lt; (ABSTRACT - 39)) | (1L &lt;&lt; (STRICTFP - 39)) | (1L &lt;&lt; (LITERAL_PRIVATE - 39)) | (1L &lt;&lt; (LITERAL_PUBLIC - 39)) | (1L &lt;&lt; (LITERAL_PROTECTED - 39)) | (1L &lt;&lt; (LITERAL_STATIC - 39)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 39)) | (1L &lt;&lt; (LITERAL_NATIVE - 39)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 39)) | (1L &lt;&lt; (LITERAL_VOLATILE - 39)) | (1L &lt;&lt; (LITERAL_DEFAULT - 39)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)))) != 0)) {</span>
					{
					{
<span class="fc" id="L6260">					setState(996);</span>
<span class="fc" id="L6261">					((LocalTypeDeclarationContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L6262">					((LocalTypeDeclarationContext)_localctx).mods.add(((LocalTypeDeclarationContext)_localctx).modifier);</span>
					}
					}
<span class="fc" id="L6265">					setState(1001);</span>
<span class="fc" id="L6266">					_errHandler.sync(this);</span>
<span class="fc" id="L6267">					_la = _input.LA(1);</span>
				}
<span class="fc" id="L6269">				setState(1006);</span>
<span class="fc" id="L6270">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L6271" title="1 of 5 branches missed.">				switch (_input.LA(1)) {</span>
				case LITERAL_CLASS:
					{
<span class="fc" id="L6274">					setState(1002);</span>
<span class="fc" id="L6275">					classDeclaration(_localctx.mods);</span>
					}
<span class="fc" id="L6277">					break;</span>
				case ENUM:
					{
<span class="fc" id="L6280">					setState(1003);</span>
<span class="fc" id="L6281">					enumDeclaration(_localctx.mods);</span>
					}
<span class="fc" id="L6283">					break;</span>
				case LITERAL_INTERFACE:
					{
<span class="fc" id="L6286">					setState(1004);</span>
<span class="fc" id="L6287">					interfaceDeclaration(_localctx.mods);</span>
					}
<span class="fc" id="L6289">					break;</span>
				case LITERAL_RECORD:
					{
<span class="fc" id="L6292">					setState(1005);</span>
<span class="fc" id="L6293">					recordDeclaration(_localctx.mods);</span>
					}
<span class="fc" id="L6295">					break;</span>
				default:
<span class="nc" id="L6297">					throw new NoViableAltException(this);</span>
				}
				}
				break;
			case SEMI:
<span class="nc" id="L6302">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="nc" id="L6304">				setState(1008);</span>
<span class="nc" id="L6305">				match(SEMI);</span>
				}
<span class="nc" id="L6307">				break;</span>
			default:
<span class="nc" id="L6309">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L6312">		catch (RecognitionException re) {</span>
<span class="nc" id="L6313">			_localctx.exception = re;</span>
<span class="nc" id="L6314">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6315">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6318">			exitRule();</span>
		}
<span class="fc" id="L6320">		return _localctx;</span>
	}

	public static class StatementContext extends ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L6325">			super(parent, invokingState);</span>
<span class="fc" id="L6326">		}</span>
<span class="nc" id="L6327">		@Override public int getRuleIndex() { return RULE_statement; }</span>
	 
<span class="fc" id="L6329">		public StatementContext() { }</span>
		public void copyFrom(StatementContext ctx) {
<span class="fc" id="L6331">			super.copyFrom(ctx);</span>
<span class="fc" id="L6332">		}</span>
	}
	public static class AssertExpContext extends StatementContext {
<span class="fc" id="L6335">		public TerminalNode ASSERT() { return getToken(JavaLanguageParser.ASSERT, 0); }</span>
		public List&lt;ExpressionContext&gt; expression() {
<span class="nc" id="L6337">			return getRuleContexts(ExpressionContext.class);</span>
		}
		public ExpressionContext expression(int i) {
<span class="nc" id="L6340">			return getRuleContext(ExpressionContext.class,i);</span>
		}
<span class="nc" id="L6342">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="nc" id="L6343">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
<span class="fc" id="L6344">		public AssertExpContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6347" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitAssertExp(this);</span>
<span class="nc" id="L6348">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class IfStatContext extends StatementContext {
<span class="fc" id="L6352">		public TerminalNode LITERAL_IF() { return getToken(JavaLanguageParser.LITERAL_IF, 0); }</span>
		public ParExpressionContext parExpression() {
<span class="nc" id="L6354">			return getRuleContext(ParExpressionContext.class,0);</span>
		}
		public StatementContext statement() {
<span class="nc" id="L6357">			return getRuleContext(StatementContext.class,0);</span>
		}
		public ElseStatContext elseStat() {
<span class="nc" id="L6360">			return getRuleContext(ElseStatContext.class,0);</span>
		}
<span class="fc" id="L6362">		public IfStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6365" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitIfStat(this);</span>
<span class="nc" id="L6366">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class BlockStatContext extends StatementContext {
		public BlockContext blockLabel;
		public BlockContext block() {
<span class="nc" id="L6372">			return getRuleContext(BlockContext.class,0);</span>
		}
<span class="fc" id="L6374">		public BlockStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6377" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBlockStat(this);</span>
<span class="nc" id="L6378">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class TryWithResourceStatContext extends StatementContext {
<span class="fc" id="L6382">		public TerminalNode LITERAL_TRY() { return getToken(JavaLanguageParser.LITERAL_TRY, 0); }</span>
		public ResourceSpecificationContext resourceSpecification() {
<span class="nc" id="L6384">			return getRuleContext(ResourceSpecificationContext.class,0);</span>
		}
		public BlockContext block() {
<span class="nc" id="L6387">			return getRuleContext(BlockContext.class,0);</span>
		}
		public List&lt;CatchClauseContext&gt; catchClause() {
<span class="nc" id="L6390">			return getRuleContexts(CatchClauseContext.class);</span>
		}
		public CatchClauseContext catchClause(int i) {
<span class="nc" id="L6393">			return getRuleContext(CatchClauseContext.class,i);</span>
		}
		public FinallyBlockContext finallyBlock() {
<span class="nc" id="L6396">			return getRuleContext(FinallyBlockContext.class,0);</span>
		}
<span class="fc" id="L6398">		public TryWithResourceStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6401" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTryWithResourceStat(this);</span>
<span class="nc" id="L6402">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class TryStatContext extends StatementContext {
<span class="nc" id="L6406">		public TerminalNode LITERAL_TRY() { return getToken(JavaLanguageParser.LITERAL_TRY, 0); }</span>
		public BlockContext block() {
<span class="nc" id="L6408">			return getRuleContext(BlockContext.class,0);</span>
		}
		public FinallyBlockContext finallyBlock() {
<span class="nc" id="L6411">			return getRuleContext(FinallyBlockContext.class,0);</span>
		}
		public List&lt;CatchClauseContext&gt; catchClause() {
<span class="nc" id="L6414">			return getRuleContexts(CatchClauseContext.class);</span>
		}
		public CatchClauseContext catchClause(int i) {
<span class="nc" id="L6417">			return getRuleContext(CatchClauseContext.class,i);</span>
		}
<span class="fc" id="L6419">		public TryStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6422" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTryStat(this);</span>
<span class="nc" id="L6423">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SwitchStatContext extends StatementContext {
		public SwitchExpressionOrStatementContext switchExpressionOrStatement() {
<span class="nc" id="L6428">			return getRuleContext(SwitchExpressionOrStatementContext.class,0);</span>
		}
<span class="fc" id="L6430">		public SwitchStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6433" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchStat(this);</span>
<span class="nc" id="L6434">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SyncStatContext extends StatementContext {
<span class="nc" id="L6438">		public TerminalNode LITERAL_SYNCHRONIZED() { return getToken(JavaLanguageParser.LITERAL_SYNCHRONIZED, 0); }</span>
		public ParExpressionContext parExpression() {
<span class="nc" id="L6440">			return getRuleContext(ParExpressionContext.class,0);</span>
		}
		public BlockContext block() {
<span class="nc" id="L6443">			return getRuleContext(BlockContext.class,0);</span>
		}
<span class="fc" id="L6445">		public SyncStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6448" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSyncStat(this);</span>
<span class="nc" id="L6449">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ContinueStatContext extends StatementContext {
<span class="fc" id="L6453">		public TerminalNode LITERAL_CONTINUE() { return getToken(JavaLanguageParser.LITERAL_CONTINUE, 0); }</span>
<span class="nc" id="L6454">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public IdContext id() {
<span class="nc" id="L6456">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L6458">		public ContinueStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6461" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitContinueStat(this);</span>
<span class="nc" id="L6462">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class BreakStatContext extends StatementContext {
<span class="fc" id="L6466">		public TerminalNode LITERAL_BREAK() { return getToken(JavaLanguageParser.LITERAL_BREAK, 0); }</span>
<span class="nc" id="L6467">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public IdContext id() {
<span class="nc" id="L6469">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L6471">		public BreakStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6474" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBreakStat(this);</span>
<span class="nc" id="L6475">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ForStatContext extends StatementContext {
<span class="nc" id="L6479">		public TerminalNode LITERAL_FOR() { return getToken(JavaLanguageParser.LITERAL_FOR, 0); }</span>
		public ForControlContext forControl() {
<span class="nc" id="L6481">			return getRuleContext(ForControlContext.class,0);</span>
		}
		public StatementContext statement() {
<span class="nc" id="L6484">			return getRuleContext(StatementContext.class,0);</span>
		}
<span class="fc" id="L6486">		public ForStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6489" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitForStat(this);</span>
<span class="nc" id="L6490">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class LabelStatContext extends StatementContext {
		public IdContext id() {
<span class="fc" id="L6495">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L6497">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
		public StatementContext statement() {
<span class="fc" id="L6499">			return getRuleContext(StatementContext.class,0);</span>
		}
<span class="fc" id="L6501">		public LabelStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6504" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLabelStat(this);</span>
<span class="nc" id="L6505">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class DoStatContext extends StatementContext {
<span class="nc" id="L6509">		public TerminalNode LITERAL_DO() { return getToken(JavaLanguageParser.LITERAL_DO, 0); }</span>
		public StatementContext statement() {
<span class="fc" id="L6511">			return getRuleContext(StatementContext.class,0);</span>
		}
<span class="fc" id="L6513">		public TerminalNode LITERAL_WHILE() { return getToken(JavaLanguageParser.LITERAL_WHILE, 0); }</span>
		public ParExpressionContext parExpression() {
<span class="fc" id="L6515">			return getRuleContext(ParExpressionContext.class,0);</span>
		}
<span class="fc" id="L6517">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L6518">		public DoStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6521" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitDoStat(this);</span>
<span class="nc" id="L6522">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ReturnStatContext extends StatementContext {
<span class="fc" id="L6526">		public TerminalNode LITERAL_RETURN() { return getToken(JavaLanguageParser.LITERAL_RETURN, 0); }</span>
<span class="nc" id="L6527">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L6529">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="fc" id="L6531">		public ReturnStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6534" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitReturnStat(this);</span>
<span class="nc" id="L6535">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ThrowStatContext extends StatementContext {
<span class="fc" id="L6539">		public TerminalNode LITERAL_THROW() { return getToken(JavaLanguageParser.LITERAL_THROW, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L6541">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L6543">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L6544">		public ThrowStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6547" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitThrowStat(this);</span>
<span class="nc" id="L6548">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class YieldStatContext extends StatementContext {
<span class="fc" id="L6552">		public TerminalNode LITERAL_YIELD() { return getToken(JavaLanguageParser.LITERAL_YIELD, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L6554">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L6556">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L6557">		public YieldStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6560" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitYieldStat(this);</span>
<span class="nc" id="L6561">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class EmptyStatContext extends StatementContext {
<span class="nc" id="L6565">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
<span class="fc" id="L6566">		public EmptyStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6569" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEmptyStat(this);</span>
<span class="nc" id="L6570">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ExpStatContext extends StatementContext {
		public ExpressionContext statementExpression;
<span class="fc" id="L6575">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L6577">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="fc" id="L6579">		public ExpStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6582" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitExpStat(this);</span>
<span class="nc" id="L6583">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class WhileStatContext extends StatementContext {
<span class="nc" id="L6587">		public TerminalNode LITERAL_WHILE() { return getToken(JavaLanguageParser.LITERAL_WHILE, 0); }</span>
		public ParExpressionContext parExpression() {
<span class="nc" id="L6589">			return getRuleContext(ParExpressionContext.class,0);</span>
		}
		public StatementContext statement() {
<span class="nc" id="L6592">			return getRuleContext(StatementContext.class,0);</span>
		}
<span class="fc" id="L6594">		public WhileStatContext(StatementContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6597" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitWhileStat(this);</span>
<span class="nc" id="L6598">			else return visitor.visitChildren(this);</span>
		}
	}

	public final StatementContext statement() throws RecognitionException {
<span class="fc" id="L6603">		StatementContext _localctx = new StatementContext(_ctx, getState());</span>
<span class="fc" id="L6604">		enterRule(_localctx, 160, RULE_statement);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L6608">			setState(1101);</span>
<span class="fc" id="L6609">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L6610" title="1 of 19 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,124,_ctx) ) {</span>
			case 1:
<span class="fc" id="L6612">				_localctx = new BlockStatContext(_localctx);</span>
<span class="fc" id="L6613">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L6615">				setState(1011);</span>
<span class="fc" id="L6616">				((BlockStatContext)_localctx).blockLabel = block();</span>
				}
<span class="fc" id="L6618">				break;</span>
			case 2:
<span class="fc" id="L6620">				_localctx = new AssertExpContext(_localctx);</span>
<span class="fc" id="L6621">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L6623">				setState(1012);</span>
<span class="fc" id="L6624">				match(ASSERT);</span>
<span class="fc" id="L6625">				setState(1013);</span>
<span class="fc" id="L6626">				expression();</span>
<span class="fc" id="L6627">				setState(1016);</span>
<span class="fc" id="L6628">				_errHandler.sync(this);</span>
<span class="fc" id="L6629">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L6630" title="All 2 branches covered.">				if (_la==COLON) {</span>
					{
<span class="fc" id="L6632">					setState(1014);</span>
<span class="fc" id="L6633">					match(COLON);</span>
<span class="fc" id="L6634">					setState(1015);</span>
<span class="fc" id="L6635">					expression();</span>
					}
				}

<span class="fc" id="L6639">				setState(1018);</span>
<span class="fc" id="L6640">				match(SEMI);</span>
				}
<span class="fc" id="L6642">				break;</span>
			case 3:
<span class="fc" id="L6644">				_localctx = new IfStatContext(_localctx);</span>
<span class="fc" id="L6645">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L6647">				setState(1020);</span>
<span class="fc" id="L6648">				match(LITERAL_IF);</span>
<span class="fc" id="L6649">				setState(1021);</span>
<span class="fc" id="L6650">				parExpression();</span>
<span class="fc" id="L6651">				setState(1022);</span>
<span class="fc" id="L6652">				statement();</span>
<span class="fc" id="L6653">				setState(1024);</span>
<span class="fc" id="L6654">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L6655" title="All 2 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,115,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L6658">					setState(1023);</span>
<span class="fc" id="L6659">					elseStat();</span>
					}
					break;
				}
				}
<span class="fc" id="L6664">				break;</span>
			case 4:
<span class="fc" id="L6666">				_localctx = new ForStatContext(_localctx);</span>
<span class="fc" id="L6667">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L6669">				setState(1026);</span>
<span class="fc" id="L6670">				match(LITERAL_FOR);</span>
<span class="fc" id="L6671">				setState(1027);</span>
<span class="fc" id="L6672">				forControl();</span>
<span class="fc" id="L6673">				setState(1028);</span>
<span class="fc" id="L6674">				statement();</span>
				}
<span class="fc" id="L6676">				break;</span>
			case 5:
<span class="fc" id="L6678">				_localctx = new WhileStatContext(_localctx);</span>
<span class="fc" id="L6679">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L6681">				setState(1030);</span>
<span class="fc" id="L6682">				match(LITERAL_WHILE);</span>
<span class="fc" id="L6683">				setState(1031);</span>
<span class="fc" id="L6684">				parExpression();</span>
<span class="fc" id="L6685">				setState(1032);</span>
<span class="fc" id="L6686">				statement();</span>
				}
<span class="fc" id="L6688">				break;</span>
			case 6:
<span class="fc" id="L6690">				_localctx = new DoStatContext(_localctx);</span>
<span class="fc" id="L6691">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L6693">				setState(1034);</span>
<span class="fc" id="L6694">				match(LITERAL_DO);</span>
<span class="fc" id="L6695">				setState(1035);</span>
<span class="fc" id="L6696">				statement();</span>
<span class="fc" id="L6697">				setState(1036);</span>
<span class="fc" id="L6698">				match(LITERAL_WHILE);</span>
<span class="fc" id="L6699">				setState(1037);</span>
<span class="fc" id="L6700">				parExpression();</span>
<span class="fc" id="L6701">				setState(1038);</span>
<span class="fc" id="L6702">				match(SEMI);</span>
				}
<span class="fc" id="L6704">				break;</span>
			case 7:
<span class="fc" id="L6706">				_localctx = new TryStatContext(_localctx);</span>
<span class="fc" id="L6707">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L6709">				setState(1040);</span>
<span class="fc" id="L6710">				match(LITERAL_TRY);</span>
<span class="fc" id="L6711">				setState(1041);</span>
<span class="fc" id="L6712">				block();</span>
<span class="fc" id="L6713">				setState(1051);</span>
<span class="fc" id="L6714">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L6715" title="1 of 3 branches missed.">				switch (_input.LA(1)) {</span>
				case LITERAL_CATCH:
					{
<span class="fc" id="L6718">					setState(1043); </span>
<span class="fc" id="L6719">					_errHandler.sync(this);</span>
<span class="fc" id="L6720">					_alt = 1;</span>
					do {
<span class="pc bpc" id="L6722" title="1 of 2 branches missed.">						switch (_alt) {</span>
						case 1:
							{
							{
<span class="fc" id="L6726">							setState(1042);</span>
<span class="fc" id="L6727">							catchClause();</span>
							}
							}
<span class="fc" id="L6730">							break;</span>
						default:
<span class="nc" id="L6732">							throw new NoViableAltException(this);</span>
						}
<span class="fc" id="L6734">						setState(1045); </span>
<span class="fc" id="L6735">						_errHandler.sync(this);</span>
<span class="fc" id="L6736">						_alt = getInterpreter().adaptivePredict(_input,116,_ctx);</span>
<span class="pc bpc" id="L6737" title="1 of 4 branches missed.">					} while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );</span>
<span class="fc" id="L6738">					setState(1048);</span>
<span class="fc" id="L6739">					_errHandler.sync(this);</span>
<span class="fc bfc" id="L6740" title="All 2 branches covered.">					switch ( getInterpreter().adaptivePredict(_input,117,_ctx) ) {</span>
					case 1:
						{
<span class="fc" id="L6743">						setState(1047);</span>
<span class="fc" id="L6744">						finallyBlock();</span>
						}
						break;
					}
					}
<span class="fc" id="L6749">					break;</span>
				case LITERAL_FINALLY:
					{
<span class="fc" id="L6752">					setState(1050);</span>
<span class="fc" id="L6753">					finallyBlock();</span>
					}
<span class="fc" id="L6755">					break;</span>
				default:
<span class="nc" id="L6757">					throw new NoViableAltException(this);</span>
				}
				}
				break;
			case 8:
<span class="fc" id="L6762">				_localctx = new TryWithResourceStatContext(_localctx);</span>
<span class="fc" id="L6763">				enterOuterAlt(_localctx, 8);</span>
				{
<span class="fc" id="L6765">				setState(1053);</span>
<span class="fc" id="L6766">				match(LITERAL_TRY);</span>
<span class="fc" id="L6767">				setState(1054);</span>
<span class="fc" id="L6768">				resourceSpecification();</span>
<span class="fc" id="L6769">				setState(1055);</span>
<span class="fc" id="L6770">				block();</span>
<span class="fc" id="L6771">				setState(1059);</span>
<span class="fc" id="L6772">				_errHandler.sync(this);</span>
<span class="fc" id="L6773">				_alt = getInterpreter().adaptivePredict(_input,119,_ctx);</span>
<span class="pc bpc" id="L6774" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L6775" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L6778">						setState(1056);</span>
<span class="fc" id="L6779">						catchClause();</span>
						}
						} 
					}
<span class="fc" id="L6783">					setState(1061);</span>
<span class="fc" id="L6784">					_errHandler.sync(this);</span>
<span class="fc" id="L6785">					_alt = getInterpreter().adaptivePredict(_input,119,_ctx);</span>
				}
<span class="fc" id="L6787">				setState(1063);</span>
<span class="fc" id="L6788">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L6789" title="All 2 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,120,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L6792">					setState(1062);</span>
<span class="fc" id="L6793">					finallyBlock();</span>
					}
					break;
				}
				}
<span class="fc" id="L6798">				break;</span>
			case 9:
<span class="fc" id="L6800">				_localctx = new YieldStatContext(_localctx);</span>
<span class="fc" id="L6801">				enterOuterAlt(_localctx, 9);</span>
				{
<span class="fc" id="L6803">				setState(1065);</span>
<span class="fc" id="L6804">				match(LITERAL_YIELD);</span>
<span class="fc" id="L6805">				setState(1066);</span>
<span class="fc" id="L6806">				expression();</span>
<span class="fc" id="L6807">				setState(1067);</span>
<span class="fc" id="L6808">				match(SEMI);</span>
				}
<span class="fc" id="L6810">				break;</span>
			case 10:
<span class="fc" id="L6812">				_localctx = new SwitchStatContext(_localctx);</span>
<span class="fc" id="L6813">				enterOuterAlt(_localctx, 10);</span>
				{
<span class="fc" id="L6815">				setState(1069);</span>
<span class="fc" id="L6816">				switchExpressionOrStatement();</span>
				}
<span class="fc" id="L6818">				break;</span>
			case 11:
<span class="fc" id="L6820">				_localctx = new SyncStatContext(_localctx);</span>
<span class="fc" id="L6821">				enterOuterAlt(_localctx, 11);</span>
				{
<span class="fc" id="L6823">				setState(1070);</span>
<span class="fc" id="L6824">				match(LITERAL_SYNCHRONIZED);</span>
<span class="fc" id="L6825">				setState(1071);</span>
<span class="fc" id="L6826">				parExpression();</span>
<span class="fc" id="L6827">				setState(1072);</span>
<span class="fc" id="L6828">				block();</span>
				}
<span class="fc" id="L6830">				break;</span>
			case 12:
<span class="fc" id="L6832">				_localctx = new ReturnStatContext(_localctx);</span>
<span class="fc" id="L6833">				enterOuterAlt(_localctx, 12);</span>
				{
<span class="fc" id="L6835">				setState(1074);</span>
<span class="fc" id="L6836">				match(LITERAL_RETURN);</span>
<span class="fc" id="L6837">				setState(1076);</span>
<span class="fc" id="L6838">				_errHandler.sync(this);</span>
<span class="fc" id="L6839">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L6840" title="2 of 12 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
					{
<span class="fc" id="L6842">					setState(1075);</span>
<span class="fc" id="L6843">					expression();</span>
					}
				}

<span class="fc" id="L6847">				setState(1078);</span>
<span class="fc" id="L6848">				match(SEMI);</span>
				}
<span class="fc" id="L6850">				break;</span>
			case 13:
<span class="fc" id="L6852">				_localctx = new ThrowStatContext(_localctx);</span>
<span class="fc" id="L6853">				enterOuterAlt(_localctx, 13);</span>
				{
<span class="fc" id="L6855">				setState(1079);</span>
<span class="fc" id="L6856">				match(LITERAL_THROW);</span>
<span class="fc" id="L6857">				setState(1080);</span>
<span class="fc" id="L6858">				expression();</span>
<span class="fc" id="L6859">				setState(1081);</span>
<span class="fc" id="L6860">				match(SEMI);</span>
				}
<span class="fc" id="L6862">				break;</span>
			case 14:
<span class="fc" id="L6864">				_localctx = new BreakStatContext(_localctx);</span>
<span class="fc" id="L6865">				enterOuterAlt(_localctx, 14);</span>
				{
<span class="fc" id="L6867">				setState(1083);</span>
<span class="fc" id="L6868">				match(LITERAL_BREAK);</span>
<span class="fc" id="L6869">				setState(1085);</span>
<span class="fc" id="L6870">				_errHandler.sync(this);</span>
<span class="fc" id="L6871">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L6872" title="3 of 6 branches missed.">				if (_la==IDENT || ((((_la - 200)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 200)) &amp; ((1L &lt;&lt; (LITERAL_RECORD - 200)) | (1L &lt;&lt; (LITERAL_YIELD - 200)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 200)) | (1L &lt;&lt; (LITERAL_SEALED - 200)) | (1L &lt;&lt; (LITERAL_PERMITS - 200)))) != 0)) {</span>
					{
<span class="fc" id="L6874">					setState(1084);</span>
<span class="fc" id="L6875">					id();</span>
					}
				}

<span class="fc" id="L6879">				setState(1087);</span>
<span class="fc" id="L6880">				match(SEMI);</span>
				}
<span class="fc" id="L6882">				break;</span>
			case 15:
<span class="fc" id="L6884">				_localctx = new ContinueStatContext(_localctx);</span>
<span class="fc" id="L6885">				enterOuterAlt(_localctx, 15);</span>
				{
<span class="fc" id="L6887">				setState(1088);</span>
<span class="fc" id="L6888">				match(LITERAL_CONTINUE);</span>
<span class="fc" id="L6889">				setState(1090);</span>
<span class="fc" id="L6890">				_errHandler.sync(this);</span>
<span class="fc" id="L6891">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L6892" title="3 of 6 branches missed.">				if (_la==IDENT || ((((_la - 200)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 200)) &amp; ((1L &lt;&lt; (LITERAL_RECORD - 200)) | (1L &lt;&lt; (LITERAL_YIELD - 200)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 200)) | (1L &lt;&lt; (LITERAL_SEALED - 200)) | (1L &lt;&lt; (LITERAL_PERMITS - 200)))) != 0)) {</span>
					{
<span class="fc" id="L6894">					setState(1089);</span>
<span class="fc" id="L6895">					id();</span>
					}
				}

<span class="fc" id="L6899">				setState(1092);</span>
<span class="fc" id="L6900">				match(SEMI);</span>
				}
<span class="fc" id="L6902">				break;</span>
			case 16:
<span class="fc" id="L6904">				_localctx = new EmptyStatContext(_localctx);</span>
<span class="fc" id="L6905">				enterOuterAlt(_localctx, 16);</span>
				{
<span class="fc" id="L6907">				setState(1093);</span>
<span class="fc" id="L6908">				match(SEMI);</span>
				}
<span class="fc" id="L6910">				break;</span>
			case 17:
<span class="fc" id="L6912">				_localctx = new ExpStatContext(_localctx);</span>
<span class="fc" id="L6913">				enterOuterAlt(_localctx, 17);</span>
				{
<span class="fc" id="L6915">				setState(1094);</span>
<span class="fc" id="L6916">				((ExpStatContext)_localctx).statementExpression = expression();</span>
<span class="fc" id="L6917">				setState(1095);</span>
<span class="fc" id="L6918">				match(SEMI);</span>
				}
<span class="fc" id="L6920">				break;</span>
			case 18:
<span class="fc" id="L6922">				_localctx = new LabelStatContext(_localctx);</span>
<span class="fc" id="L6923">				enterOuterAlt(_localctx, 18);</span>
				{
<span class="fc" id="L6925">				setState(1097);</span>
<span class="fc" id="L6926">				id();</span>
<span class="fc" id="L6927">				setState(1098);</span>
<span class="fc" id="L6928">				match(COLON);</span>
<span class="fc" id="L6929">				setState(1099);</span>
<span class="fc" id="L6930">				statement();</span>
				}
				break;
			}
		}
<span class="nc" id="L6935">		catch (RecognitionException re) {</span>
<span class="nc" id="L6936">			_localctx.exception = re;</span>
<span class="nc" id="L6937">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6938">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6941">			exitRule();</span>
		}
<span class="fc" id="L6943">		return _localctx;</span>
	}

	public static class SwitchExpressionOrStatementContext extends ParserRuleContext {
<span class="fc" id="L6947">		public TerminalNode LITERAL_SWITCH() { return getToken(JavaLanguageParser.LITERAL_SWITCH, 0); }</span>
		public ParExpressionContext parExpression() {
<span class="fc" id="L6949">			return getRuleContext(ParExpressionContext.class,0);</span>
		}
<span class="fc" id="L6951">		public TerminalNode LCURLY() { return getToken(JavaLanguageParser.LCURLY, 0); }</span>
		public SwitchBlockContext switchBlock() {
<span class="fc" id="L6953">			return getRuleContext(SwitchBlockContext.class,0);</span>
		}
<span class="fc" id="L6955">		public TerminalNode RCURLY() { return getToken(JavaLanguageParser.RCURLY, 0); }</span>
		public SwitchExpressionOrStatementContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L6957">			super(parent, invokingState);</span>
<span class="fc" id="L6958">		}</span>
<span class="nc" id="L6959">		@Override public int getRuleIndex() { return RULE_switchExpressionOrStatement; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L6962" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchExpressionOrStatement(this);</span>
<span class="nc" id="L6963">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchExpressionOrStatementContext switchExpressionOrStatement() throws RecognitionException {
<span class="fc" id="L6968">		SwitchExpressionOrStatementContext _localctx = new SwitchExpressionOrStatementContext(_ctx, getState());</span>
<span class="fc" id="L6969">		enterRule(_localctx, 162, RULE_switchExpressionOrStatement);</span>
		try {
<span class="fc" id="L6971">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L6973">			setState(1103);</span>
<span class="fc" id="L6974">			match(LITERAL_SWITCH);</span>
<span class="fc" id="L6975">			setState(1104);</span>
<span class="fc" id="L6976">			parExpression();</span>
<span class="fc" id="L6977">			setState(1105);</span>
<span class="fc" id="L6978">			match(LCURLY);</span>
<span class="fc" id="L6979">			switchBlockDepth++;</span>
<span class="fc" id="L6980">			setState(1107);</span>
<span class="fc" id="L6981">			switchBlock();</span>
<span class="fc" id="L6982">			switchBlockDepth--;</span>
<span class="fc" id="L6983">			setState(1109);</span>
<span class="fc" id="L6984">			match(RCURLY);</span>
			}
		}
<span class="nc" id="L6987">		catch (RecognitionException re) {</span>
<span class="nc" id="L6988">			_localctx.exception = re;</span>
<span class="nc" id="L6989">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L6990">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L6993">			exitRule();</span>
		}
<span class="fc" id="L6995">		return _localctx;</span>
	}

	public static class SwitchBlockContext extends ParserRuleContext {
		public SwitchBlockContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7000">			super(parent, invokingState);</span>
<span class="fc" id="L7001">		}</span>
<span class="nc" id="L7002">		@Override public int getRuleIndex() { return RULE_switchBlock; }</span>
	 
<span class="fc" id="L7004">		public SwitchBlockContext() { }</span>
		public void copyFrom(SwitchBlockContext ctx) {
<span class="fc" id="L7006">			super.copyFrom(ctx);</span>
<span class="fc" id="L7007">		}</span>
	}
	public static class SwitchRulesContext extends SwitchBlockContext {
		public List&lt;SwitchLabeledRuleContext&gt; switchLabeledRule() {
<span class="fc" id="L7011">			return getRuleContexts(SwitchLabeledRuleContext.class);</span>
		}
		public SwitchLabeledRuleContext switchLabeledRule(int i) {
<span class="nc" id="L7014">			return getRuleContext(SwitchLabeledRuleContext.class,i);</span>
		}
<span class="fc" id="L7016">		public SwitchRulesContext(SwitchBlockContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7019" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchRules(this);</span>
<span class="nc" id="L7020">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SwitchBlocksContext extends SwitchBlockContext {
		public SwitchBlockStatementGroupContext switchBlockStatementGroup;
<span class="fc" id="L7025">		public List&lt;SwitchBlockStatementGroupContext&gt; groups = new ArrayList&lt;SwitchBlockStatementGroupContext&gt;();</span>
		public SwitchLabelContext switchLabel;
<span class="fc" id="L7027">		public List&lt;SwitchLabelContext&gt; emptyLabels = new ArrayList&lt;SwitchLabelContext&gt;();</span>
		public List&lt;SwitchBlockStatementGroupContext&gt; switchBlockStatementGroup() {
<span class="nc" id="L7029">			return getRuleContexts(SwitchBlockStatementGroupContext.class);</span>
		}
		public SwitchBlockStatementGroupContext switchBlockStatementGroup(int i) {
<span class="nc" id="L7032">			return getRuleContext(SwitchBlockStatementGroupContext.class,i);</span>
		}
		public List&lt;SwitchLabelContext&gt; switchLabel() {
<span class="nc" id="L7035">			return getRuleContexts(SwitchLabelContext.class);</span>
		}
		public SwitchLabelContext switchLabel(int i) {
<span class="nc" id="L7038">			return getRuleContext(SwitchLabelContext.class,i);</span>
		}
<span class="fc" id="L7040">		public SwitchBlocksContext(SwitchBlockContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7043" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchBlocks(this);</span>
<span class="nc" id="L7044">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchBlockContext switchBlock() throws RecognitionException {
<span class="fc" id="L7049">		SwitchBlockContext _localctx = new SwitchBlockContext(_ctx, getState());</span>
<span class="fc" id="L7050">		enterRule(_localctx, 164, RULE_switchBlock);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L7054">			setState(1128);</span>
<span class="fc" id="L7055">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L7056" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,128,_ctx) ) {</span>
			case 1:
<span class="fc" id="L7058">				_localctx = new SwitchRulesContext(_localctx);</span>
<span class="fc" id="L7059">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L7061">				setState(1112); </span>
<span class="fc" id="L7062">				_errHandler.sync(this);</span>
<span class="fc" id="L7063">				_la = _input.LA(1);</span>
				do {
					{
					{
<span class="fc" id="L7067">					setState(1111);</span>
<span class="fc" id="L7068">					switchLabeledRule();</span>
					}
					}
<span class="fc" id="L7071">					setState(1114); </span>
<span class="fc" id="L7072">					_errHandler.sync(this);</span>
<span class="fc" id="L7073">					_la = _input.LA(1);</span>
<span class="fc bfc" id="L7074" title="All 4 branches covered.">				} while ( _la==LITERAL_CASE || _la==LITERAL_DEFAULT );</span>
				}
<span class="fc" id="L7076">				break;</span>
			case 2:
<span class="fc" id="L7078">				_localctx = new SwitchBlocksContext(_localctx);</span>
<span class="fc" id="L7079">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L7081">				setState(1119);</span>
<span class="fc" id="L7082">				_errHandler.sync(this);</span>
<span class="fc" id="L7083">				_alt = getInterpreter().adaptivePredict(_input,126,_ctx);</span>
<span class="pc bpc" id="L7084" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L7085" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L7088">						setState(1116);</span>
<span class="fc" id="L7089">						((SwitchBlocksContext)_localctx).switchBlockStatementGroup = switchBlockStatementGroup();</span>
<span class="fc" id="L7090">						((SwitchBlocksContext)_localctx).groups.add(((SwitchBlocksContext)_localctx).switchBlockStatementGroup);</span>
						}
						} 
					}
<span class="fc" id="L7094">					setState(1121);</span>
<span class="fc" id="L7095">					_errHandler.sync(this);</span>
<span class="fc" id="L7096">					_alt = getInterpreter().adaptivePredict(_input,126,_ctx);</span>
				}
<span class="fc" id="L7098">				setState(1125);</span>
<span class="fc" id="L7099">				_errHandler.sync(this);</span>
<span class="fc" id="L7100">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L7101" title="All 4 branches covered.">				while (_la==LITERAL_CASE || _la==LITERAL_DEFAULT) {</span>
					{
					{
<span class="fc" id="L7104">					setState(1122);</span>
<span class="fc" id="L7105">					((SwitchBlocksContext)_localctx).switchLabel = switchLabel();</span>
<span class="fc" id="L7106">					((SwitchBlocksContext)_localctx).emptyLabels.add(((SwitchBlocksContext)_localctx).switchLabel);</span>
					}
					}
<span class="fc" id="L7109">					setState(1127);</span>
<span class="fc" id="L7110">					_errHandler.sync(this);</span>
<span class="fc" id="L7111">					_la = _input.LA(1);</span>
				}
				}
				break;
			}
		}
<span class="nc" id="L7117">		catch (RecognitionException re) {</span>
<span class="nc" id="L7118">			_localctx.exception = re;</span>
<span class="nc" id="L7119">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7120">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7123">			exitRule();</span>
		}
<span class="fc" id="L7125">		return _localctx;</span>
	}

	public static class SwitchLabeledRuleContext extends ParserRuleContext {
		public SwitchLabeledExpressionContext switchLabeledExpression() {
<span class="nc" id="L7130">			return getRuleContext(SwitchLabeledExpressionContext.class,0);</span>
		}
		public SwitchLabeledBlockContext switchLabeledBlock() {
<span class="nc" id="L7133">			return getRuleContext(SwitchLabeledBlockContext.class,0);</span>
		}
		public SwitchLabeledThrowContext switchLabeledThrow() {
<span class="nc" id="L7136">			return getRuleContext(SwitchLabeledThrowContext.class,0);</span>
		}
		public SwitchLabeledRuleContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7139">			super(parent, invokingState);</span>
<span class="fc" id="L7140">		}</span>
<span class="nc" id="L7141">		@Override public int getRuleIndex() { return RULE_switchLabeledRule; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7144" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchLabeledRule(this);</span>
<span class="nc" id="L7145">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchLabeledRuleContext switchLabeledRule() throws RecognitionException {
<span class="fc" id="L7150">		SwitchLabeledRuleContext _localctx = new SwitchLabeledRuleContext(_ctx, getState());</span>
<span class="fc" id="L7151">		enterRule(_localctx, 166, RULE_switchLabeledRule);</span>
		try {
<span class="fc" id="L7153">			setState(1133);</span>
<span class="fc" id="L7154">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L7155" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,129,_ctx) ) {</span>
			case 1:
<span class="fc" id="L7157">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L7159">				setState(1130);</span>
<span class="fc" id="L7160">				switchLabeledExpression();</span>
				}
<span class="fc" id="L7162">				break;</span>
			case 2:
<span class="fc" id="L7164">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L7166">				setState(1131);</span>
<span class="fc" id="L7167">				switchLabeledBlock();</span>
				}
<span class="fc" id="L7169">				break;</span>
			case 3:
<span class="fc" id="L7171">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L7173">				setState(1132);</span>
<span class="fc" id="L7174">				switchLabeledThrow();</span>
				}
				break;
			}
		}
<span class="nc" id="L7179">		catch (RecognitionException re) {</span>
<span class="nc" id="L7180">			_localctx.exception = re;</span>
<span class="nc" id="L7181">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7182">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7185">			exitRule();</span>
		}
<span class="fc" id="L7187">		return _localctx;</span>
	}

	public static class SwitchLabeledExpressionContext extends ParserRuleContext {
		public SwitchLabelContext switchLabel() {
<span class="nc" id="L7192">			return getRuleContext(SwitchLabelContext.class,0);</span>
		}
<span class="nc" id="L7194">		public TerminalNode LAMBDA() { return getToken(JavaLanguageParser.LAMBDA, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L7196">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L7198">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public SwitchLabeledExpressionContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7200">			super(parent, invokingState);</span>
<span class="fc" id="L7201">		}</span>
<span class="nc" id="L7202">		@Override public int getRuleIndex() { return RULE_switchLabeledExpression; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7205" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchLabeledExpression(this);</span>
<span class="nc" id="L7206">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchLabeledExpressionContext switchLabeledExpression() throws RecognitionException {
<span class="fc" id="L7211">		SwitchLabeledExpressionContext _localctx = new SwitchLabeledExpressionContext(_ctx, getState());</span>
<span class="fc" id="L7212">		enterRule(_localctx, 168, RULE_switchLabeledExpression);</span>
		try {
<span class="fc" id="L7214">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7216">			setState(1135);</span>
<span class="fc" id="L7217">			switchLabel();</span>
<span class="fc" id="L7218">			setState(1136);</span>
<span class="fc" id="L7219">			match(LAMBDA);</span>
<span class="fc" id="L7220">			setState(1137);</span>
<span class="fc" id="L7221">			expression();</span>
<span class="fc" id="L7222">			setState(1138);</span>
<span class="fc" id="L7223">			match(SEMI);</span>
			}
		}
<span class="nc" id="L7226">		catch (RecognitionException re) {</span>
<span class="nc" id="L7227">			_localctx.exception = re;</span>
<span class="nc" id="L7228">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7229">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7232">			exitRule();</span>
		}
<span class="fc" id="L7234">		return _localctx;</span>
	}

	public static class SwitchLabeledBlockContext extends ParserRuleContext {
		public SwitchLabelContext switchLabel() {
<span class="nc" id="L7239">			return getRuleContext(SwitchLabelContext.class,0);</span>
		}
<span class="nc" id="L7241">		public TerminalNode LAMBDA() { return getToken(JavaLanguageParser.LAMBDA, 0); }</span>
		public BlockContext block() {
<span class="nc" id="L7243">			return getRuleContext(BlockContext.class,0);</span>
		}
		public SwitchLabeledBlockContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7246">			super(parent, invokingState);</span>
<span class="fc" id="L7247">		}</span>
<span class="nc" id="L7248">		@Override public int getRuleIndex() { return RULE_switchLabeledBlock; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7251" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchLabeledBlock(this);</span>
<span class="nc" id="L7252">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchLabeledBlockContext switchLabeledBlock() throws RecognitionException {
<span class="fc" id="L7257">		SwitchLabeledBlockContext _localctx = new SwitchLabeledBlockContext(_ctx, getState());</span>
<span class="fc" id="L7258">		enterRule(_localctx, 170, RULE_switchLabeledBlock);</span>
		try {
<span class="fc" id="L7260">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7262">			setState(1140);</span>
<span class="fc" id="L7263">			switchLabel();</span>
<span class="fc" id="L7264">			setState(1141);</span>
<span class="fc" id="L7265">			match(LAMBDA);</span>
<span class="fc" id="L7266">			setState(1142);</span>
<span class="fc" id="L7267">			block();</span>
			}
		}
<span class="nc" id="L7270">		catch (RecognitionException re) {</span>
<span class="nc" id="L7271">			_localctx.exception = re;</span>
<span class="nc" id="L7272">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7273">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7276">			exitRule();</span>
		}
<span class="fc" id="L7278">		return _localctx;</span>
	}

	public static class SwitchLabeledThrowContext extends ParserRuleContext {
		public SwitchLabelContext switchLabel() {
<span class="fc" id="L7283">			return getRuleContext(SwitchLabelContext.class,0);</span>
		}
<span class="fc" id="L7285">		public TerminalNode LAMBDA() { return getToken(JavaLanguageParser.LAMBDA, 0); }</span>
<span class="fc" id="L7286">		public TerminalNode LITERAL_THROW() { return getToken(JavaLanguageParser.LITERAL_THROW, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L7288">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="fc" id="L7290">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public SwitchLabeledThrowContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7292">			super(parent, invokingState);</span>
<span class="fc" id="L7293">		}</span>
<span class="nc" id="L7294">		@Override public int getRuleIndex() { return RULE_switchLabeledThrow; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7297" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchLabeledThrow(this);</span>
<span class="nc" id="L7298">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchLabeledThrowContext switchLabeledThrow() throws RecognitionException {
<span class="fc" id="L7303">		SwitchLabeledThrowContext _localctx = new SwitchLabeledThrowContext(_ctx, getState());</span>
<span class="fc" id="L7304">		enterRule(_localctx, 172, RULE_switchLabeledThrow);</span>
		try {
<span class="fc" id="L7306">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7308">			setState(1144);</span>
<span class="fc" id="L7309">			switchLabel();</span>
<span class="fc" id="L7310">			setState(1145);</span>
<span class="fc" id="L7311">			match(LAMBDA);</span>
<span class="fc" id="L7312">			setState(1146);</span>
<span class="fc" id="L7313">			match(LITERAL_THROW);</span>
<span class="fc" id="L7314">			setState(1147);</span>
<span class="fc" id="L7315">			expression();</span>
<span class="fc" id="L7316">			setState(1148);</span>
<span class="fc" id="L7317">			match(SEMI);</span>
			}
		}
<span class="nc" id="L7320">		catch (RecognitionException re) {</span>
<span class="nc" id="L7321">			_localctx.exception = re;</span>
<span class="nc" id="L7322">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7323">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7326">			exitRule();</span>
		}
<span class="fc" id="L7328">		return _localctx;</span>
	}

	public static class ElseStatContext extends ParserRuleContext {
<span class="fc" id="L7332">		public TerminalNode LITERAL_ELSE() { return getToken(JavaLanguageParser.LITERAL_ELSE, 0); }</span>
		public StatementContext statement() {
<span class="nc" id="L7334">			return getRuleContext(StatementContext.class,0);</span>
		}
		public ElseStatContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7337">			super(parent, invokingState);</span>
<span class="fc" id="L7338">		}</span>
<span class="nc" id="L7339">		@Override public int getRuleIndex() { return RULE_elseStat; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7342" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitElseStat(this);</span>
<span class="nc" id="L7343">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ElseStatContext elseStat() throws RecognitionException {
<span class="fc" id="L7348">		ElseStatContext _localctx = new ElseStatContext(_ctx, getState());</span>
<span class="fc" id="L7349">		enterRule(_localctx, 174, RULE_elseStat);</span>
		try {
<span class="fc" id="L7351">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7353">			setState(1150);</span>
<span class="fc" id="L7354">			match(LITERAL_ELSE);</span>
<span class="fc" id="L7355">			setState(1151);</span>
<span class="fc" id="L7356">			statement();</span>
			}
		}
<span class="nc" id="L7359">		catch (RecognitionException re) {</span>
<span class="nc" id="L7360">			_localctx.exception = re;</span>
<span class="nc" id="L7361">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7362">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7365">			exitRule();</span>
		}
<span class="fc" id="L7367">		return _localctx;</span>
	}

	public static class CatchClauseContext extends ParserRuleContext {
<span class="fc" id="L7371">		public TerminalNode LITERAL_CATCH() { return getToken(JavaLanguageParser.LITERAL_CATCH, 0); }</span>
<span class="nc" id="L7372">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public CatchParameterContext catchParameter() {
<span class="nc" id="L7374">			return getRuleContext(CatchParameterContext.class,0);</span>
		}
<span class="nc" id="L7376">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public BlockContext block() {
<span class="nc" id="L7378">			return getRuleContext(BlockContext.class,0);</span>
		}
		public CatchClauseContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7381">			super(parent, invokingState);</span>
<span class="fc" id="L7382">		}</span>
<span class="nc" id="L7383">		@Override public int getRuleIndex() { return RULE_catchClause; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7386" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCatchClause(this);</span>
<span class="nc" id="L7387">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CatchClauseContext catchClause() throws RecognitionException {
<span class="fc" id="L7392">		CatchClauseContext _localctx = new CatchClauseContext(_ctx, getState());</span>
<span class="fc" id="L7393">		enterRule(_localctx, 176, RULE_catchClause);</span>
		try {
<span class="fc" id="L7395">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7397">			setState(1153);</span>
<span class="fc" id="L7398">			match(LITERAL_CATCH);</span>
<span class="fc" id="L7399">			setState(1154);</span>
<span class="fc" id="L7400">			match(LPAREN);</span>
<span class="fc" id="L7401">			setState(1155);</span>
<span class="fc" id="L7402">			catchParameter();</span>
<span class="fc" id="L7403">			setState(1156);</span>
<span class="fc" id="L7404">			match(RPAREN);</span>
<span class="fc" id="L7405">			setState(1157);</span>
<span class="fc" id="L7406">			block();</span>
			}
		}
<span class="nc" id="L7409">		catch (RecognitionException re) {</span>
<span class="nc" id="L7410">			_localctx.exception = re;</span>
<span class="nc" id="L7411">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7412">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7415">			exitRule();</span>
		}
<span class="fc" id="L7417">		return _localctx;</span>
	}

	public static class CatchParameterContext extends ParserRuleContext {
		public VariableModifierContext variableModifier;
<span class="fc" id="L7422">		public List&lt;VariableModifierContext&gt; mods = new ArrayList&lt;VariableModifierContext&gt;();</span>
		public CatchTypeContext catchType() {
<span class="nc" id="L7424">			return getRuleContext(CatchTypeContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L7427">			return getRuleContext(IdContext.class,0);</span>
		}
		public List&lt;VariableModifierContext&gt; variableModifier() {
<span class="nc" id="L7430">			return getRuleContexts(VariableModifierContext.class);</span>
		}
		public VariableModifierContext variableModifier(int i) {
<span class="nc" id="L7433">			return getRuleContext(VariableModifierContext.class,i);</span>
		}
		public CatchParameterContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7436">			super(parent, invokingState);</span>
<span class="fc" id="L7437">		}</span>
<span class="nc" id="L7438">		@Override public int getRuleIndex() { return RULE_catchParameter; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7441" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCatchParameter(this);</span>
<span class="nc" id="L7442">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CatchParameterContext catchParameter() throws RecognitionException {
<span class="fc" id="L7447">		CatchParameterContext _localctx = new CatchParameterContext(_ctx, getState());</span>
<span class="fc" id="L7448">		enterRule(_localctx, 178, RULE_catchParameter);</span>
		try {
			int _alt;
<span class="fc" id="L7451">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7453">			setState(1162);</span>
<span class="fc" id="L7454">			_errHandler.sync(this);</span>
<span class="fc" id="L7455">			_alt = getInterpreter().adaptivePredict(_input,130,_ctx);</span>
<span class="pc bpc" id="L7456" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L7457" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L7460">					setState(1159);</span>
<span class="fc" id="L7461">					((CatchParameterContext)_localctx).variableModifier = variableModifier();</span>
<span class="fc" id="L7462">					((CatchParameterContext)_localctx).mods.add(((CatchParameterContext)_localctx).variableModifier);</span>
					}
					} 
				}
<span class="fc" id="L7466">				setState(1164);</span>
<span class="fc" id="L7467">				_errHandler.sync(this);</span>
<span class="fc" id="L7468">				_alt = getInterpreter().adaptivePredict(_input,130,_ctx);</span>
			}
<span class="fc" id="L7470">			setState(1165);</span>
<span class="fc" id="L7471">			catchType();</span>
<span class="fc" id="L7472">			setState(1166);</span>
<span class="fc" id="L7473">			id();</span>
			}
		}
<span class="nc" id="L7476">		catch (RecognitionException re) {</span>
<span class="nc" id="L7477">			_localctx.exception = re;</span>
<span class="nc" id="L7478">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7479">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7482">			exitRule();</span>
		}
<span class="fc" id="L7484">		return _localctx;</span>
	}

	public static class CatchTypeContext extends ParserRuleContext {
		public List&lt;ClassOrInterfaceTypeContext&gt; classOrInterfaceType() {
<span class="nc" id="L7489">			return getRuleContexts(ClassOrInterfaceTypeContext.class);</span>
		}
		public ClassOrInterfaceTypeContext classOrInterfaceType(int i) {
<span class="nc" id="L7492">			return getRuleContext(ClassOrInterfaceTypeContext.class,i);</span>
		}
<span class="nc" id="L7494">		public List&lt;TerminalNode&gt; BOR() { return getTokens(JavaLanguageParser.BOR); }</span>
		public TerminalNode BOR(int i) {
<span class="nc" id="L7496">			return getToken(JavaLanguageParser.BOR, i);</span>
		}
		public CatchTypeContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7499">			super(parent, invokingState);</span>
<span class="fc" id="L7500">		}</span>
<span class="nc" id="L7501">		@Override public int getRuleIndex() { return RULE_catchType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7504" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCatchType(this);</span>
<span class="nc" id="L7505">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CatchTypeContext catchType() throws RecognitionException {
<span class="fc" id="L7510">		CatchTypeContext _localctx = new CatchTypeContext(_ctx, getState());</span>
<span class="fc" id="L7511">		enterRule(_localctx, 180, RULE_catchType);</span>
		int _la;
		try {
<span class="fc" id="L7514">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7516">			setState(1168);</span>
<span class="fc" id="L7517">			classOrInterfaceType(false);</span>
<span class="fc" id="L7518">			setState(1173);</span>
<span class="fc" id="L7519">			_errHandler.sync(this);</span>
<span class="fc" id="L7520">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L7521" title="All 2 branches covered.">			while (_la==BOR) {</span>
				{
				{
<span class="fc" id="L7524">				setState(1169);</span>
<span class="fc" id="L7525">				match(BOR);</span>
<span class="fc" id="L7526">				setState(1170);</span>
<span class="fc" id="L7527">				classOrInterfaceType(false);</span>
				}
				}
<span class="fc" id="L7530">				setState(1175);</span>
<span class="fc" id="L7531">				_errHandler.sync(this);</span>
<span class="fc" id="L7532">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L7536">		catch (RecognitionException re) {</span>
<span class="nc" id="L7537">			_localctx.exception = re;</span>
<span class="nc" id="L7538">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7539">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7542">			exitRule();</span>
		}
<span class="fc" id="L7544">		return _localctx;</span>
	}

	public static class FinallyBlockContext extends ParserRuleContext {
<span class="fc" id="L7548">		public TerminalNode LITERAL_FINALLY() { return getToken(JavaLanguageParser.LITERAL_FINALLY, 0); }</span>
		public BlockContext block() {
<span class="nc" id="L7550">			return getRuleContext(BlockContext.class,0);</span>
		}
		public FinallyBlockContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7553">			super(parent, invokingState);</span>
<span class="fc" id="L7554">		}</span>
<span class="nc" id="L7555">		@Override public int getRuleIndex() { return RULE_finallyBlock; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7558" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFinallyBlock(this);</span>
<span class="nc" id="L7559">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FinallyBlockContext finallyBlock() throws RecognitionException {
<span class="fc" id="L7564">		FinallyBlockContext _localctx = new FinallyBlockContext(_ctx, getState());</span>
<span class="fc" id="L7565">		enterRule(_localctx, 182, RULE_finallyBlock);</span>
		try {
<span class="fc" id="L7567">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7569">			setState(1176);</span>
<span class="fc" id="L7570">			match(LITERAL_FINALLY);</span>
<span class="fc" id="L7571">			setState(1177);</span>
<span class="fc" id="L7572">			block();</span>
			}
		}
<span class="nc" id="L7575">		catch (RecognitionException re) {</span>
<span class="nc" id="L7576">			_localctx.exception = re;</span>
<span class="nc" id="L7577">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7578">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7581">			exitRule();</span>
		}
<span class="fc" id="L7583">		return _localctx;</span>
	}

	public static class ResourceSpecificationContext extends ParserRuleContext {
<span class="nc" id="L7587">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public ResourcesContext resources() {
<span class="nc" id="L7589">			return getRuleContext(ResourcesContext.class,0);</span>
		}
<span class="nc" id="L7591">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="nc" id="L7592">		public TerminalNode SEMI() { return getToken(JavaLanguageParser.SEMI, 0); }</span>
		public ResourceSpecificationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7594">			super(parent, invokingState);</span>
<span class="fc" id="L7595">		}</span>
<span class="nc" id="L7596">		@Override public int getRuleIndex() { return RULE_resourceSpecification; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7599" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitResourceSpecification(this);</span>
<span class="nc" id="L7600">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ResourceSpecificationContext resourceSpecification() throws RecognitionException {
<span class="fc" id="L7605">		ResourceSpecificationContext _localctx = new ResourceSpecificationContext(_ctx, getState());</span>
<span class="fc" id="L7606">		enterRule(_localctx, 184, RULE_resourceSpecification);</span>
		int _la;
		try {
<span class="fc" id="L7609">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7611">			setState(1179);</span>
<span class="fc" id="L7612">			match(LPAREN);</span>
<span class="fc" id="L7613">			setState(1180);</span>
<span class="fc" id="L7614">			resources();</span>
<span class="fc" id="L7615">			setState(1182);</span>
<span class="fc" id="L7616">			_errHandler.sync(this);</span>
<span class="fc" id="L7617">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L7618" title="All 2 branches covered.">			if (_la==SEMI) {</span>
				{
<span class="fc" id="L7620">				setState(1181);</span>
<span class="fc" id="L7621">				match(SEMI);</span>
				}
			}

<span class="fc" id="L7625">			setState(1184);</span>
<span class="fc" id="L7626">			match(RPAREN);</span>
			}
		}
<span class="nc" id="L7629">		catch (RecognitionException re) {</span>
<span class="nc" id="L7630">			_localctx.exception = re;</span>
<span class="nc" id="L7631">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7632">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7635">			exitRule();</span>
		}
<span class="fc" id="L7637">		return _localctx;</span>
	}

	public static class ResourcesContext extends ParserRuleContext {
		public List&lt;ResourceContext&gt; resource() {
<span class="nc" id="L7642">			return getRuleContexts(ResourceContext.class);</span>
		}
		public ResourceContext resource(int i) {
<span class="fc" id="L7645">			return getRuleContext(ResourceContext.class,i);</span>
		}
<span class="nc" id="L7647">		public List&lt;TerminalNode&gt; SEMI() { return getTokens(JavaLanguageParser.SEMI); }</span>
		public TerminalNode SEMI(int i) {
<span class="nc" id="L7649">			return getToken(JavaLanguageParser.SEMI, i);</span>
		}
		public ResourcesContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7652">			super(parent, invokingState);</span>
<span class="fc" id="L7653">		}</span>
<span class="nc" id="L7654">		@Override public int getRuleIndex() { return RULE_resources; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7657" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitResources(this);</span>
<span class="nc" id="L7658">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ResourcesContext resources() throws RecognitionException {
<span class="fc" id="L7663">		ResourcesContext _localctx = new ResourcesContext(_ctx, getState());</span>
<span class="fc" id="L7664">		enterRule(_localctx, 186, RULE_resources);</span>
		try {
			int _alt;
<span class="fc" id="L7667">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7669">			setState(1186);</span>
<span class="fc" id="L7670">			resource();</span>
<span class="fc" id="L7671">			setState(1191);</span>
<span class="fc" id="L7672">			_errHandler.sync(this);</span>
<span class="fc" id="L7673">			_alt = getInterpreter().adaptivePredict(_input,133,_ctx);</span>
<span class="pc bpc" id="L7674" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L7675" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L7678">					setState(1187);</span>
<span class="fc" id="L7679">					match(SEMI);</span>
<span class="fc" id="L7680">					setState(1188);</span>
<span class="fc" id="L7681">					resource();</span>
					}
					} 
				}
<span class="fc" id="L7685">				setState(1193);</span>
<span class="fc" id="L7686">				_errHandler.sync(this);</span>
<span class="fc" id="L7687">				_alt = getInterpreter().adaptivePredict(_input,133,_ctx);</span>
			}
			}
		}
<span class="nc" id="L7691">		catch (RecognitionException re) {</span>
<span class="nc" id="L7692">			_localctx.exception = re;</span>
<span class="nc" id="L7693">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7694">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7697">			exitRule();</span>
		}
<span class="fc" id="L7699">		return _localctx;</span>
	}

	public static class ResourceContext extends ParserRuleContext {
		public ResourceDeclarationContext resourceDeclaration() {
<span class="nc" id="L7704">			return getRuleContext(ResourceDeclarationContext.class,0);</span>
		}
		public VariableAccessContext variableAccess() {
<span class="nc" id="L7707">			return getRuleContext(VariableAccessContext.class,0);</span>
		}
		public ResourceContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7710">			super(parent, invokingState);</span>
<span class="fc" id="L7711">		}</span>
<span class="nc" id="L7712">		@Override public int getRuleIndex() { return RULE_resource; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7715" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitResource(this);</span>
<span class="nc" id="L7716">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ResourceContext resource() throws RecognitionException {
<span class="fc" id="L7721">		ResourceContext _localctx = new ResourceContext(_ctx, getState());</span>
<span class="fc" id="L7722">		enterRule(_localctx, 188, RULE_resource);</span>
		try {
<span class="fc" id="L7724">			setState(1196);</span>
<span class="fc" id="L7725">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L7726" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,134,_ctx) ) {</span>
			case 1:
<span class="fc" id="L7728">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L7730">				setState(1194);</span>
<span class="fc" id="L7731">				resourceDeclaration();</span>
				}
<span class="fc" id="L7733">				break;</span>
			case 2:
<span class="fc" id="L7735">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L7737">				setState(1195);</span>
<span class="fc" id="L7738">				variableAccess();</span>
				}
				break;
			}
		}
<span class="nc" id="L7743">		catch (RecognitionException re) {</span>
<span class="nc" id="L7744">			_localctx.exception = re;</span>
<span class="nc" id="L7745">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7746">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7749">			exitRule();</span>
		}
<span class="fc" id="L7751">		return _localctx;</span>
	}

	public static class ResourceDeclarationContext extends ParserRuleContext {
		public VariableModifierContext variableModifier;
<span class="fc" id="L7756">		public List&lt;VariableModifierContext&gt; mods = new ArrayList&lt;VariableModifierContext&gt;();</span>
		public ClassOrInterfaceTypeContext type;
		public VariableDeclaratorIdContext variableDeclaratorId() {
<span class="fc" id="L7759">			return getRuleContext(VariableDeclaratorIdContext.class,0);</span>
		}
<span class="fc" id="L7761">		public TerminalNode ASSIGN() { return getToken(JavaLanguageParser.ASSIGN, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L7763">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public ClassOrInterfaceTypeContext classOrInterfaceType() {
<span class="nc" id="L7766">			return getRuleContext(ClassOrInterfaceTypeContext.class,0);</span>
		}
		public List&lt;VariableModifierContext&gt; variableModifier() {
<span class="nc" id="L7769">			return getRuleContexts(VariableModifierContext.class);</span>
		}
		public VariableModifierContext variableModifier(int i) {
<span class="nc" id="L7772">			return getRuleContext(VariableModifierContext.class,i);</span>
		}
		public ResourceDeclarationContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7775">			super(parent, invokingState);</span>
<span class="fc" id="L7776">		}</span>
<span class="nc" id="L7777">		@Override public int getRuleIndex() { return RULE_resourceDeclaration; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7780" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitResourceDeclaration(this);</span>
<span class="nc" id="L7781">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ResourceDeclarationContext resourceDeclaration() throws RecognitionException {
<span class="fc" id="L7786">		ResourceDeclarationContext _localctx = new ResourceDeclarationContext(_ctx, getState());</span>
<span class="fc" id="L7787">		enterRule(_localctx, 190, RULE_resourceDeclaration);</span>
		try {
			int _alt;
<span class="fc" id="L7790">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7792">			setState(1201);</span>
<span class="fc" id="L7793">			_errHandler.sync(this);</span>
<span class="fc" id="L7794">			_alt = getInterpreter().adaptivePredict(_input,135,_ctx);</span>
<span class="pc bpc" id="L7795" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L7796" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L7799">					setState(1198);</span>
<span class="fc" id="L7800">					((ResourceDeclarationContext)_localctx).variableModifier = variableModifier();</span>
<span class="fc" id="L7801">					((ResourceDeclarationContext)_localctx).mods.add(((ResourceDeclarationContext)_localctx).variableModifier);</span>
					}
					} 
				}
<span class="fc" id="L7805">				setState(1203);</span>
<span class="fc" id="L7806">				_errHandler.sync(this);</span>
<span class="fc" id="L7807">				_alt = getInterpreter().adaptivePredict(_input,135,_ctx);</span>
			}
<span class="fc" id="L7809">			setState(1204);</span>
<span class="fc" id="L7810">			((ResourceDeclarationContext)_localctx).type = classOrInterfaceType(true);</span>
<span class="fc" id="L7811">			setState(1205);</span>
<span class="fc" id="L7812">			variableDeclaratorId(_localctx.mods, _localctx.type);</span>
<span class="fc" id="L7813">			setState(1206);</span>
<span class="fc" id="L7814">			match(ASSIGN);</span>
<span class="fc" id="L7815">			setState(1207);</span>
<span class="fc" id="L7816">			expression();</span>
			}
		}
<span class="nc" id="L7819">		catch (RecognitionException re) {</span>
<span class="nc" id="L7820">			_localctx.exception = re;</span>
<span class="nc" id="L7821">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7822">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7825">			exitRule();</span>
		}
<span class="fc" id="L7827">		return _localctx;</span>
	}

	public static class VariableAccessContext extends ParserRuleContext {
		public FieldAccessNoIdentContext fieldAccessNoIdent;
<span class="fc" id="L7832">		public List&lt;FieldAccessNoIdentContext&gt; accessList = new ArrayList&lt;FieldAccessNoIdentContext&gt;();</span>
		public IdContext id() {
<span class="fc" id="L7834">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L7836">		public TerminalNode LITERAL_THIS() { return getToken(JavaLanguageParser.LITERAL_THIS, 0); }</span>
		public List&lt;FieldAccessNoIdentContext&gt; fieldAccessNoIdent() {
<span class="nc" id="L7838">			return getRuleContexts(FieldAccessNoIdentContext.class);</span>
		}
		public FieldAccessNoIdentContext fieldAccessNoIdent(int i) {
<span class="nc" id="L7841">			return getRuleContext(FieldAccessNoIdentContext.class,i);</span>
		}
		public VariableAccessContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7844">			super(parent, invokingState);</span>
<span class="fc" id="L7845">		}</span>
<span class="nc" id="L7846">		@Override public int getRuleIndex() { return RULE_variableAccess; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7849" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitVariableAccess(this);</span>
<span class="nc" id="L7850">			else return visitor.visitChildren(this);</span>
		}
	}

	public final VariableAccessContext variableAccess() throws RecognitionException {
<span class="fc" id="L7855">		VariableAccessContext _localctx = new VariableAccessContext(_ctx, getState());</span>
<span class="fc" id="L7856">		enterRule(_localctx, 192, RULE_variableAccess);</span>
		try {
			int _alt;
<span class="fc" id="L7859">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7861">			setState(1212);</span>
<span class="fc" id="L7862">			_errHandler.sync(this);</span>
<span class="fc" id="L7863">			_alt = getInterpreter().adaptivePredict(_input,136,_ctx);</span>
<span class="pc bpc" id="L7864" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L7865" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L7868">					setState(1209);</span>
<span class="fc" id="L7869">					((VariableAccessContext)_localctx).fieldAccessNoIdent = fieldAccessNoIdent();</span>
<span class="fc" id="L7870">					((VariableAccessContext)_localctx).accessList.add(((VariableAccessContext)_localctx).fieldAccessNoIdent);</span>
					}
					} 
				}
<span class="fc" id="L7874">				setState(1214);</span>
<span class="fc" id="L7875">				_errHandler.sync(this);</span>
<span class="fc" id="L7876">				_alt = getInterpreter().adaptivePredict(_input,136,_ctx);</span>
			}
<span class="fc" id="L7878">			setState(1217);</span>
<span class="fc" id="L7879">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L7880" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case IDENT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
				{
<span class="fc" id="L7888">				setState(1215);</span>
<span class="fc" id="L7889">				id();</span>
				}
<span class="fc" id="L7891">				break;</span>
			case LITERAL_THIS:
				{
<span class="fc" id="L7894">				setState(1216);</span>
<span class="fc" id="L7895">				match(LITERAL_THIS);</span>
				}
<span class="fc" id="L7897">				break;</span>
			default:
<span class="nc" id="L7899">				throw new NoViableAltException(this);</span>
			}
			}
		}
<span class="nc" id="L7903">		catch (RecognitionException re) {</span>
<span class="nc" id="L7904">			_localctx.exception = re;</span>
<span class="nc" id="L7905">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7906">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7909">			exitRule();</span>
		}
<span class="fc" id="L7911">		return _localctx;</span>
	}

	public static class FieldAccessNoIdentContext extends ParserRuleContext {
		public ExprContext expr() {
<span class="fc" id="L7916">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L7918">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public FieldAccessNoIdentContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7920">			super(parent, invokingState);</span>
<span class="fc" id="L7921">		}</span>
<span class="nc" id="L7922">		@Override public int getRuleIndex() { return RULE_fieldAccessNoIdent; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L7925" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFieldAccessNoIdent(this);</span>
<span class="nc" id="L7926">			else return visitor.visitChildren(this);</span>
		}
	}

	public final FieldAccessNoIdentContext fieldAccessNoIdent() throws RecognitionException {
<span class="fc" id="L7931">		FieldAccessNoIdentContext _localctx = new FieldAccessNoIdentContext(_ctx, getState());</span>
<span class="fc" id="L7932">		enterRule(_localctx, 194, RULE_fieldAccessNoIdent);</span>
		try {
<span class="fc" id="L7934">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7936">			setState(1219);</span>
<span class="fc" id="L7937">			expr(0);</span>
<span class="fc" id="L7938">			setState(1220);</span>
<span class="fc" id="L7939">			match(DOT);</span>
			}
		}
<span class="nc" id="L7942">		catch (RecognitionException re) {</span>
<span class="nc" id="L7943">			_localctx.exception = re;</span>
<span class="nc" id="L7944">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L7945">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L7948">			exitRule();</span>
		}
<span class="fc" id="L7950">		return _localctx;</span>
	}

	public static class SwitchBlockStatementGroupContext extends ParserRuleContext {
		public BlockStatementContext blockStatement;
<span class="fc" id="L7955">		public List&lt;BlockStatementContext&gt; slists = new ArrayList&lt;BlockStatementContext&gt;();</span>
		public List&lt;SwitchLabelContext&gt; switchLabel() {
<span class="fc" id="L7957">			return getRuleContexts(SwitchLabelContext.class);</span>
		}
		public SwitchLabelContext switchLabel(int i) {
<span class="nc" id="L7960">			return getRuleContext(SwitchLabelContext.class,i);</span>
		}
		public List&lt;BlockStatementContext&gt; blockStatement() {
<span class="nc" id="L7963">			return getRuleContexts(BlockStatementContext.class);</span>
		}
		public BlockStatementContext blockStatement(int i) {
<span class="nc" id="L7966">			return getRuleContext(BlockStatementContext.class,i);</span>
		}
		public SwitchBlockStatementGroupContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L7969">			super(parent, invokingState);</span>
<span class="fc" id="L7970">		}</span>
<span class="nc" id="L7971">		@Override public int getRuleIndex() { return RULE_switchBlockStatementGroup; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L7974" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchBlockStatementGroup(this);</span>
<span class="nc" id="L7975">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchBlockStatementGroupContext switchBlockStatementGroup() throws RecognitionException {
<span class="fc" id="L7980">		SwitchBlockStatementGroupContext _localctx = new SwitchBlockStatementGroupContext(_ctx, getState());</span>
<span class="fc" id="L7981">		enterRule(_localctx, 196, RULE_switchBlockStatementGroup);</span>
		try {
			int _alt;
<span class="fc" id="L7984">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L7986">			setState(1223); </span>
<span class="fc" id="L7987">			_errHandler.sync(this);</span>
<span class="fc" id="L7988">			_alt = 1;</span>
			do {
<span class="pc bpc" id="L7990" title="1 of 2 branches missed.">				switch (_alt) {</span>
				case 1:
					{
					{
<span class="fc" id="L7994">					setState(1222);</span>
<span class="fc" id="L7995">					switchLabel();</span>
					}
					}
<span class="fc" id="L7998">					break;</span>
				default:
<span class="nc" id="L8000">					throw new NoViableAltException(this);</span>
				}
<span class="fc" id="L8002">				setState(1225); </span>
<span class="fc" id="L8003">				_errHandler.sync(this);</span>
<span class="fc" id="L8004">				_alt = getInterpreter().adaptivePredict(_input,138,_ctx);</span>
<span class="pc bpc" id="L8005" title="1 of 4 branches missed.">			} while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );</span>
<span class="fc" id="L8006">			setState(1228); </span>
<span class="fc" id="L8007">			_errHandler.sync(this);</span>
<span class="fc" id="L8008">			_alt = 1;</span>
			do {
<span class="pc bpc" id="L8010" title="1 of 2 branches missed.">				switch (_alt) {</span>
				case 1:
					{
					{
<span class="fc" id="L8014">					setState(1227);</span>
<span class="fc" id="L8015">					((SwitchBlockStatementGroupContext)_localctx).blockStatement = blockStatement();</span>
<span class="fc" id="L8016">					((SwitchBlockStatementGroupContext)_localctx).slists.add(((SwitchBlockStatementGroupContext)_localctx).blockStatement);</span>
					}
					}
<span class="fc" id="L8019">					break;</span>
				default:
<span class="nc" id="L8021">					throw new NoViableAltException(this);</span>
				}
<span class="fc" id="L8023">				setState(1230); </span>
<span class="fc" id="L8024">				_errHandler.sync(this);</span>
<span class="fc" id="L8025">				_alt = getInterpreter().adaptivePredict(_input,139,_ctx);</span>
<span class="pc bpc" id="L8026" title="1 of 4 branches missed.">			} while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );</span>
			}
		}
<span class="nc" id="L8029">		catch (RecognitionException re) {</span>
<span class="nc" id="L8030">			_localctx.exception = re;</span>
<span class="nc" id="L8031">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8032">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8035">			exitRule();</span>
		}
<span class="fc" id="L8037">		return _localctx;</span>
	}

	public static class SwitchLabelContext extends ParserRuleContext {
		public SwitchLabelContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8042">			super(parent, invokingState);</span>
<span class="fc" id="L8043">		}</span>
<span class="nc" id="L8044">		@Override public int getRuleIndex() { return RULE_switchLabel; }</span>
	 
<span class="fc" id="L8046">		public SwitchLabelContext() { }</span>
		public void copyFrom(SwitchLabelContext ctx) {
<span class="fc" id="L8048">			super.copyFrom(ctx);</span>
<span class="fc" id="L8049">		}</span>
	}
	public static class DefaultLabelContext extends SwitchLabelContext {
<span class="fc" id="L8052">		public TerminalNode LITERAL_DEFAULT() { return getToken(JavaLanguageParser.LITERAL_DEFAULT, 0); }</span>
<span class="fc" id="L8053">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
<span class="fc" id="L8054">		public DefaultLabelContext(SwitchLabelContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8057" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitDefaultLabel(this);</span>
<span class="nc" id="L8058">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class CaseLabelContext extends SwitchLabelContext {
<span class="fc" id="L8062">		public TerminalNode LITERAL_CASE() { return getToken(JavaLanguageParser.LITERAL_CASE, 0); }</span>
		public CaseConstantsContext caseConstants() {
<span class="nc" id="L8064">			return getRuleContext(CaseConstantsContext.class,0);</span>
		}
<span class="nc" id="L8066">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
<span class="fc" id="L8067">		public CaseLabelContext(SwitchLabelContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8070" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCaseLabel(this);</span>
<span class="nc" id="L8071">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SwitchLabelContext switchLabel() throws RecognitionException {
<span class="fc" id="L8076">		SwitchLabelContext _localctx = new SwitchLabelContext(_ctx, getState());</span>
<span class="fc" id="L8077">		enterRule(_localctx, 198, RULE_switchLabel);</span>
		try {
<span class="fc" id="L8079">			setState(1241);</span>
<span class="fc" id="L8080">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L8081" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LITERAL_CASE:
<span class="fc" id="L8083">				_localctx = new CaseLabelContext(_localctx);</span>
<span class="fc" id="L8084">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L8086">				setState(1232);</span>
<span class="fc" id="L8087">				match(LITERAL_CASE);</span>
<span class="fc" id="L8088">				setState(1233);</span>
<span class="fc" id="L8089">				caseConstants();</span>
<span class="fc" id="L8090">				setState(1235);</span>
<span class="fc" id="L8091">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L8092" title="All 2 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,140,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L8095">					setState(1234);</span>
<span class="fc" id="L8096">					match(COLON);</span>
					}
					break;
				}
				}
<span class="fc" id="L8101">				break;</span>
			case LITERAL_DEFAULT:
<span class="fc" id="L8103">				_localctx = new DefaultLabelContext(_localctx);</span>
<span class="fc" id="L8104">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L8106">				setState(1237);</span>
<span class="fc" id="L8107">				match(LITERAL_DEFAULT);</span>
<span class="fc" id="L8108">				setState(1239);</span>
<span class="fc" id="L8109">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L8110" title="All 2 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,141,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L8113">					setState(1238);</span>
<span class="fc" id="L8114">					match(COLON);</span>
					}
					break;
				}
				}
<span class="fc" id="L8119">				break;</span>
			default:
<span class="nc" id="L8121">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L8124">		catch (RecognitionException re) {</span>
<span class="nc" id="L8125">			_localctx.exception = re;</span>
<span class="nc" id="L8126">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8127">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8130">			exitRule();</span>
		}
<span class="fc" id="L8132">		return _localctx;</span>
	}

	public static class CaseConstantsContext extends ParserRuleContext {
		public List&lt;CaseConstantContext&gt; caseConstant() {
<span class="nc" id="L8137">			return getRuleContexts(CaseConstantContext.class);</span>
		}
		public CaseConstantContext caseConstant(int i) {
<span class="nc" id="L8140">			return getRuleContext(CaseConstantContext.class,i);</span>
		}
<span class="nc" id="L8142">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L8144">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public CaseConstantsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8147">			super(parent, invokingState);</span>
<span class="fc" id="L8148">		}</span>
<span class="nc" id="L8149">		@Override public int getRuleIndex() { return RULE_caseConstants; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8152" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCaseConstants(this);</span>
<span class="nc" id="L8153">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CaseConstantsContext caseConstants() throws RecognitionException {
<span class="fc" id="L8158">		CaseConstantsContext _localctx = new CaseConstantsContext(_ctx, getState());</span>
<span class="fc" id="L8159">		enterRule(_localctx, 200, RULE_caseConstants);</span>
		try {
			int _alt;
<span class="fc" id="L8162">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L8164">			setState(1243);</span>
<span class="fc" id="L8165">			caseConstant();</span>
<span class="fc" id="L8166">			setState(1248);</span>
<span class="fc" id="L8167">			_errHandler.sync(this);</span>
<span class="fc" id="L8168">			_alt = getInterpreter().adaptivePredict(_input,143,_ctx);</span>
<span class="pc bpc" id="L8169" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L8170" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L8173">					setState(1244);</span>
<span class="fc" id="L8174">					match(COMMA);</span>
<span class="fc" id="L8175">					setState(1245);</span>
<span class="fc" id="L8176">					caseConstant();</span>
					}
					} 
				}
<span class="fc" id="L8180">				setState(1250);</span>
<span class="fc" id="L8181">				_errHandler.sync(this);</span>
<span class="fc" id="L8182">				_alt = getInterpreter().adaptivePredict(_input,143,_ctx);</span>
			}
			}
		}
<span class="nc" id="L8186">		catch (RecognitionException re) {</span>
<span class="nc" id="L8187">			_localctx.exception = re;</span>
<span class="nc" id="L8188">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8189">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8192">			exitRule();</span>
		}
<span class="fc" id="L8194">		return _localctx;</span>
	}

	public static class CaseConstantContext extends ParserRuleContext {
		public PatternContext pattern() {
<span class="nc" id="L8199">			return getRuleContext(PatternContext.class,0);</span>
		}
		public ExpressionContext expression() {
<span class="nc" id="L8202">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L8204">		public TerminalNode LITERAL_DEFAULT() { return getToken(JavaLanguageParser.LITERAL_DEFAULT, 0); }</span>
		public CaseConstantContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8206">			super(parent, invokingState);</span>
<span class="fc" id="L8207">		}</span>
<span class="nc" id="L8208">		@Override public int getRuleIndex() { return RULE_caseConstant; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8211" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCaseConstant(this);</span>
<span class="nc" id="L8212">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CaseConstantContext caseConstant() throws RecognitionException {
<span class="fc" id="L8217">		CaseConstantContext _localctx = new CaseConstantContext(_ctx, getState());</span>
<span class="fc" id="L8218">		enterRule(_localctx, 202, RULE_caseConstant);</span>
		try {
<span class="fc" id="L8220">			setState(1254);</span>
<span class="fc" id="L8221">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L8222" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,144,_ctx) ) {</span>
			case 1:
<span class="fc" id="L8224">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L8226">				setState(1251);</span>
<span class="fc" id="L8227">				pattern();</span>
				}
<span class="fc" id="L8229">				break;</span>
			case 2:
<span class="fc" id="L8231">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L8233">				setState(1252);</span>
<span class="fc" id="L8234">				expression();</span>
				}
<span class="fc" id="L8236">				break;</span>
			case 3:
<span class="fc" id="L8238">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L8240">				setState(1253);</span>
<span class="fc" id="L8241">				match(LITERAL_DEFAULT);</span>
				}
				break;
			}
		}
<span class="nc" id="L8246">		catch (RecognitionException re) {</span>
<span class="nc" id="L8247">			_localctx.exception = re;</span>
<span class="nc" id="L8248">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8249">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8252">			exitRule();</span>
		}
<span class="fc" id="L8254">		return _localctx;</span>
	}

	public static class ForControlContext extends ParserRuleContext {
		public ForControlContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8259">			super(parent, invokingState);</span>
<span class="fc" id="L8260">		}</span>
<span class="nc" id="L8261">		@Override public int getRuleIndex() { return RULE_forControl; }</span>
	 
<span class="fc" id="L8263">		public ForControlContext() { }</span>
		public void copyFrom(ForControlContext ctx) {
<span class="fc" id="L8265">			super.copyFrom(ctx);</span>
<span class="fc" id="L8266">		}</span>
	}
	public static class EnhancedForContext extends ForControlContext {
<span class="fc" id="L8269">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public EnhancedForControlContext enhancedForControl() {
<span class="fc" id="L8271">			return getRuleContext(EnhancedForControlContext.class,0);</span>
		}
<span class="fc" id="L8273">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="fc" id="L8274">		public EnhancedForContext(ForControlContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8277" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnhancedFor(this);</span>
<span class="nc" id="L8278">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ForForContext extends ForControlContext {
		public ExpressionContext forCond;
		public ExpressionListContext forUpdate;
<span class="fc" id="L8284">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="nc" id="L8285">		public List&lt;TerminalNode&gt; SEMI() { return getTokens(JavaLanguageParser.SEMI); }</span>
		public TerminalNode SEMI(int i) {
<span class="fc" id="L8287">			return getToken(JavaLanguageParser.SEMI, i);</span>
		}
<span class="fc" id="L8289">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ForInitContext forInit() {
<span class="fc" id="L8291">			return getRuleContext(ForInitContext.class,0);</span>
		}
		public ExpressionContext expression() {
<span class="nc" id="L8294">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public ExpressionListContext expressionList() {
<span class="nc" id="L8297">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="fc" id="L8299">		public ForForContext(ForControlContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8302" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitForFor(this);</span>
<span class="nc" id="L8303">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ForControlContext forControl() throws RecognitionException {
<span class="fc" id="L8308">		ForControlContext _localctx = new ForControlContext(_ctx, getState());</span>
<span class="fc" id="L8309">		enterRule(_localctx, 204, RULE_forControl);</span>
		int _la;
		try {
<span class="fc" id="L8312">			setState(1273);</span>
<span class="fc" id="L8313">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L8314" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,148,_ctx) ) {</span>
			case 1:
<span class="fc" id="L8316">				_localctx = new EnhancedForContext(_localctx);</span>
<span class="fc" id="L8317">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L8319">				setState(1256);</span>
<span class="fc" id="L8320">				match(LPAREN);</span>
<span class="fc" id="L8321">				setState(1257);</span>
<span class="fc" id="L8322">				enhancedForControl();</span>
<span class="fc" id="L8323">				setState(1258);</span>
<span class="fc" id="L8324">				match(RPAREN);</span>
				}
<span class="fc" id="L8326">				break;</span>
			case 2:
<span class="fc" id="L8328">				_localctx = new ForForContext(_localctx);</span>
<span class="fc" id="L8329">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L8331">				setState(1260);</span>
<span class="fc" id="L8332">				match(LPAREN);</span>
<span class="fc" id="L8333">				setState(1262);</span>
<span class="fc" id="L8334">				_errHandler.sync(this);</span>
<span class="fc" id="L8335">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L8336" title="4 of 12 branches missed.">				if (((((_la - 39)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 39)) &amp; ((1L &lt;&lt; (FINAL - 39)) | (1L &lt;&lt; (ABSTRACT - 39)) | (1L &lt;&lt; (STRICTFP - 39)) | (1L &lt;&lt; (LITERAL_VOID - 39)) | (1L &lt;&lt; (LITERAL_BOOLEAN - 39)) | (1L &lt;&lt; (LITERAL_BYTE - 39)) | (1L &lt;&lt; (LITERAL_CHAR - 39)) | (1L &lt;&lt; (LITERAL_SHORT - 39)) | (1L &lt;&lt; (LITERAL_INT - 39)) | (1L &lt;&lt; (LITERAL_FLOAT - 39)) | (1L &lt;&lt; (LITERAL_LONG - 39)) | (1L &lt;&lt; (LITERAL_DOUBLE - 39)) | (1L &lt;&lt; (IDENT - 39)) | (1L &lt;&lt; (LITERAL_PRIVATE - 39)) | (1L &lt;&lt; (LITERAL_PUBLIC - 39)) | (1L &lt;&lt; (LITERAL_PROTECTED - 39)) | (1L &lt;&lt; (LITERAL_STATIC - 39)) | (1L &lt;&lt; (LITERAL_TRANSIENT - 39)) | (1L &lt;&lt; (LITERAL_NATIVE - 39)) | (1L &lt;&lt; (LITERAL_SYNCHRONIZED - 39)) | (1L &lt;&lt; (LITERAL_VOLATILE - 39)) | (1L &lt;&lt; (LPAREN - 39)) | (1L &lt;&lt; (LITERAL_THIS - 39)) | (1L &lt;&lt; (LITERAL_SUPER - 39)) | (1L &lt;&lt; (LITERAL_SWITCH - 39)) | (1L &lt;&lt; (LITERAL_DEFAULT - 39)))) != 0) || ((((_la - 125)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 125)) &amp; ((1L &lt;&lt; (PLUS - 125)) | (1L &lt;&lt; (MINUS - 125)) | (1L &lt;&lt; (INC - 125)) | (1L &lt;&lt; (DEC - 125)) | (1L &lt;&lt; (BNOT - 125)) | (1L &lt;&lt; (LNOT - 125)) | (1L &lt;&lt; (LITERAL_TRUE - 125)) | (1L &lt;&lt; (LITERAL_FALSE - 125)) | (1L &lt;&lt; (LITERAL_NULL - 125)) | (1L &lt;&lt; (LITERAL_NEW - 125)) | (1L &lt;&lt; (CHAR_LITERAL - 125)) | (1L &lt;&lt; (STRING_LITERAL - 125)) | (1L &lt;&lt; (AT - 125)))) != 0) || ((((_la - 192)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 192)) &amp; ((1L &lt;&lt; (FLOAT_LITERAL - 192)) | (1L &lt;&lt; (DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 192)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 192)) | (1L &lt;&lt; (LITERAL_RECORD - 192)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 192)) | (1L &lt;&lt; (LITERAL_YIELD - 192)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 192)) | (1L &lt;&lt; (LITERAL_SEALED - 192)) | (1L &lt;&lt; (LITERAL_PERMITS - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 192)) | (1L &lt;&lt; (DECIMAL_LITERAL - 192)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 192)) | (1L &lt;&lt; (HEX_LITERAL - 192)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 192)) | (1L &lt;&lt; (OCT_LITERAL - 192)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 192)) | (1L &lt;&lt; (BINARY_LITERAL - 192)))) != 0)) {</span>
					{
<span class="fc" id="L8338">					setState(1261);</span>
<span class="fc" id="L8339">					forInit();</span>
					}
				}

<span class="fc" id="L8343">				setState(1264);</span>
<span class="fc" id="L8344">				match(SEMI);</span>
<span class="fc" id="L8345">				setState(1266);</span>
<span class="fc" id="L8346">				_errHandler.sync(this);</span>
<span class="fc" id="L8347">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L8348" title="4 of 12 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
					{
<span class="fc" id="L8350">					setState(1265);</span>
<span class="fc" id="L8351">					((ForForContext)_localctx).forCond = expression();</span>
					}
				}

<span class="fc" id="L8355">				setState(1268);</span>
<span class="fc" id="L8356">				match(SEMI);</span>
<span class="fc" id="L8357">				setState(1270);</span>
<span class="fc" id="L8358">				_errHandler.sync(this);</span>
<span class="fc" id="L8359">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L8360" title="5 of 12 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
					{
<span class="fc" id="L8362">					setState(1269);</span>
<span class="fc" id="L8363">					((ForForContext)_localctx).forUpdate = expressionList();</span>
					}
				}

<span class="fc" id="L8367">				setState(1272);</span>
<span class="fc" id="L8368">				match(RPAREN);</span>
				}
				break;
			}
		}
<span class="nc" id="L8373">		catch (RecognitionException re) {</span>
<span class="nc" id="L8374">			_localctx.exception = re;</span>
<span class="nc" id="L8375">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8376">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8379">			exitRule();</span>
		}
<span class="fc" id="L8381">		return _localctx;</span>
	}

	public static class ForInitContext extends ParserRuleContext {
		public LocalVariableDeclarationContext localVariableDeclaration() {
<span class="nc" id="L8386">			return getRuleContext(LocalVariableDeclarationContext.class,0);</span>
		}
		public ExpressionListContext expressionList() {
<span class="nc" id="L8389">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
		public ForInitContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8392">			super(parent, invokingState);</span>
<span class="fc" id="L8393">		}</span>
<span class="nc" id="L8394">		@Override public int getRuleIndex() { return RULE_forInit; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8397" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitForInit(this);</span>
<span class="nc" id="L8398">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ForInitContext forInit() throws RecognitionException {
<span class="fc" id="L8403">		ForInitContext _localctx = new ForInitContext(_ctx, getState());</span>
<span class="fc" id="L8404">		enterRule(_localctx, 206, RULE_forInit);</span>
		try {
<span class="fc" id="L8406">			setState(1277);</span>
<span class="fc" id="L8407">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L8408" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,149,_ctx) ) {</span>
			case 1:
<span class="fc" id="L8410">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L8412">				setState(1275);</span>
<span class="fc" id="L8413">				localVariableDeclaration();</span>
				}
<span class="fc" id="L8415">				break;</span>
			case 2:
<span class="fc" id="L8417">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L8419">				setState(1276);</span>
<span class="fc" id="L8420">				expressionList();</span>
				}
				break;
			}
		}
<span class="nc" id="L8425">		catch (RecognitionException re) {</span>
<span class="nc" id="L8426">			_localctx.exception = re;</span>
<span class="nc" id="L8427">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8428">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8431">			exitRule();</span>
		}
<span class="fc" id="L8433">		return _localctx;</span>
	}

	public static class EnhancedForControlContext extends ParserRuleContext {
		public VariableModifierContext variableModifier;
<span class="fc" id="L8438">		public List&lt;VariableModifierContext&gt; mods = new ArrayList&lt;VariableModifierContext&gt;();</span>
		public TypeTypeContext type;
		public VariableDeclaratorIdContext variableDeclaratorId() {
<span class="fc" id="L8441">			return getRuleContext(VariableDeclaratorIdContext.class,0);</span>
		}
<span class="fc" id="L8443">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L8445">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L8448">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public List&lt;VariableModifierContext&gt; variableModifier() {
<span class="nc" id="L8451">			return getRuleContexts(VariableModifierContext.class);</span>
		}
		public VariableModifierContext variableModifier(int i) {
<span class="nc" id="L8454">			return getRuleContext(VariableModifierContext.class,i);</span>
		}
		public EnhancedForControlContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8457">			super(parent, invokingState);</span>
<span class="fc" id="L8458">		}</span>
<span class="nc" id="L8459">		@Override public int getRuleIndex() { return RULE_enhancedForControl; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8462" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitEnhancedForControl(this);</span>
<span class="nc" id="L8463">			else return visitor.visitChildren(this);</span>
		}
	}

	public final EnhancedForControlContext enhancedForControl() throws RecognitionException {
<span class="fc" id="L8468">		EnhancedForControlContext _localctx = new EnhancedForControlContext(_ctx, getState());</span>
<span class="fc" id="L8469">		enterRule(_localctx, 208, RULE_enhancedForControl);</span>
		try {
			int _alt;
<span class="fc" id="L8472">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L8474">			setState(1282);</span>
<span class="fc" id="L8475">			_errHandler.sync(this);</span>
<span class="fc" id="L8476">			_alt = getInterpreter().adaptivePredict(_input,150,_ctx);</span>
<span class="pc bpc" id="L8477" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L8478" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L8481">					setState(1279);</span>
<span class="fc" id="L8482">					((EnhancedForControlContext)_localctx).variableModifier = variableModifier();</span>
<span class="fc" id="L8483">					((EnhancedForControlContext)_localctx).mods.add(((EnhancedForControlContext)_localctx).variableModifier);</span>
					}
					} 
				}
<span class="fc" id="L8487">				setState(1284);</span>
<span class="fc" id="L8488">				_errHandler.sync(this);</span>
<span class="fc" id="L8489">				_alt = getInterpreter().adaptivePredict(_input,150,_ctx);</span>
			}
<span class="fc" id="L8491">			setState(1285);</span>
<span class="fc" id="L8492">			((EnhancedForControlContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L8493">			setState(1286);</span>
<span class="fc" id="L8494">			variableDeclaratorId(_localctx.mods, _localctx.type);</span>
<span class="fc" id="L8495">			setState(1287);</span>
<span class="fc" id="L8496">			match(COLON);</span>
<span class="fc" id="L8497">			setState(1288);</span>
<span class="fc" id="L8498">			expression();</span>
			}
		}
<span class="nc" id="L8501">		catch (RecognitionException re) {</span>
<span class="nc" id="L8502">			_localctx.exception = re;</span>
<span class="nc" id="L8503">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8504">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8507">			exitRule();</span>
		}
<span class="fc" id="L8509">		return _localctx;</span>
	}

	public static class ParExpressionContext extends ParserRuleContext {
<span class="nc" id="L8513">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public ExpressionContext expression() {
<span class="nc" id="L8515">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L8517">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ParExpressionContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8519">			super(parent, invokingState);</span>
<span class="fc" id="L8520">		}</span>
<span class="nc" id="L8521">		@Override public int getRuleIndex() { return RULE_parExpression; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8524" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitParExpression(this);</span>
<span class="nc" id="L8525">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ParExpressionContext parExpression() throws RecognitionException {
<span class="fc" id="L8530">		ParExpressionContext _localctx = new ParExpressionContext(_ctx, getState());</span>
<span class="fc" id="L8531">		enterRule(_localctx, 210, RULE_parExpression);</span>
		try {
<span class="fc" id="L8533">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L8535">			setState(1290);</span>
<span class="fc" id="L8536">			match(LPAREN);</span>
<span class="fc" id="L8537">			setState(1291);</span>
<span class="fc" id="L8538">			expression();</span>
<span class="fc" id="L8539">			setState(1292);</span>
<span class="fc" id="L8540">			match(RPAREN);</span>
			}
		}
<span class="nc" id="L8543">		catch (RecognitionException re) {</span>
<span class="nc" id="L8544">			_localctx.exception = re;</span>
<span class="nc" id="L8545">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8546">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8549">			exitRule();</span>
		}
<span class="fc" id="L8551">		return _localctx;</span>
	}

	public static class ExpressionListContext extends ParserRuleContext {
		public ExpressionContext startExp;
		public List&lt;ExpressionContext&gt; expression() {
<span class="nc" id="L8557">			return getRuleContexts(ExpressionContext.class);</span>
		}
		public ExpressionContext expression(int i) {
<span class="nc" id="L8560">			return getRuleContext(ExpressionContext.class,i);</span>
		}
<span class="nc" id="L8562">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L8564">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8567">			super(parent, invokingState);</span>
<span class="fc" id="L8568">		}</span>
<span class="nc" id="L8569">		@Override public int getRuleIndex() { return RULE_expressionList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8572" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitExpressionList(this);</span>
<span class="nc" id="L8573">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ExpressionListContext expressionList() throws RecognitionException {
<span class="fc" id="L8578">		ExpressionListContext _localctx = new ExpressionListContext(_ctx, getState());</span>
<span class="fc" id="L8579">		enterRule(_localctx, 212, RULE_expressionList);</span>
		int _la;
		try {
<span class="fc" id="L8582">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L8584">			setState(1294);</span>
<span class="fc" id="L8585">			((ExpressionListContext)_localctx).startExp = expression();</span>
<span class="fc" id="L8586">			setState(1299);</span>
<span class="fc" id="L8587">			_errHandler.sync(this);</span>
<span class="fc" id="L8588">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L8589" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L8592">				setState(1295);</span>
<span class="fc" id="L8593">				match(COMMA);</span>
<span class="fc" id="L8594">				setState(1296);</span>
<span class="fc" id="L8595">				expression();</span>
				}
				}
<span class="fc" id="L8598">				setState(1301);</span>
<span class="fc" id="L8599">				_errHandler.sync(this);</span>
<span class="fc" id="L8600">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L8604">		catch (RecognitionException re) {</span>
<span class="nc" id="L8605">			_localctx.exception = re;</span>
<span class="nc" id="L8606">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8607">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8610">			exitRule();</span>
		}
<span class="fc" id="L8612">		return _localctx;</span>
	}

	public static class ExpressionContext extends ParserRuleContext {
		public ExprContext expr() {
<span class="fc" id="L8617">			return getRuleContext(ExprContext.class,0);</span>
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8620">			super(parent, invokingState);</span>
<span class="fc" id="L8621">		}</span>
<span class="nc" id="L8622">		@Override public int getRuleIndex() { return RULE_expression; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8625" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitExpression(this);</span>
<span class="nc" id="L8626">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
<span class="fc" id="L8631">		ExpressionContext _localctx = new ExpressionContext(_ctx, getState());</span>
<span class="fc" id="L8632">		enterRule(_localctx, 214, RULE_expression);</span>
		try {
<span class="fc" id="L8634">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L8636">			setState(1302);</span>
<span class="fc" id="L8637">			expr(0);</span>
			}
		}
<span class="nc" id="L8640">		catch (RecognitionException re) {</span>
<span class="nc" id="L8641">			_localctx.exception = re;</span>
<span class="nc" id="L8642">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L8643">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L8646">			exitRule();</span>
		}
<span class="fc" id="L8648">		return _localctx;</span>
	}

	public static class ExprContext extends ParserRuleContext {
		public ExprContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L8653">			super(parent, invokingState);</span>
<span class="fc" id="L8654">		}</span>
<span class="nc" id="L8655">		@Override public int getRuleIndex() { return RULE_expr; }</span>
	 
<span class="fc" id="L8657">		public ExprContext() { }</span>
		public void copyFrom(ExprContext ctx) {
<span class="fc" id="L8659">			super.copyFrom(ctx);</span>
<span class="fc" id="L8660">		}</span>
	}
	public static class RefOpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8665">			return getRuleContext(ExprContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L8668">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="nc" id="L8670">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L8671">		public RefOpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8674" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitRefOp(this);</span>
<span class="nc" id="L8675">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SuperExpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8681">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8683">		public TerminalNode LITERAL_SUPER() { return getToken(JavaLanguageParser.LITERAL_SUPER, 0); }</span>
<span class="nc" id="L8684">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public NonWildcardTypeArgumentsContext nonWildcardTypeArguments() {
<span class="nc" id="L8686">			return getRuleContext(NonWildcardTypeArgumentsContext.class,0);</span>
		}
		public SuperSuffixContext superSuffix() {
<span class="fc" id="L8689">			return getRuleContext(SuperSuffixContext.class,0);</span>
		}
<span class="fc" id="L8691">		public SuperExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8694" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSuperExp(this);</span>
<span class="nc" id="L8695">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class InstanceOfExpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8701">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8703">		public TerminalNode LITERAL_INSTANCEOF() { return getToken(JavaLanguageParser.LITERAL_INSTANCEOF, 0); }</span>
		public PrimaryPatternContext primaryPattern() {
<span class="nc" id="L8705">			return getRuleContext(PrimaryPatternContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L8708">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
<span class="fc" id="L8710">		public InstanceOfExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8713" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInstanceOfExp(this);</span>
<span class="nc" id="L8714">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class BitShiftContext extends ExprContext {
		public List&lt;ExprContext&gt; expr() {
<span class="nc" id="L8719">			return getRuleContexts(ExprContext.class);</span>
		}
		public ExprContext expr(int i) {
<span class="fc" id="L8722">			return getRuleContext(ExprContext.class,i);</span>
		}
<span class="fc" id="L8724">		public List&lt;TerminalNode&gt; LT() { return getTokens(JavaLanguageParser.LT); }</span>
		public TerminalNode LT(int i) {
<span class="fc" id="L8726">			return getToken(JavaLanguageParser.LT, i);</span>
		}
<span class="fc" id="L8728">		public List&lt;TerminalNode&gt; GT() { return getTokens(JavaLanguageParser.GT); }</span>
		public TerminalNode GT(int i) {
<span class="fc" id="L8730">			return getToken(JavaLanguageParser.GT, i);</span>
		}
<span class="fc" id="L8732">		public BitShiftContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8735" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBitShift(this);</span>
<span class="nc" id="L8736">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class NewExpContext extends ExprContext {
<span class="fc" id="L8740">		public TerminalNode LITERAL_NEW() { return getToken(JavaLanguageParser.LITERAL_NEW, 0); }</span>
		public CreatorContext creator() {
<span class="nc" id="L8742">			return getRuleContext(CreatorContext.class,0);</span>
		}
<span class="fc" id="L8744">		public NewExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8747" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitNewExp(this);</span>
<span class="nc" id="L8748">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class PrefixContext extends ExprContext {
		public Token prefix;
		public ExprContext expr() {
<span class="fc" id="L8754">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="nc" id="L8756">		public TerminalNode PLUS() { return getToken(JavaLanguageParser.PLUS, 0); }</span>
<span class="nc" id="L8757">		public TerminalNode MINUS() { return getToken(JavaLanguageParser.MINUS, 0); }</span>
<span class="nc" id="L8758">		public TerminalNode INC() { return getToken(JavaLanguageParser.INC, 0); }</span>
<span class="nc" id="L8759">		public TerminalNode DEC() { return getToken(JavaLanguageParser.DEC, 0); }</span>
<span class="nc" id="L8760">		public TerminalNode BNOT() { return getToken(JavaLanguageParser.BNOT, 0); }</span>
<span class="nc" id="L8761">		public TerminalNode LNOT() { return getToken(JavaLanguageParser.LNOT, 0); }</span>
<span class="fc" id="L8762">		public PrefixContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8765" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPrefix(this);</span>
<span class="nc" id="L8766">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class CastExpContext extends ExprContext {
<span class="fc" id="L8770">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public TypeCastParametersContext typeCastParameters() {
<span class="nc" id="L8772">			return getRuleContext(TypeCastParametersContext.class,0);</span>
		}
<span class="nc" id="L8774">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ExprContext expr() {
<span class="nc" id="L8776">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8778">		public CastExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8781" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCastExp(this);</span>
<span class="nc" id="L8782">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class IndexOpContext extends ExprContext {
		public List&lt;ExprContext&gt; expr() {
<span class="nc" id="L8787">			return getRuleContexts(ExprContext.class);</span>
		}
		public ExprContext expr(int i) {
<span class="fc" id="L8790">			return getRuleContext(ExprContext.class,i);</span>
		}
<span class="fc" id="L8792">		public TerminalNode LBRACK() { return getToken(JavaLanguageParser.LBRACK, 0); }</span>
<span class="fc" id="L8793">		public TerminalNode RBRACK() { return getToken(JavaLanguageParser.RBRACK, 0); }</span>
<span class="fc" id="L8794">		public IndexOpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8797" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitIndexOp(this);</span>
<span class="nc" id="L8798">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class InvOpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8804">			return getRuleContext(ExprContext.class,0);</span>
		}
		public NonWildcardTypeArgumentsContext nonWildcardTypeArguments() {
<span class="fc" id="L8807">			return getRuleContext(NonWildcardTypeArgumentsContext.class,0);</span>
		}
		public IdContext id() {
<span class="fc" id="L8810">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L8812">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L8813">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="nc" id="L8814">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="fc" id="L8816">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="fc" id="L8818">		public InvOpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8821" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInvOp(this);</span>
<span class="nc" id="L8822">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class InitExpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8828">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8830">		public TerminalNode LITERAL_NEW() { return getToken(JavaLanguageParser.LITERAL_NEW, 0); }</span>
		public InnerCreatorContext innerCreator() {
<span class="fc" id="L8832">			return getRuleContext(InnerCreatorContext.class,0);</span>
		}
<span class="nc" id="L8834">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public NonWildcardTypeArgumentsContext nonWildcardTypeArguments() {
<span class="fc" id="L8836">			return getRuleContext(NonWildcardTypeArgumentsContext.class,0);</span>
		}
<span class="fc" id="L8838">		public InitExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8841" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInitExp(this);</span>
<span class="nc" id="L8842">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SimpleMethodCallContext extends ExprContext {
		public IdContext id() {
<span class="fc" id="L8847">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L8849">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L8850">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="fc" id="L8852">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="fc" id="L8854">		public SimpleMethodCallContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8857" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSimpleMethodCall(this);</span>
<span class="nc" id="L8858">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class LambdaExpContext extends ExprContext {
		public LambdaExpressionContext lambdaExpression() {
<span class="nc" id="L8863">			return getRuleContext(LambdaExpressionContext.class,0);</span>
		}
<span class="fc" id="L8865">		public LambdaExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8868" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLambdaExp(this);</span>
<span class="nc" id="L8869">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ThisExpContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8875">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8877">		public TerminalNode LITERAL_THIS() { return getToken(JavaLanguageParser.LITERAL_THIS, 0); }</span>
<span class="nc" id="L8878">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L8879">		public ThisExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8882" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitThisExp(this);</span>
<span class="nc" id="L8883">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class PrimaryExpContext extends ExprContext {
		public PrimaryContext primary() {
<span class="nc" id="L8888">			return getRuleContext(PrimaryContext.class,0);</span>
		}
<span class="fc" id="L8890">		public PrimaryExpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8893" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPrimaryExp(this);</span>
<span class="nc" id="L8894">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class PostfixContext extends ExprContext {
		public Token postfix;
		public ExprContext expr() {
<span class="fc" id="L8900">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="nc" id="L8902">		public TerminalNode INC() { return getToken(JavaLanguageParser.INC, 0); }</span>
<span class="nc" id="L8903">		public TerminalNode DEC() { return getToken(JavaLanguageParser.DEC, 0); }</span>
<span class="fc" id="L8904">		public PostfixContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8907" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPostfix(this);</span>
<span class="nc" id="L8908">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class MethodRefContext extends ExprContext {
		public TypeTypeContext typeType() {
<span class="nc" id="L8913">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
<span class="fc" id="L8915">		public TerminalNode DOUBLE_COLON() { return getToken(JavaLanguageParser.DOUBLE_COLON, 0); }</span>
		public IdContext id() {
<span class="nc" id="L8917">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="nc" id="L8919">		public TerminalNode LITERAL_NEW() { return getToken(JavaLanguageParser.LITERAL_NEW, 0); }</span>
		public TypeArgumentsContext typeArguments() {
<span class="nc" id="L8921">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
		public ClassTypeContext classType() {
<span class="nc" id="L8924">			return getRuleContext(ClassTypeContext.class,0);</span>
		}
		public ExprContext expr() {
<span class="nc" id="L8927">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="fc" id="L8929">		public MethodRefContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8932" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMethodRef(this);</span>
<span class="nc" id="L8933">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class TernaryOpContext extends ExprContext {
		public Token bop;
		public List&lt;ExprContext&gt; expr() {
<span class="nc" id="L8939">			return getRuleContexts(ExprContext.class);</span>
		}
		public ExprContext expr(int i) {
<span class="nc" id="L8942">			return getRuleContext(ExprContext.class,i);</span>
		}
<span class="nc" id="L8944">		public TerminalNode COLON() { return getToken(JavaLanguageParser.COLON, 0); }</span>
<span class="fc" id="L8945">		public TerminalNode QUESTION() { return getToken(JavaLanguageParser.QUESTION, 0); }</span>
<span class="fc" id="L8946">		public TernaryOpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8949" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTernaryOp(this);</span>
<span class="nc" id="L8950">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class BinOpContext extends ExprContext {
		public Token bop;
		public List&lt;ExprContext&gt; expr() {
<span class="nc" id="L8956">			return getRuleContexts(ExprContext.class);</span>
		}
		public ExprContext expr(int i) {
<span class="fc" id="L8959">			return getRuleContext(ExprContext.class,i);</span>
		}
<span class="nc" id="L8961">		public TerminalNode STAR() { return getToken(JavaLanguageParser.STAR, 0); }</span>
<span class="nc" id="L8962">		public TerminalNode DIV() { return getToken(JavaLanguageParser.DIV, 0); }</span>
<span class="nc" id="L8963">		public TerminalNode MOD() { return getToken(JavaLanguageParser.MOD, 0); }</span>
<span class="nc" id="L8964">		public TerminalNode PLUS() { return getToken(JavaLanguageParser.PLUS, 0); }</span>
<span class="nc" id="L8965">		public TerminalNode MINUS() { return getToken(JavaLanguageParser.MINUS, 0); }</span>
<span class="nc" id="L8966">		public TerminalNode LE() { return getToken(JavaLanguageParser.LE, 0); }</span>
<span class="nc" id="L8967">		public TerminalNode GE() { return getToken(JavaLanguageParser.GE, 0); }</span>
<span class="nc" id="L8968">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
<span class="nc" id="L8969">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
<span class="nc" id="L8970">		public TerminalNode EQUAL() { return getToken(JavaLanguageParser.EQUAL, 0); }</span>
<span class="nc" id="L8971">		public TerminalNode NOT_EQUAL() { return getToken(JavaLanguageParser.NOT_EQUAL, 0); }</span>
<span class="nc" id="L8972">		public TerminalNode BAND() { return getToken(JavaLanguageParser.BAND, 0); }</span>
<span class="nc" id="L8973">		public TerminalNode BXOR() { return getToken(JavaLanguageParser.BXOR, 0); }</span>
<span class="nc" id="L8974">		public TerminalNode BOR() { return getToken(JavaLanguageParser.BOR, 0); }</span>
<span class="nc" id="L8975">		public TerminalNode LAND() { return getToken(JavaLanguageParser.LAND, 0); }</span>
<span class="nc" id="L8976">		public TerminalNode LOR() { return getToken(JavaLanguageParser.LOR, 0); }</span>
<span class="nc" id="L8977">		public TerminalNode ASSIGN() { return getToken(JavaLanguageParser.ASSIGN, 0); }</span>
<span class="nc" id="L8978">		public TerminalNode PLUS_ASSIGN() { return getToken(JavaLanguageParser.PLUS_ASSIGN, 0); }</span>
<span class="nc" id="L8979">		public TerminalNode MINUS_ASSIGN() { return getToken(JavaLanguageParser.MINUS_ASSIGN, 0); }</span>
<span class="nc" id="L8980">		public TerminalNode STAR_ASSIGN() { return getToken(JavaLanguageParser.STAR_ASSIGN, 0); }</span>
<span class="nc" id="L8981">		public TerminalNode DIV_ASSIGN() { return getToken(JavaLanguageParser.DIV_ASSIGN, 0); }</span>
<span class="nc" id="L8982">		public TerminalNode BAND_ASSIGN() { return getToken(JavaLanguageParser.BAND_ASSIGN, 0); }</span>
<span class="nc" id="L8983">		public TerminalNode BOR_ASSIGN() { return getToken(JavaLanguageParser.BOR_ASSIGN, 0); }</span>
<span class="nc" id="L8984">		public TerminalNode BXOR_ASSIGN() { return getToken(JavaLanguageParser.BXOR_ASSIGN, 0); }</span>
<span class="nc" id="L8985">		public TerminalNode SR_ASSIGN() { return getToken(JavaLanguageParser.SR_ASSIGN, 0); }</span>
<span class="nc" id="L8986">		public TerminalNode BSR_ASSIGN() { return getToken(JavaLanguageParser.BSR_ASSIGN, 0); }</span>
<span class="nc" id="L8987">		public TerminalNode SL_ASSIGN() { return getToken(JavaLanguageParser.SL_ASSIGN, 0); }</span>
<span class="nc" id="L8988">		public TerminalNode MOD_ASSIGN() { return getToken(JavaLanguageParser.MOD_ASSIGN, 0); }</span>
<span class="fc" id="L8989">		public BinOpContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L8992" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBinOp(this);</span>
<span class="nc" id="L8993">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class MethodCallContext extends ExprContext {
		public Token bop;
		public ExprContext expr() {
<span class="fc" id="L8999">			return getRuleContext(ExprContext.class,0);</span>
		}
		public IdContext id() {
<span class="fc" id="L9002">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L9004">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L9005">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="fc" id="L9006">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="fc" id="L9008">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="fc" id="L9010">		public MethodCallContext(ExprContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9013" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMethodCall(this);</span>
<span class="nc" id="L9014">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ExprContext expr() throws RecognitionException {
<span class="nc" id="L9019">		return expr(0);</span>
	}

	private ExprContext expr(int _p) throws RecognitionException {
<span class="fc" id="L9023">		ParserRuleContext _parentctx = _ctx;</span>
<span class="fc" id="L9024">		int _parentState = getState();</span>
<span class="fc" id="L9025">		ExprContext _localctx = new ExprContext(_ctx, _parentState);</span>
<span class="fc" id="L9026">		ExprContext _prevctx = _localctx;</span>
<span class="fc" id="L9027">		int _startState = 216;</span>
<span class="fc" id="L9028">		enterRecursionRule(_localctx, 216, RULE_expr, _p);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L9032">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L9034">			setState(1341);</span>
<span class="fc" id="L9035">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L9036" title="2 of 10 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,156,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L9039">				_localctx = new PrimaryExpContext(_localctx);</span>
<span class="fc" id="L9040">				_ctx = _localctx;</span>
<span class="fc" id="L9041">				_prevctx = _localctx;</span>

<span class="fc" id="L9043">				setState(1305);</span>
<span class="fc" id="L9044">				primary();</span>
				}
<span class="fc" id="L9046">				break;</span>
			case 2:
				{
<span class="fc" id="L9049">				_localctx = new SimpleMethodCallContext(_localctx);</span>
<span class="fc" id="L9050">				_ctx = _localctx;</span>
<span class="fc" id="L9051">				_prevctx = _localctx;</span>
<span class="fc" id="L9052">				setState(1306);</span>
<span class="fc" id="L9053">				id();</span>
<span class="fc" id="L9054">				setState(1307);</span>
<span class="fc" id="L9055">				match(LPAREN);</span>
<span class="fc" id="L9056">				setState(1309);</span>
<span class="fc" id="L9057">				_errHandler.sync(this);</span>
<span class="fc" id="L9058">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L9059" title="2 of 12 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
					{
<span class="fc" id="L9061">					setState(1308);</span>
<span class="fc" id="L9062">					expressionList();</span>
					}
				}

<span class="fc" id="L9066">				setState(1311);</span>
<span class="fc" id="L9067">				match(RPAREN);</span>
				}
<span class="fc" id="L9069">				break;</span>
			case 3:
				{
<span class="fc" id="L9072">				_localctx = new NewExpContext(_localctx);</span>
<span class="fc" id="L9073">				_ctx = _localctx;</span>
<span class="fc" id="L9074">				_prevctx = _localctx;</span>
<span class="fc" id="L9075">				setState(1313);</span>
<span class="fc" id="L9076">				match(LITERAL_NEW);</span>
<span class="fc" id="L9077">				setState(1314);</span>
<span class="fc" id="L9078">				creator();</span>
				}
<span class="fc" id="L9080">				break;</span>
			case 4:
				{
<span class="fc" id="L9083">				_localctx = new PrefixContext(_localctx);</span>
<span class="fc" id="L9084">				_ctx = _localctx;</span>
<span class="fc" id="L9085">				_prevctx = _localctx;</span>
<span class="fc" id="L9086">				setState(1315);</span>
<span class="fc" id="L9087">				((PrefixContext)_localctx).prefix = _input.LT(1);</span>
<span class="fc" id="L9088">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L9089" title="2 of 4 branches missed.">				if ( !(((((_la - 125)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 125)) &amp; ((1L &lt;&lt; (PLUS - 125)) | (1L &lt;&lt; (MINUS - 125)) | (1L &lt;&lt; (INC - 125)) | (1L &lt;&lt; (DEC - 125)))) != 0)) ) {</span>
<span class="nc" id="L9090">					((PrefixContext)_localctx).prefix = (Token)_errHandler.recoverInline(this);</span>
				}
				else {
<span class="pc bpc" id="L9093" title="1 of 2 branches missed.">					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9094">					_errHandler.reportMatch(this);</span>
<span class="fc" id="L9095">					consume();</span>
				}
<span class="fc" id="L9097">				setState(1316);</span>
<span class="fc" id="L9098">				expr(20);</span>
				}
<span class="fc" id="L9100">				break;</span>
			case 5:
				{
<span class="fc" id="L9103">				_localctx = new PrefixContext(_localctx);</span>
<span class="fc" id="L9104">				_ctx = _localctx;</span>
<span class="fc" id="L9105">				_prevctx = _localctx;</span>
<span class="fc" id="L9106">				setState(1317);</span>
<span class="fc" id="L9107">				((PrefixContext)_localctx).prefix = _input.LT(1);</span>
<span class="fc" id="L9108">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L9109" title="1 of 4 branches missed.">				if ( !(_la==BNOT || _la==LNOT) ) {</span>
<span class="nc" id="L9110">					((PrefixContext)_localctx).prefix = (Token)_errHandler.recoverInline(this);</span>
				}
				else {
<span class="pc bpc" id="L9113" title="1 of 2 branches missed.">					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9114">					_errHandler.reportMatch(this);</span>
<span class="fc" id="L9115">					consume();</span>
				}
<span class="fc" id="L9117">				setState(1318);</span>
<span class="fc" id="L9118">				expr(19);</span>
				}
<span class="fc" id="L9120">				break;</span>
			case 6:
				{
<span class="fc" id="L9123">				_localctx = new MethodRefContext(_localctx);</span>
<span class="fc" id="L9124">				_ctx = _localctx;</span>
<span class="fc" id="L9125">				_prevctx = _localctx;</span>
<span class="fc" id="L9126">				setState(1319);</span>
<span class="fc" id="L9127">				typeType(false);</span>
<span class="fc" id="L9128">				setState(1320);</span>
<span class="fc" id="L9129">				match(DOUBLE_COLON);</span>
<span class="fc" id="L9130">				setState(1322);</span>
<span class="fc" id="L9131">				_errHandler.sync(this);</span>
<span class="fc" id="L9132">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L9133" title="All 2 branches covered.">				if (_la==LT) {</span>
					{
<span class="fc" id="L9135">					setState(1321);</span>
<span class="fc" id="L9136">					typeArguments();</span>
					}
				}

<span class="fc" id="L9140">				setState(1326);</span>
<span class="fc" id="L9141">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L9142" title="1 of 3 branches missed.">				switch (_input.LA(1)) {</span>
				case IDENT:
				case LITERAL_RECORD:
				case LITERAL_YIELD:
				case LITERAL_NON_SEALED:
				case LITERAL_SEALED:
				case LITERAL_PERMITS:
					{
<span class="fc" id="L9150">					setState(1324);</span>
<span class="fc" id="L9151">					id();</span>
					}
<span class="fc" id="L9153">					break;</span>
				case LITERAL_NEW:
					{
<span class="fc" id="L9156">					setState(1325);</span>
<span class="fc" id="L9157">					match(LITERAL_NEW);</span>
					}
<span class="fc" id="L9159">					break;</span>
				default:
<span class="nc" id="L9161">					throw new NoViableAltException(this);</span>
				}
				}
				break;
			case 7:
				{
<span class="nc" id="L9167">				_localctx = new MethodRefContext(_localctx);</span>
<span class="nc" id="L9168">				_ctx = _localctx;</span>
<span class="nc" id="L9169">				_prevctx = _localctx;</span>
<span class="nc" id="L9170">				setState(1328);</span>
<span class="nc" id="L9171">				classType();</span>
<span class="nc" id="L9172">				setState(1329);</span>
<span class="nc" id="L9173">				match(DOUBLE_COLON);</span>
<span class="nc" id="L9174">				setState(1331);</span>
<span class="nc" id="L9175">				_errHandler.sync(this);</span>
<span class="nc" id="L9176">				_la = _input.LA(1);</span>
<span class="nc bnc" id="L9177" title="All 2 branches missed.">				if (_la==LT) {</span>
					{
<span class="nc" id="L9179">					setState(1330);</span>
<span class="nc" id="L9180">					typeArguments();</span>
					}
				}

<span class="nc" id="L9184">				setState(1333);</span>
<span class="nc" id="L9185">				match(LITERAL_NEW);</span>
				}
<span class="nc" id="L9187">				break;</span>
			case 8:
				{
<span class="fc" id="L9190">				_localctx = new CastExpContext(_localctx);</span>
<span class="fc" id="L9191">				_ctx = _localctx;</span>
<span class="fc" id="L9192">				_prevctx = _localctx;</span>
<span class="fc" id="L9193">				setState(1335);</span>
<span class="fc" id="L9194">				match(LPAREN);</span>
<span class="fc" id="L9195">				setState(1336);</span>
<span class="fc" id="L9196">				typeCastParameters();</span>
<span class="fc" id="L9197">				setState(1337);</span>
<span class="fc" id="L9198">				match(RPAREN);</span>
<span class="fc" id="L9199">				setState(1338);</span>
<span class="fc" id="L9200">				expr(15);</span>
				}
<span class="fc" id="L9202">				break;</span>
			case 9:
				{
<span class="fc" id="L9205">				_localctx = new LambdaExpContext(_localctx);</span>
<span class="fc" id="L9206">				_ctx = _localctx;</span>
<span class="fc" id="L9207">				_prevctx = _localctx;</span>
<span class="fc" id="L9208">				setState(1340);</span>
<span class="fc" id="L9209">				lambdaExpression();</span>
				}
				break;
			}
<span class="fc" id="L9213">			_ctx.stop = _input.LT(-1);</span>
<span class="fc" id="L9214">			setState(1455);</span>
<span class="fc" id="L9215">			_errHandler.sync(this);</span>
<span class="fc" id="L9216">			_alt = getInterpreter().adaptivePredict(_input,167,_ctx);</span>
<span class="pc bpc" id="L9217" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L9218" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
<span class="pc bpc" id="L9219" title="1 of 2 branches missed.">					if ( _parseListeners!=null ) triggerExitRuleEvent();</span>
<span class="fc" id="L9220">					_prevctx = _localctx;</span>
					{
<span class="fc" id="L9222">					setState(1453);</span>
<span class="fc" id="L9223">					_errHandler.sync(this);</span>
<span class="pc bpc" id="L9224" title="1 of 23 branches missed.">					switch ( getInterpreter().adaptivePredict(_input,166,_ctx) ) {</span>
					case 1:
						{
<span class="fc" id="L9227">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9228">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9229">						setState(1343);</span>
<span class="pc bpc" id="L9230" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 14))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 14)&quot;);</span>
<span class="fc" id="L9231">						setState(1344);</span>
<span class="fc" id="L9232">						((BinOpContext)_localctx).bop = _input.LT(1);</span>
<span class="fc" id="L9233">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9234" title="1 of 6 branches missed.">						if ( !(_la==STAR || _la==DIV || _la==MOD) ) {</span>
<span class="nc" id="L9235">							((BinOpContext)_localctx).bop = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9238" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9239">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9240">							consume();</span>
						}
<span class="fc" id="L9242">						setState(1345);</span>
<span class="fc" id="L9243">						expr(15);</span>
						}
<span class="fc" id="L9245">						break;</span>
					case 2:
						{
<span class="fc" id="L9248">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9249">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9250">						setState(1346);</span>
<span class="pc bpc" id="L9251" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 13))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 13)&quot;);</span>
<span class="fc" id="L9252">						setState(1347);</span>
<span class="fc" id="L9253">						((BinOpContext)_localctx).bop = _input.LT(1);</span>
<span class="fc" id="L9254">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9255" title="1 of 4 branches missed.">						if ( !(_la==PLUS || _la==MINUS) ) {</span>
<span class="nc" id="L9256">							((BinOpContext)_localctx).bop = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9259" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9260">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9261">							consume();</span>
						}
<span class="fc" id="L9263">						setState(1348);</span>
<span class="fc" id="L9264">						expr(14);</span>
						}
<span class="fc" id="L9266">						break;</span>
					case 3:
						{
<span class="fc" id="L9269">						_localctx = new BitShiftContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9270">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9271">						setState(1349);</span>
<span class="pc bpc" id="L9272" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 12)&quot;);</span>
<span class="fc" id="L9273">						setState(1357);</span>
<span class="fc" id="L9274">						_errHandler.sync(this);</span>
<span class="pc bpc" id="L9275" title="1 of 4 branches missed.">						switch ( getInterpreter().adaptivePredict(_input,157,_ctx) ) {</span>
						case 1:
							{
<span class="fc" id="L9278">							setState(1350);</span>
<span class="fc" id="L9279">							match(LT);</span>
<span class="fc" id="L9280">							setState(1351);</span>
<span class="fc" id="L9281">							match(LT);</span>
							}
<span class="fc" id="L9283">							break;</span>
						case 2:
							{
<span class="fc" id="L9286">							setState(1352);</span>
<span class="fc" id="L9287">							match(GT);</span>
<span class="fc" id="L9288">							setState(1353);</span>
<span class="fc" id="L9289">							match(GT);</span>
<span class="fc" id="L9290">							setState(1354);</span>
<span class="fc" id="L9291">							match(GT);</span>
							}
<span class="fc" id="L9293">							break;</span>
						case 3:
							{
<span class="fc" id="L9296">							setState(1355);</span>
<span class="fc" id="L9297">							match(GT);</span>
<span class="fc" id="L9298">							setState(1356);</span>
<span class="fc" id="L9299">							match(GT);</span>
							}
							break;
						}
<span class="fc" id="L9303">						setState(1359);</span>
<span class="fc" id="L9304">						expr(13);</span>
						}
<span class="fc" id="L9306">						break;</span>
					case 4:
						{
<span class="fc" id="L9309">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9310">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9311">						setState(1360);</span>
<span class="pc bpc" id="L9312" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 10)&quot;);</span>
<span class="fc" id="L9313">						setState(1361);</span>
<span class="fc" id="L9314">						((BinOpContext)_localctx).bop = _input.LT(1);</span>
<span class="fc" id="L9315">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9316" title="2 of 4 branches missed.">						if ( !(((((_la - 117)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 117)) &amp; ((1L &lt;&lt; (LT - 117)) | (1L &lt;&lt; (GT - 117)) | (1L &lt;&lt; (LE - 117)) | (1L &lt;&lt; (GE - 117)))) != 0)) ) {</span>
<span class="nc" id="L9317">							((BinOpContext)_localctx).bop = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9320" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9321">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9322">							consume();</span>
						}
<span class="fc" id="L9324">						setState(1362);</span>
<span class="fc" id="L9325">						expr(11);</span>
						}
<span class="fc" id="L9327">						break;</span>
					case 5:
						{
<span class="fc" id="L9330">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9331">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9332">						setState(1363);</span>
<span class="pc bpc" id="L9333" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 9)&quot;);</span>
<span class="fc" id="L9334">						setState(1364);</span>
<span class="fc" id="L9335">						((BinOpContext)_localctx).bop = _input.LT(1);</span>
<span class="fc" id="L9336">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9337" title="1 of 4 branches missed.">						if ( !(_la==NOT_EQUAL || _la==EQUAL) ) {</span>
<span class="nc" id="L9338">							((BinOpContext)_localctx).bop = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9341" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9342">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9343">							consume();</span>
						}
<span class="fc" id="L9345">						setState(1365);</span>
<span class="fc" id="L9346">						expr(10);</span>
						}
<span class="fc" id="L9348">						break;</span>
					case 6:
						{
<span class="fc" id="L9351">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9352">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9353">						setState(1366);</span>
<span class="pc bpc" id="L9354" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 8)&quot;);</span>
<span class="fc" id="L9355">						setState(1367);</span>
<span class="fc" id="L9356">						((BinOpContext)_localctx).bop = match(BAND);</span>
<span class="fc" id="L9357">						setState(1368);</span>
<span class="fc" id="L9358">						expr(9);</span>
						}
<span class="fc" id="L9360">						break;</span>
					case 7:
						{
<span class="fc" id="L9363">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9364">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9365">						setState(1369);</span>
<span class="pc bpc" id="L9366" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 7)&quot;);</span>
<span class="fc" id="L9367">						setState(1370);</span>
<span class="fc" id="L9368">						((BinOpContext)_localctx).bop = match(BXOR);</span>
<span class="fc" id="L9369">						setState(1371);</span>
<span class="fc" id="L9370">						expr(8);</span>
						}
<span class="fc" id="L9372">						break;</span>
					case 8:
						{
<span class="fc" id="L9375">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9376">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9377">						setState(1372);</span>
<span class="pc bpc" id="L9378" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 6)&quot;);</span>
<span class="fc" id="L9379">						setState(1373);</span>
<span class="fc" id="L9380">						((BinOpContext)_localctx).bop = match(BOR);</span>
<span class="fc" id="L9381">						setState(1374);</span>
<span class="fc" id="L9382">						expr(7);</span>
						}
<span class="fc" id="L9384">						break;</span>
					case 9:
						{
<span class="fc" id="L9387">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9388">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9389">						setState(1375);</span>
<span class="pc bpc" id="L9390" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 5)&quot;);</span>
<span class="fc" id="L9391">						setState(1376);</span>
<span class="fc" id="L9392">						((BinOpContext)_localctx).bop = match(LAND);</span>
<span class="fc" id="L9393">						setState(1377);</span>
<span class="fc" id="L9394">						expr(6);</span>
						}
<span class="fc" id="L9396">						break;</span>
					case 10:
						{
<span class="fc" id="L9399">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9400">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9401">						setState(1378);</span>
<span class="pc bpc" id="L9402" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 4)&quot;);</span>
<span class="fc" id="L9403">						setState(1379);</span>
<span class="fc" id="L9404">						((BinOpContext)_localctx).bop = match(LOR);</span>
<span class="fc" id="L9405">						setState(1380);</span>
<span class="fc" id="L9406">						expr(5);</span>
						}
<span class="fc" id="L9408">						break;</span>
					case 11:
						{
<span class="fc" id="L9411">						_localctx = new TernaryOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9412">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9413">						setState(1381);</span>
<span class="pc bpc" id="L9414" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 3)&quot;);</span>
<span class="fc" id="L9415">						setState(1382);</span>
<span class="fc" id="L9416">						((TernaryOpContext)_localctx).bop = match(QUESTION);</span>
<span class="fc" id="L9417">						setState(1383);</span>
<span class="fc" id="L9418">						expr(0);</span>
<span class="fc" id="L9419">						setState(1384);</span>
<span class="fc" id="L9420">						match(COLON);</span>
<span class="fc" id="L9421">						setState(1385);</span>
<span class="fc" id="L9422">						expr(3);</span>
						}
<span class="fc" id="L9424">						break;</span>
					case 12:
						{
<span class="fc" id="L9427">						_localctx = new BinOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9428">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9429">						setState(1387);</span>
<span class="pc bpc" id="L9430" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 2)&quot;);</span>
<span class="fc" id="L9431">						setState(1388);</span>
<span class="fc" id="L9432">						((BinOpContext)_localctx).bop = _input.LT(1);</span>
<span class="fc" id="L9433">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9434" title="2 of 4 branches missed.">						if ( !(((((_la - 80)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 80)) &amp; ((1L &lt;&lt; (ASSIGN - 80)) | (1L &lt;&lt; (PLUS_ASSIGN - 80)) | (1L &lt;&lt; (MINUS_ASSIGN - 80)) | (1L &lt;&lt; (STAR_ASSIGN - 80)) | (1L &lt;&lt; (DIV_ASSIGN - 80)) | (1L &lt;&lt; (MOD_ASSIGN - 80)) | (1L &lt;&lt; (SR_ASSIGN - 80)) | (1L &lt;&lt; (BSR_ASSIGN - 80)) | (1L &lt;&lt; (SL_ASSIGN - 80)) | (1L &lt;&lt; (BAND_ASSIGN - 80)) | (1L &lt;&lt; (BXOR_ASSIGN - 80)) | (1L &lt;&lt; (BOR_ASSIGN - 80)))) != 0)) ) {</span>
<span class="nc" id="L9435">							((BinOpContext)_localctx).bop = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9438" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9439">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9440">							consume();</span>
						}
<span class="fc" id="L9442">						setState(1389);</span>
<span class="fc" id="L9443">						expr(2);</span>
						}
<span class="fc" id="L9445">						break;</span>
					case 13:
						{
<span class="fc" id="L9448">						_localctx = new RefOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9449">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9450">						setState(1390);</span>
<span class="pc bpc" id="L9451" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 30))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 30)&quot;);</span>
<span class="fc" id="L9452">						setState(1391);</span>
<span class="fc" id="L9453">						((RefOpContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9454">						setState(1392);</span>
<span class="fc" id="L9455">						id();</span>
						}
<span class="fc" id="L9457">						break;</span>
					case 14:
						{
<span class="fc" id="L9460">						_localctx = new MethodCallContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9461">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9462">						setState(1393);</span>
<span class="pc bpc" id="L9463" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 29))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 29)&quot;);</span>
<span class="fc" id="L9464">						setState(1394);</span>
<span class="fc" id="L9465">						((MethodCallContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9466">						setState(1395);</span>
<span class="fc" id="L9467">						id();</span>
<span class="fc" id="L9468">						setState(1396);</span>
<span class="fc" id="L9469">						match(LPAREN);</span>
<span class="fc" id="L9470">						setState(1398);</span>
<span class="fc" id="L9471">						_errHandler.sync(this);</span>
<span class="fc" id="L9472">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9473" title="2 of 12 branches missed.">						if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
							{
<span class="fc" id="L9475">							setState(1397);</span>
<span class="fc" id="L9476">							expressionList();</span>
							}
						}

<span class="fc" id="L9480">						setState(1400);</span>
<span class="fc" id="L9481">						match(RPAREN);</span>
						}
<span class="fc" id="L9483">						break;</span>
					case 15:
						{
<span class="fc" id="L9486">						_localctx = new ThisExpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9487">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9488">						setState(1402);</span>
<span class="pc bpc" id="L9489" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 28))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 28)&quot;);</span>
<span class="fc" id="L9490">						setState(1403);</span>
<span class="fc" id="L9491">						((ThisExpContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9492">						setState(1404);</span>
<span class="fc" id="L9493">						match(LITERAL_THIS);</span>
						}
<span class="fc" id="L9495">						break;</span>
					case 16:
						{
<span class="fc" id="L9498">						_localctx = new InitExpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9499">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9500">						setState(1405);</span>
<span class="pc bpc" id="L9501" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 27))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 27)&quot;);</span>
<span class="fc" id="L9502">						setState(1406);</span>
<span class="fc" id="L9503">						((InitExpContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9504">						setState(1407);</span>
<span class="fc" id="L9505">						match(LITERAL_NEW);</span>
<span class="fc" id="L9506">						setState(1409);</span>
<span class="fc" id="L9507">						_errHandler.sync(this);</span>
<span class="fc" id="L9508">						_la = _input.LA(1);</span>
<span class="fc bfc" id="L9509" title="All 2 branches covered.">						if (_la==LT) {</span>
							{
<span class="fc" id="L9511">							setState(1408);</span>
<span class="fc" id="L9512">							nonWildcardTypeArguments();</span>
							}
						}

<span class="fc" id="L9516">						setState(1411);</span>
<span class="fc" id="L9517">						innerCreator();</span>
						}
<span class="fc" id="L9519">						break;</span>
					case 17:
						{
<span class="fc" id="L9522">						_localctx = new SuperExpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9523">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9524">						setState(1412);</span>
<span class="pc bpc" id="L9525" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 26))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 26)&quot;);</span>
<span class="fc" id="L9526">						setState(1413);</span>
<span class="fc" id="L9527">						((SuperExpContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9528">						setState(1415);</span>
<span class="fc" id="L9529">						_errHandler.sync(this);</span>
<span class="fc" id="L9530">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9531" title="1 of 2 branches missed.">						if (_la==LT) {</span>
							{
<span class="nc" id="L9533">							setState(1414);</span>
<span class="nc" id="L9534">							nonWildcardTypeArguments();</span>
							}
						}

<span class="fc" id="L9538">						setState(1417);</span>
<span class="fc" id="L9539">						match(LITERAL_SUPER);</span>
<span class="fc" id="L9540">						setState(1419);</span>
<span class="fc" id="L9541">						_errHandler.sync(this);</span>
<span class="fc bfc" id="L9542" title="All 2 branches covered.">						switch ( getInterpreter().adaptivePredict(_input,161,_ctx) ) {</span>
						case 1:
							{
<span class="fc" id="L9545">							setState(1418);</span>
<span class="fc" id="L9546">							superSuffix();</span>
							}
							break;
						}
						}
<span class="fc" id="L9551">						break;</span>
					case 18:
						{
<span class="fc" id="L9554">						_localctx = new InvOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9555">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9556">						setState(1421);</span>
<span class="pc bpc" id="L9557" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 25))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 25)&quot;);</span>
<span class="fc" id="L9558">						setState(1422);</span>
<span class="fc" id="L9559">						((InvOpContext)_localctx).bop = match(DOT);</span>
<span class="fc" id="L9560">						setState(1423);</span>
<span class="fc" id="L9561">						nonWildcardTypeArguments();</span>
<span class="fc" id="L9562">						setState(1424);</span>
<span class="fc" id="L9563">						id();</span>
<span class="fc" id="L9564">						setState(1425);</span>
<span class="fc" id="L9565">						match(LPAREN);</span>
<span class="fc" id="L9566">						setState(1427);</span>
<span class="fc" id="L9567">						_errHandler.sync(this);</span>
<span class="fc" id="L9568">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9569" title="6 of 12 branches missed.">						if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
							{
<span class="fc" id="L9571">							setState(1426);</span>
<span class="fc" id="L9572">							expressionList();</span>
							}
						}

<span class="fc" id="L9576">						setState(1429);</span>
<span class="fc" id="L9577">						match(RPAREN);</span>
						}
<span class="fc" id="L9579">						break;</span>
					case 19:
						{
<span class="fc" id="L9582">						_localctx = new IndexOpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9583">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9584">						setState(1431);</span>
<span class="pc bpc" id="L9585" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 24))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 24)&quot;);</span>
<span class="fc" id="L9586">						setState(1432);</span>
<span class="fc" id="L9587">						match(LBRACK);</span>
<span class="fc" id="L9588">						setState(1433);</span>
<span class="fc" id="L9589">						expr(0);</span>
<span class="fc" id="L9590">						setState(1434);</span>
<span class="fc" id="L9591">						match(RBRACK);</span>
						}
<span class="fc" id="L9593">						break;</span>
					case 20:
						{
<span class="fc" id="L9596">						_localctx = new PostfixContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9597">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9598">						setState(1436);</span>
<span class="pc bpc" id="L9599" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 21))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 21)&quot;);</span>
<span class="fc" id="L9600">						setState(1437);</span>
<span class="fc" id="L9601">						((PostfixContext)_localctx).postfix = _input.LT(1);</span>
<span class="fc" id="L9602">						_la = _input.LA(1);</span>
<span class="pc bpc" id="L9603" title="1 of 4 branches missed.">						if ( !(_la==INC || _la==DEC) ) {</span>
<span class="nc" id="L9604">							((PostfixContext)_localctx).postfix = (Token)_errHandler.recoverInline(this);</span>
						}
						else {
<span class="pc bpc" id="L9607" title="1 of 2 branches missed.">							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L9608">							_errHandler.reportMatch(this);</span>
<span class="fc" id="L9609">							consume();</span>
						}
						}
<span class="fc" id="L9612">						break;</span>
					case 21:
						{
<span class="fc" id="L9615">						_localctx = new MethodRefContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9616">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9617">						setState(1438);</span>
<span class="pc bpc" id="L9618" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 18))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 18)&quot;);</span>
<span class="fc" id="L9619">						setState(1439);</span>
<span class="fc" id="L9620">						match(DOUBLE_COLON);</span>
<span class="fc" id="L9621">						setState(1441);</span>
<span class="fc" id="L9622">						_errHandler.sync(this);</span>
<span class="fc" id="L9623">						_la = _input.LA(1);</span>
<span class="fc bfc" id="L9624" title="All 2 branches covered.">						if (_la==LT) {</span>
							{
<span class="fc" id="L9626">							setState(1440);</span>
<span class="fc" id="L9627">							typeArguments();</span>
							}
						}

<span class="fc" id="L9631">						setState(1445);</span>
<span class="fc" id="L9632">						_errHandler.sync(this);</span>
<span class="pc bpc" id="L9633" title="1 of 3 branches missed.">						switch (_input.LA(1)) {</span>
						case IDENT:
						case LITERAL_RECORD:
						case LITERAL_YIELD:
						case LITERAL_NON_SEALED:
						case LITERAL_SEALED:
						case LITERAL_PERMITS:
							{
<span class="fc" id="L9641">							setState(1443);</span>
<span class="fc" id="L9642">							id();</span>
							}
<span class="fc" id="L9644">							break;</span>
						case LITERAL_NEW:
							{
<span class="fc" id="L9647">							setState(1444);</span>
<span class="fc" id="L9648">							match(LITERAL_NEW);</span>
							}
<span class="fc" id="L9650">							break;</span>
						default:
<span class="nc" id="L9652">							throw new NoViableAltException(this);</span>
						}
						}
						break;
					case 22:
						{
<span class="fc" id="L9658">						_localctx = new InstanceOfExpContext(new ExprContext(_parentctx, _parentState));</span>
<span class="fc" id="L9659">						pushNewRecursionContext(_localctx, _startState, RULE_expr);</span>
<span class="fc" id="L9660">						setState(1447);</span>
<span class="pc bpc" id="L9661" title="1 of 2 branches missed.">						if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 11)&quot;);</span>
<span class="fc" id="L9662">						setState(1448);</span>
<span class="fc" id="L9663">						((InstanceOfExpContext)_localctx).bop = match(LITERAL_INSTANCEOF);</span>
<span class="fc" id="L9664">						setState(1451);</span>
<span class="fc" id="L9665">						_errHandler.sync(this);</span>
<span class="pc bpc" id="L9666" title="1 of 3 branches missed.">						switch ( getInterpreter().adaptivePredict(_input,165,_ctx) ) {</span>
						case 1:
							{
<span class="fc" id="L9669">							setState(1449);</span>
<span class="fc" id="L9670">							primaryPattern();</span>
							}
<span class="fc" id="L9672">							break;</span>
						case 2:
							{
<span class="fc" id="L9675">							setState(1450);</span>
<span class="fc" id="L9676">							typeType(true);</span>
							}
							break;
						}
						}
						break;
					}
					} 
				}
<span class="fc" id="L9685">				setState(1457);</span>
<span class="fc" id="L9686">				_errHandler.sync(this);</span>
<span class="fc" id="L9687">				_alt = getInterpreter().adaptivePredict(_input,167,_ctx);</span>
			}
			}
		}
<span class="nc" id="L9691">		catch (RecognitionException re) {</span>
<span class="nc" id="L9692">			_localctx.exception = re;</span>
<span class="nc" id="L9693">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L9694">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L9697">			unrollRecursionContexts(_parentctx);</span>
		}
<span class="fc" id="L9699">		return _localctx;</span>
	}

	public static class TypeCastParametersContext extends ParserRuleContext {
		public List&lt;TypeTypeContext&gt; typeType() {
<span class="nc" id="L9704">			return getRuleContexts(TypeTypeContext.class);</span>
		}
		public TypeTypeContext typeType(int i) {
<span class="fc" id="L9707">			return getRuleContext(TypeTypeContext.class,i);</span>
		}
<span class="fc" id="L9709">		public List&lt;TerminalNode&gt; BAND() { return getTokens(JavaLanguageParser.BAND); }</span>
		public TerminalNode BAND(int i) {
<span class="fc" id="L9711">			return getToken(JavaLanguageParser.BAND, i);</span>
		}
		public TypeCastParametersContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L9714">			super(parent, invokingState);</span>
<span class="fc" id="L9715">		}</span>
<span class="nc" id="L9716">		@Override public int getRuleIndex() { return RULE_typeCastParameters; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9719" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeCastParameters(this);</span>
<span class="nc" id="L9720">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeCastParametersContext typeCastParameters() throws RecognitionException {
<span class="fc" id="L9725">		TypeCastParametersContext _localctx = new TypeCastParametersContext(_ctx, getState());</span>
<span class="fc" id="L9726">		enterRule(_localctx, 218, RULE_typeCastParameters);</span>
		int _la;
		try {
<span class="fc" id="L9729">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L9731">			setState(1458);</span>
<span class="fc" id="L9732">			typeType(true);</span>
<span class="fc" id="L9733">			setState(1463);</span>
<span class="fc" id="L9734">			_errHandler.sync(this);</span>
<span class="fc" id="L9735">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L9736" title="All 2 branches covered.">			while (_la==BAND) {</span>
				{
				{
<span class="fc" id="L9739">				setState(1459);</span>
<span class="fc" id="L9740">				match(BAND);</span>
<span class="fc" id="L9741">				setState(1460);</span>
<span class="fc" id="L9742">				typeType(true);</span>
				}
				}
<span class="fc" id="L9745">				setState(1465);</span>
<span class="fc" id="L9746">				_errHandler.sync(this);</span>
<span class="fc" id="L9747">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L9751">		catch (RecognitionException re) {</span>
<span class="nc" id="L9752">			_localctx.exception = re;</span>
<span class="nc" id="L9753">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L9754">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L9757">			exitRule();</span>
		}
<span class="fc" id="L9759">		return _localctx;</span>
	}

	public static class LambdaExpressionContext extends ParserRuleContext {
		public LambdaParametersContext lambdaParameters() {
<span class="fc" id="L9764">			return getRuleContext(LambdaParametersContext.class,0);</span>
		}
<span class="fc" id="L9766">		public TerminalNode LAMBDA() { return getToken(JavaLanguageParser.LAMBDA, 0); }</span>
		public LambdaBodyContext lambdaBody() {
<span class="fc" id="L9768">			return getRuleContext(LambdaBodyContext.class,0);</span>
		}
		public LambdaExpressionContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L9771">			super(parent, invokingState);</span>
<span class="fc" id="L9772">		}</span>
<span class="nc" id="L9773">		@Override public int getRuleIndex() { return RULE_lambdaExpression; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9776" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLambdaExpression(this);</span>
<span class="nc" id="L9777">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LambdaExpressionContext lambdaExpression() throws RecognitionException {
<span class="fc" id="L9782">		LambdaExpressionContext _localctx = new LambdaExpressionContext(_ctx, getState());</span>
<span class="fc" id="L9783">		enterRule(_localctx, 220, RULE_lambdaExpression);</span>
		try {
<span class="fc" id="L9785">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L9787">			setState(1466);</span>
<span class="fc" id="L9788">			lambdaParameters();</span>
<span class="fc" id="L9789">			setState(1467);</span>
<span class="fc" id="L9790">			match(LAMBDA);</span>
<span class="fc" id="L9791">			setState(1468);</span>
<span class="fc" id="L9792">			lambdaBody();</span>
			}
		}
<span class="nc" id="L9795">		catch (RecognitionException re) {</span>
<span class="nc" id="L9796">			_localctx.exception = re;</span>
<span class="nc" id="L9797">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L9798">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L9801">			exitRule();</span>
		}
<span class="fc" id="L9803">		return _localctx;</span>
	}

	public static class LambdaParametersContext extends ParserRuleContext {
		public LambdaParametersContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L9808">			super(parent, invokingState);</span>
<span class="fc" id="L9809">		}</span>
<span class="nc" id="L9810">		@Override public int getRuleIndex() { return RULE_lambdaParameters; }</span>
	 
<span class="fc" id="L9812">		public LambdaParametersContext() { }</span>
		public void copyFrom(LambdaParametersContext ctx) {
<span class="fc" id="L9814">			super.copyFrom(ctx);</span>
<span class="fc" id="L9815">		}</span>
	}
	public static class SingleLambdaParamContext extends LambdaParametersContext {
		public IdContext id() {
<span class="nc" id="L9819">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L9821">		public SingleLambdaParamContext(LambdaParametersContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9824" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSingleLambdaParam(this);</span>
<span class="nc" id="L9825">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class MultiLambdaParamContext extends LambdaParametersContext {
<span class="fc" id="L9829">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public MultiLambdaParamsContext multiLambdaParams() {
<span class="fc" id="L9831">			return getRuleContext(MultiLambdaParamsContext.class,0);</span>
		}
<span class="fc" id="L9833">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="fc" id="L9834">		public MultiLambdaParamContext(LambdaParametersContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9837" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMultiLambdaParam(this);</span>
<span class="nc" id="L9838">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class FormalLambdaParamContext extends LambdaParametersContext {
<span class="fc" id="L9842">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L9843">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public FormalParameterListContext formalParameterList() {
<span class="fc" id="L9845">			return getRuleContext(FormalParameterListContext.class,0);</span>
		}
<span class="fc" id="L9847">		public FormalLambdaParamContext(LambdaParametersContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9850" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitFormalLambdaParam(this);</span>
<span class="nc" id="L9851">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LambdaParametersContext lambdaParameters() throws RecognitionException {
<span class="fc" id="L9856">		LambdaParametersContext _localctx = new LambdaParametersContext(_ctx, getState());</span>
<span class="fc" id="L9857">		enterRule(_localctx, 222, RULE_lambdaParameters);</span>
		int _la;
		try {
<span class="fc" id="L9860">			setState(1480);</span>
<span class="fc" id="L9861">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L9862" title="1 of 4 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,170,_ctx) ) {</span>
			case 1:
<span class="fc" id="L9864">				_localctx = new SingleLambdaParamContext(_localctx);</span>
<span class="fc" id="L9865">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L9867">				setState(1470);</span>
<span class="fc" id="L9868">				id();</span>
				}
<span class="fc" id="L9870">				break;</span>
			case 2:
<span class="fc" id="L9872">				_localctx = new FormalLambdaParamContext(_localctx);</span>
<span class="fc" id="L9873">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L9875">				setState(1471);</span>
<span class="fc" id="L9876">				match(LPAREN);</span>
<span class="fc" id="L9877">				setState(1473);</span>
<span class="fc" id="L9878">				_errHandler.sync(this);</span>
<span class="fc" id="L9879">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L9880" title="2 of 8 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; FINAL) | (1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)))) != 0)) {</span>
					{
<span class="fc" id="L9882">					setState(1472);</span>
<span class="fc" id="L9883">					formalParameterList();</span>
					}
				}

<span class="fc" id="L9887">				setState(1475);</span>
<span class="fc" id="L9888">				match(RPAREN);</span>
				}
<span class="fc" id="L9890">				break;</span>
			case 3:
<span class="fc" id="L9892">				_localctx = new MultiLambdaParamContext(_localctx);</span>
<span class="fc" id="L9893">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L9895">				setState(1476);</span>
<span class="fc" id="L9896">				match(LPAREN);</span>
<span class="fc" id="L9897">				setState(1477);</span>
<span class="fc" id="L9898">				multiLambdaParams();</span>
<span class="fc" id="L9899">				setState(1478);</span>
<span class="fc" id="L9900">				match(RPAREN);</span>
				}
				break;
			}
		}
<span class="nc" id="L9905">		catch (RecognitionException re) {</span>
<span class="nc" id="L9906">			_localctx.exception = re;</span>
<span class="nc" id="L9907">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L9908">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L9911">			exitRule();</span>
		}
<span class="fc" id="L9913">		return _localctx;</span>
	}

	public static class MultiLambdaParamsContext extends ParserRuleContext {
		public List&lt;IdContext&gt; id() {
<span class="nc" id="L9918">			return getRuleContexts(IdContext.class);</span>
		}
		public IdContext id(int i) {
<span class="fc" id="L9921">			return getRuleContext(IdContext.class,i);</span>
		}
<span class="fc" id="L9923">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="fc" id="L9925">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public MultiLambdaParamsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L9928">			super(parent, invokingState);</span>
<span class="fc" id="L9929">		}</span>
<span class="nc" id="L9930">		@Override public int getRuleIndex() { return RULE_multiLambdaParams; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9933" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitMultiLambdaParams(this);</span>
<span class="nc" id="L9934">			else return visitor.visitChildren(this);</span>
		}
	}

	public final MultiLambdaParamsContext multiLambdaParams() throws RecognitionException {
<span class="fc" id="L9939">		MultiLambdaParamsContext _localctx = new MultiLambdaParamsContext(_ctx, getState());</span>
<span class="fc" id="L9940">		enterRule(_localctx, 224, RULE_multiLambdaParams);</span>
		int _la;
		try {
<span class="fc" id="L9943">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L9945">			setState(1482);</span>
<span class="fc" id="L9946">			id();</span>
<span class="fc" id="L9947">			setState(1487);</span>
<span class="fc" id="L9948">			_errHandler.sync(this);</span>
<span class="fc" id="L9949">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L9950" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L9953">				setState(1483);</span>
<span class="fc" id="L9954">				match(COMMA);</span>
<span class="fc" id="L9955">				setState(1484);</span>
<span class="fc" id="L9956">				id();</span>
				}
				}
<span class="fc" id="L9959">				setState(1489);</span>
<span class="fc" id="L9960">				_errHandler.sync(this);</span>
<span class="fc" id="L9961">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L9965">		catch (RecognitionException re) {</span>
<span class="nc" id="L9966">			_localctx.exception = re;</span>
<span class="nc" id="L9967">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L9968">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L9971">			exitRule();</span>
		}
<span class="fc" id="L9973">		return _localctx;</span>
	}

	public static class LambdaBodyContext extends ParserRuleContext {
		public ExpressionContext expression() {
<span class="nc" id="L9978">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public BlockContext block() {
<span class="nc" id="L9981">			return getRuleContext(BlockContext.class,0);</span>
		}
		public LambdaBodyContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L9984">			super(parent, invokingState);</span>
<span class="fc" id="L9985">		}</span>
<span class="nc" id="L9986">		@Override public int getRuleIndex() { return RULE_lambdaBody; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L9989" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLambdaBody(this);</span>
<span class="nc" id="L9990">			else return visitor.visitChildren(this);</span>
		}
	}

	public final LambdaBodyContext lambdaBody() throws RecognitionException {
<span class="fc" id="L9995">		LambdaBodyContext _localctx = new LambdaBodyContext(_ctx, getState());</span>
<span class="fc" id="L9996">		enterRule(_localctx, 226, RULE_lambdaBody);</span>
		try {
<span class="fc" id="L9998">			setState(1492);</span>
<span class="fc" id="L9999">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L10000" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LPAREN:
			case LITERAL_THIS:
			case LITERAL_SUPER:
			case LITERAL_SWITCH:
			case PLUS:
			case MINUS:
			case INC:
			case DEC:
			case BNOT:
			case LNOT:
			case LITERAL_TRUE:
			case LITERAL_FALSE:
			case LITERAL_NULL:
			case LITERAL_NEW:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case AT:
			case FLOAT_LITERAL:
			case DOUBLE_LITERAL:
			case HEX_FLOAT_LITERAL:
			case HEX_DOUBLE_LITERAL:
			case LITERAL_RECORD:
			case TEXT_BLOCK_LITERAL_BEGIN:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
			case DECIMAL_LITERAL_LONG:
			case DECIMAL_LITERAL:
			case HEX_LITERAL_LONG:
			case HEX_LITERAL:
			case OCT_LITERAL_LONG:
			case OCT_LITERAL:
			case BINARY_LITERAL_LONG:
			case BINARY_LITERAL:
<span class="fc" id="L10046">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L10048">				setState(1490);</span>
<span class="fc" id="L10049">				expression();</span>
				}
<span class="fc" id="L10051">				break;</span>
			case LCURLY:
<span class="fc" id="L10053">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L10055">				setState(1491);</span>
<span class="fc" id="L10056">				block();</span>
				}
<span class="fc" id="L10058">				break;</span>
			default:
<span class="nc" id="L10060">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L10063">		catch (RecognitionException re) {</span>
<span class="nc" id="L10064">			_localctx.exception = re;</span>
<span class="nc" id="L10065">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10066">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10069">			exitRule();</span>
		}
<span class="fc" id="L10071">		return _localctx;</span>
	}

	public static class PrimaryContext extends ParserRuleContext {
		public PrimaryContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10076">			super(parent, invokingState);</span>
<span class="fc" id="L10077">		}</span>
<span class="nc" id="L10078">		@Override public int getRuleIndex() { return RULE_primary; }</span>
	 
<span class="fc" id="L10080">		public PrimaryContext() { }</span>
		public void copyFrom(PrimaryContext ctx) {
<span class="fc" id="L10082">			super.copyFrom(ctx);</span>
<span class="fc" id="L10083">		}</span>
	}
	public static class ParenPrimaryContext extends PrimaryContext {
<span class="nc" id="L10086">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
		public ExprContext expr() {
<span class="nc" id="L10088">			return getRuleContext(ExprContext.class,0);</span>
		}
<span class="nc" id="L10090">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
<span class="fc" id="L10091">		public ParenPrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10094" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitParenPrimary(this);</span>
<span class="nc" id="L10095">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SwitchPrimaryContext extends PrimaryContext {
		public SwitchExpressionOrStatementContext switchExpressionOrStatement() {
<span class="nc" id="L10100">			return getRuleContext(SwitchExpressionOrStatementContext.class,0);</span>
		}
<span class="fc" id="L10102">		public SwitchPrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10105" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSwitchPrimary(this);</span>
<span class="nc" id="L10106">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class PrimitivePrimaryContext extends PrimaryContext {
		public PrimitiveTypeContext type;
<span class="fc" id="L10111">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L10112">		public TerminalNode LITERAL_CLASS() { return getToken(JavaLanguageParser.LITERAL_CLASS, 0); }</span>
		public PrimitiveTypeContext primitiveType() {
<span class="nc" id="L10114">			return getRuleContext(PrimitiveTypeContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="fc" id="L10117">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L10120">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="fc" id="L10122">		public PrimitivePrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10125" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPrimitivePrimary(this);</span>
<span class="nc" id="L10126">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class TokenPrimaryContext extends PrimaryContext {
<span class="nc" id="L10130">		public TerminalNode LITERAL_THIS() { return getToken(JavaLanguageParser.LITERAL_THIS, 0); }</span>
<span class="nc" id="L10131">		public TerminalNode LITERAL_SUPER() { return getToken(JavaLanguageParser.LITERAL_SUPER, 0); }</span>
		public IdContext id() {
<span class="nc" id="L10133">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L10135">		public TokenPrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10138" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTokenPrimary(this);</span>
<span class="nc" id="L10139">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ClassRefPrimaryContext extends PrimaryContext {
		public ClassOrInterfaceTypeContext type;
<span class="fc" id="L10144">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
<span class="fc" id="L10145">		public TerminalNode LITERAL_CLASS() { return getToken(JavaLanguageParser.LITERAL_CLASS, 0); }</span>
		public ClassOrInterfaceTypeContext classOrInterfaceType() {
<span class="nc" id="L10147">			return getRuleContext(ClassOrInterfaceTypeContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="fc" id="L10150">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L10153">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="fc" id="L10155">		public ClassRefPrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10158" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassRefPrimary(this);</span>
<span class="nc" id="L10159">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class LiteralPrimaryContext extends PrimaryContext {
		public LiteralContext literal() {
<span class="nc" id="L10164">			return getRuleContext(LiteralContext.class,0);</span>
		}
<span class="fc" id="L10166">		public LiteralPrimaryContext(PrimaryContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10169" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitLiteralPrimary(this);</span>
<span class="nc" id="L10170">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PrimaryContext primary() throws RecognitionException {
<span class="fc" id="L10175">		PrimaryContext _localctx = new PrimaryContext(_ctx, getState());</span>
<span class="fc" id="L10176">		enterRule(_localctx, 228, RULE_primary);</span>
		int _la;
		try {
<span class="fc" id="L10179">			setState(1523);</span>
<span class="fc" id="L10180">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L10181" title="1 of 9 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,175,_ctx) ) {</span>
			case 1:
<span class="fc" id="L10183">				_localctx = new SwitchPrimaryContext(_localctx);</span>
<span class="fc" id="L10184">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L10186">				setState(1494);</span>
<span class="fc" id="L10187">				switchExpressionOrStatement();</span>
				}
<span class="fc" id="L10189">				break;</span>
			case 2:
<span class="fc" id="L10191">				_localctx = new ParenPrimaryContext(_localctx);</span>
<span class="fc" id="L10192">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L10194">				setState(1495);</span>
<span class="fc" id="L10195">				match(LPAREN);</span>
<span class="fc" id="L10196">				setState(1496);</span>
<span class="fc" id="L10197">				expr(0);</span>
<span class="fc" id="L10198">				setState(1497);</span>
<span class="fc" id="L10199">				match(RPAREN);</span>
				}
<span class="fc" id="L10201">				break;</span>
			case 3:
<span class="fc" id="L10203">				_localctx = new TokenPrimaryContext(_localctx);</span>
<span class="fc" id="L10204">				enterOuterAlt(_localctx, 3);</span>
				{
<span class="fc" id="L10206">				setState(1499);</span>
<span class="fc" id="L10207">				match(LITERAL_THIS);</span>
				}
<span class="fc" id="L10209">				break;</span>
			case 4:
<span class="fc" id="L10211">				_localctx = new TokenPrimaryContext(_localctx);</span>
<span class="fc" id="L10212">				enterOuterAlt(_localctx, 4);</span>
				{
<span class="fc" id="L10214">				setState(1500);</span>
<span class="fc" id="L10215">				match(LITERAL_SUPER);</span>
				}
<span class="fc" id="L10217">				break;</span>
			case 5:
<span class="fc" id="L10219">				_localctx = new LiteralPrimaryContext(_localctx);</span>
<span class="fc" id="L10220">				enterOuterAlt(_localctx, 5);</span>
				{
<span class="fc" id="L10222">				setState(1501);</span>
<span class="fc" id="L10223">				literal();</span>
				}
<span class="fc" id="L10225">				break;</span>
			case 6:
<span class="fc" id="L10227">				_localctx = new TokenPrimaryContext(_localctx);</span>
<span class="fc" id="L10228">				enterOuterAlt(_localctx, 6);</span>
				{
<span class="fc" id="L10230">				setState(1502);</span>
<span class="fc" id="L10231">				id();</span>
				}
<span class="fc" id="L10233">				break;</span>
			case 7:
<span class="fc" id="L10235">				_localctx = new ClassRefPrimaryContext(_localctx);</span>
<span class="fc" id="L10236">				enterOuterAlt(_localctx, 7);</span>
				{
<span class="fc" id="L10238">				setState(1503);</span>
<span class="fc" id="L10239">				((ClassRefPrimaryContext)_localctx).type = classOrInterfaceType(false);</span>
<span class="fc" id="L10240">				setState(1507);</span>
<span class="fc" id="L10241">				_errHandler.sync(this);</span>
<span class="fc" id="L10242">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L10243" title="1 of 4 branches missed.">				while (_la==LBRACK || _la==AT) {</span>
					{
					{
<span class="fc" id="L10246">					setState(1504);</span>
<span class="fc" id="L10247">					arrayDeclarator();</span>
					}
					}
<span class="fc" id="L10250">					setState(1509);</span>
<span class="fc" id="L10251">					_errHandler.sync(this);</span>
<span class="fc" id="L10252">					_la = _input.LA(1);</span>
				}
<span class="fc" id="L10254">				setState(1510);</span>
<span class="fc" id="L10255">				match(DOT);</span>
<span class="fc" id="L10256">				setState(1511);</span>
<span class="fc" id="L10257">				match(LITERAL_CLASS);</span>
				}
<span class="fc" id="L10259">				break;</span>
			case 8:
<span class="fc" id="L10261">				_localctx = new PrimitivePrimaryContext(_localctx);</span>
<span class="fc" id="L10262">				enterOuterAlt(_localctx, 8);</span>
				{
<span class="fc" id="L10264">				setState(1513);</span>
<span class="fc" id="L10265">				((PrimitivePrimaryContext)_localctx).type = primitiveType();</span>
<span class="fc" id="L10266">				setState(1517);</span>
<span class="fc" id="L10267">				_errHandler.sync(this);</span>
<span class="fc" id="L10268">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L10269" title="1 of 4 branches missed.">				while (_la==LBRACK || _la==AT) {</span>
					{
					{
<span class="fc" id="L10272">					setState(1514);</span>
<span class="fc" id="L10273">					arrayDeclarator();</span>
					}
					}
<span class="fc" id="L10276">					setState(1519);</span>
<span class="fc" id="L10277">					_errHandler.sync(this);</span>
<span class="fc" id="L10278">					_la = _input.LA(1);</span>
				}
<span class="fc" id="L10280">				setState(1520);</span>
<span class="fc" id="L10281">				match(DOT);</span>
<span class="fc" id="L10282">				setState(1521);</span>
<span class="fc" id="L10283">				match(LITERAL_CLASS);</span>
				}
				break;
			}
		}
<span class="nc" id="L10288">		catch (RecognitionException re) {</span>
<span class="nc" id="L10289">			_localctx.exception = re;</span>
<span class="nc" id="L10290">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10291">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10294">			exitRule();</span>
		}
<span class="fc" id="L10296">		return _localctx;</span>
	}

	public static class ClassTypeContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="nc" id="L10301">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L10304">			return getRuleContext(IdContext.class,0);</span>
		}
		public ClassOrInterfaceTypeContext classOrInterfaceType() {
<span class="nc" id="L10307">			return getRuleContext(ClassOrInterfaceTypeContext.class,0);</span>
		}
<span class="nc" id="L10309">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public TypeArgumentsContext typeArguments() {
<span class="nc" id="L10311">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
		public ClassTypeContext(ParserRuleContext parent, int invokingState) {
<span class="nc" id="L10314">			super(parent, invokingState);</span>
<span class="nc" id="L10315">		}</span>
<span class="nc" id="L10316">		@Override public int getRuleIndex() { return RULE_classType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L10319" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassType(this);</span>
<span class="nc" id="L10320">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassTypeContext classType() throws RecognitionException {
<span class="nc" id="L10325">		ClassTypeContext _localctx = new ClassTypeContext(_ctx, getState());</span>
<span class="nc" id="L10326">		enterRule(_localctx, 230, RULE_classType);</span>
		int _la;
		try {
<span class="nc" id="L10329">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="nc" id="L10331">			setState(1528);</span>
<span class="nc" id="L10332">			_errHandler.sync(this);</span>
<span class="nc bnc" id="L10333" title="All 2 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,176,_ctx) ) {</span>
			case 1:
				{
<span class="nc" id="L10336">				setState(1525);</span>
<span class="nc" id="L10337">				classOrInterfaceType(false);</span>
<span class="nc" id="L10338">				setState(1526);</span>
<span class="nc" id="L10339">				match(DOT);</span>
				}
				break;
			}
<span class="nc" id="L10343">			setState(1530);</span>
<span class="nc" id="L10344">			annotations(false);</span>
<span class="nc" id="L10345">			setState(1531);</span>
<span class="nc" id="L10346">			id();</span>
<span class="nc" id="L10347">			setState(1533);</span>
<span class="nc" id="L10348">			_errHandler.sync(this);</span>
<span class="nc" id="L10349">			_la = _input.LA(1);</span>
<span class="nc bnc" id="L10350" title="All 2 branches missed.">			if (_la==LT) {</span>
				{
<span class="nc" id="L10352">				setState(1532);</span>
<span class="nc" id="L10353">				typeArguments();</span>
				}
			}

			}
		}
<span class="nc" id="L10359">		catch (RecognitionException re) {</span>
<span class="nc" id="L10360">			_localctx.exception = re;</span>
<span class="nc" id="L10361">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10362">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="nc" id="L10365">			exitRule();</span>
		}
<span class="nc" id="L10367">		return _localctx;</span>
	}

	public static class CreatorContext extends ParserRuleContext {
		public NonWildcardTypeArgumentsContext nonWildcardTypeArguments() {
<span class="nc" id="L10372">			return getRuleContext(NonWildcardTypeArgumentsContext.class,0);</span>
		}
		public CreatedNameContext createdName() {
<span class="nc" id="L10375">			return getRuleContext(CreatedNameContext.class,0);</span>
		}
		public ClassCreatorRestContext classCreatorRest() {
<span class="nc" id="L10378">			return getRuleContext(ClassCreatorRestContext.class,0);</span>
		}
		public List&lt;AnnotationsContext&gt; annotations() {
<span class="nc" id="L10381">			return getRuleContexts(AnnotationsContext.class);</span>
		}
		public AnnotationsContext annotations(int i) {
<span class="nc" id="L10384">			return getRuleContext(AnnotationsContext.class,i);</span>
		}
		public ArrayCreatorRestContext arrayCreatorRest() {
<span class="nc" id="L10387">			return getRuleContext(ArrayCreatorRestContext.class,0);</span>
		}
		public CreatorContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10390">			super(parent, invokingState);</span>
<span class="fc" id="L10391">		}</span>
<span class="nc" id="L10392">		@Override public int getRuleIndex() { return RULE_creator; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10395" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCreator(this);</span>
<span class="nc" id="L10396">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CreatorContext creator() throws RecognitionException {
<span class="fc" id="L10401">		CreatorContext _localctx = new CreatorContext(_ctx, getState());</span>
<span class="fc" id="L10402">		enterRule(_localctx, 232, RULE_creator);</span>
		try {
<span class="fc" id="L10404">			setState(1547);</span>
<span class="fc" id="L10405">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L10406" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LT:
<span class="fc" id="L10408">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L10410">				setState(1535);</span>
<span class="fc" id="L10411">				nonWildcardTypeArguments();</span>
<span class="fc" id="L10412">				setState(1536);</span>
<span class="fc" id="L10413">				createdName();</span>
<span class="fc" id="L10414">				setState(1537);</span>
<span class="fc" id="L10415">				classCreatorRest();</span>
				}
<span class="fc" id="L10417">				break;</span>
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
<span class="fc" id="L10434">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L10436">				setState(1539);</span>
<span class="fc" id="L10437">				annotations(false);</span>
<span class="fc" id="L10438">				setState(1540);</span>
<span class="fc" id="L10439">				createdName();</span>
<span class="fc" id="L10440">				setState(1545);</span>
<span class="fc" id="L10441">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L10442" title="1 of 3 branches missed.">				switch (_input.LA(1)) {</span>
				case LBRACK:
				case AT:
					{
<span class="fc" id="L10446">					setState(1541);</span>
<span class="fc" id="L10447">					annotations(false);</span>
<span class="fc" id="L10448">					setState(1542);</span>
<span class="fc" id="L10449">					arrayCreatorRest();</span>
					}
<span class="fc" id="L10451">					break;</span>
				case LPAREN:
					{
<span class="fc" id="L10454">					setState(1544);</span>
<span class="fc" id="L10455">					classCreatorRest();</span>
					}
<span class="fc" id="L10457">					break;</span>
				default:
<span class="nc" id="L10459">					throw new NoViableAltException(this);</span>
				}
				}
				break;
			default:
<span class="nc" id="L10464">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L10467">		catch (RecognitionException re) {</span>
<span class="nc" id="L10468">			_localctx.exception = re;</span>
<span class="nc" id="L10469">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10470">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10473">			exitRule();</span>
		}
<span class="fc" id="L10475">		return _localctx;</span>
	}

	public static class CreatedNameContext extends ParserRuleContext {
		public CreatedNameContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10480">			super(parent, invokingState);</span>
<span class="fc" id="L10481">		}</span>
<span class="nc" id="L10482">		@Override public int getRuleIndex() { return RULE_createdName; }</span>
	 
<span class="fc" id="L10484">		public CreatedNameContext() { }</span>
		public void copyFrom(CreatedNameContext ctx) {
<span class="fc" id="L10486">			super.copyFrom(ctx);</span>
<span class="fc" id="L10487">		}</span>
	}
	public static class CreatedNamePrimitiveContext extends CreatedNameContext {
		public PrimitiveTypeContext primitiveType() {
<span class="nc" id="L10491">			return getRuleContext(PrimitiveTypeContext.class,0);</span>
		}
<span class="fc" id="L10493">		public CreatedNamePrimitiveContext(CreatedNameContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10496" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCreatedNamePrimitive(this);</span>
<span class="nc" id="L10497">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class CreatedNameObjectContext extends CreatedNameContext {
		public CreatedNameExtendedContext createdNameExtended;
<span class="fc" id="L10502">		public List&lt;CreatedNameExtendedContext&gt; extended = new ArrayList&lt;CreatedNameExtendedContext&gt;();</span>
		public AnnotationsContext annotations() {
<span class="fc" id="L10504">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="fc" id="L10507">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeArgumentsOrDiamondContext typeArgumentsOrDiamond() {
<span class="fc" id="L10510">			return getRuleContext(TypeArgumentsOrDiamondContext.class,0);</span>
		}
		public List&lt;CreatedNameExtendedContext&gt; createdNameExtended() {
<span class="nc" id="L10513">			return getRuleContexts(CreatedNameExtendedContext.class);</span>
		}
		public CreatedNameExtendedContext createdNameExtended(int i) {
<span class="nc" id="L10516">			return getRuleContext(CreatedNameExtendedContext.class,i);</span>
		}
<span class="fc" id="L10518">		public CreatedNameObjectContext(CreatedNameContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10521" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCreatedNameObject(this);</span>
<span class="nc" id="L10522">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CreatedNameContext createdName() throws RecognitionException {
<span class="fc" id="L10527">		CreatedNameContext _localctx = new CreatedNameContext(_ctx, getState());</span>
<span class="fc" id="L10528">		enterRule(_localctx, 234, RULE_createdName);</span>
		int _la;
		try {
<span class="fc" id="L10531">			setState(1561);</span>
<span class="fc" id="L10532">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L10533" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case IDENT:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
<span class="fc" id="L10541">				_localctx = new CreatedNameObjectContext(_localctx);</span>
<span class="fc" id="L10542">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L10544">				setState(1549);</span>
<span class="fc" id="L10545">				annotations(false);</span>
<span class="fc" id="L10546">				setState(1550);</span>
<span class="fc" id="L10547">				id();</span>
<span class="fc" id="L10548">				setState(1552);</span>
<span class="fc" id="L10549">				_errHandler.sync(this);</span>
<span class="fc" id="L10550">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L10551" title="All 2 branches covered.">				if (_la==LT) {</span>
					{
<span class="fc" id="L10553">					setState(1551);</span>
<span class="fc" id="L10554">					typeArgumentsOrDiamond();</span>
					}
				}

<span class="fc" id="L10558">				setState(1557);</span>
<span class="fc" id="L10559">				_errHandler.sync(this);</span>
<span class="fc" id="L10560">				_la = _input.LA(1);</span>
<span class="fc bfc" id="L10561" title="All 2 branches covered.">				while (_la==DOT) {</span>
					{
					{
<span class="fc" id="L10564">					setState(1554);</span>
<span class="fc" id="L10565">					((CreatedNameObjectContext)_localctx).createdNameExtended = createdNameExtended();</span>
<span class="fc" id="L10566">					((CreatedNameObjectContext)_localctx).extended.add(((CreatedNameObjectContext)_localctx).createdNameExtended);</span>
					}
					}
<span class="fc" id="L10569">					setState(1559);</span>
<span class="fc" id="L10570">					_errHandler.sync(this);</span>
<span class="fc" id="L10571">					_la = _input.LA(1);</span>
				}
				}
				break;
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
<span class="fc" id="L10584">				_localctx = new CreatedNamePrimitiveContext(_localctx);</span>
<span class="fc" id="L10585">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L10587">				setState(1560);</span>
<span class="fc" id="L10588">				primitiveType();</span>
				}
<span class="fc" id="L10590">				break;</span>
			default:
<span class="nc" id="L10592">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L10595">		catch (RecognitionException re) {</span>
<span class="nc" id="L10596">			_localctx.exception = re;</span>
<span class="nc" id="L10597">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10598">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10601">			exitRule();</span>
		}
<span class="fc" id="L10603">		return _localctx;</span>
	}

	public static class CreatedNameExtendedContext extends ParserRuleContext {
<span class="nc" id="L10607">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L10609">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L10612">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeArgumentsOrDiamondContext typeArgumentsOrDiamond() {
<span class="nc" id="L10615">			return getRuleContext(TypeArgumentsOrDiamondContext.class,0);</span>
		}
		public CreatedNameExtendedContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10618">			super(parent, invokingState);</span>
<span class="fc" id="L10619">		}</span>
<span class="nc" id="L10620">		@Override public int getRuleIndex() { return RULE_createdNameExtended; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L10623" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitCreatedNameExtended(this);</span>
<span class="nc" id="L10624">			else return visitor.visitChildren(this);</span>
		}
	}

	public final CreatedNameExtendedContext createdNameExtended() throws RecognitionException {
<span class="fc" id="L10629">		CreatedNameExtendedContext _localctx = new CreatedNameExtendedContext(_ctx, getState());</span>
<span class="fc" id="L10630">		enterRule(_localctx, 236, RULE_createdNameExtended);</span>
		int _la;
		try {
<span class="fc" id="L10633">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L10635">			setState(1563);</span>
<span class="fc" id="L10636">			match(DOT);</span>
<span class="fc" id="L10637">			setState(1564);</span>
<span class="fc" id="L10638">			annotations(false);</span>
<span class="fc" id="L10639">			setState(1565);</span>
<span class="fc" id="L10640">			id();</span>
<span class="fc" id="L10641">			setState(1567);</span>
<span class="fc" id="L10642">			_errHandler.sync(this);</span>
<span class="fc" id="L10643">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L10644" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L10646">				setState(1566);</span>
<span class="fc" id="L10647">				typeArgumentsOrDiamond();</span>
				}
			}

			}
		}
<span class="nc" id="L10653">		catch (RecognitionException re) {</span>
<span class="nc" id="L10654">			_localctx.exception = re;</span>
<span class="nc" id="L10655">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10656">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10659">			exitRule();</span>
		}
<span class="fc" id="L10661">		return _localctx;</span>
	}

	public static class InnerCreatorContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="nc" id="L10666">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public IdContext id() {
<span class="nc" id="L10669">			return getRuleContext(IdContext.class,0);</span>
		}
		public ClassCreatorRestContext classCreatorRest() {
<span class="nc" id="L10672">			return getRuleContext(ClassCreatorRestContext.class,0);</span>
		}
		public NonWildcardTypeArgumentsOrDiamondContext nonWildcardTypeArgumentsOrDiamond() {
<span class="nc" id="L10675">			return getRuleContext(NonWildcardTypeArgumentsOrDiamondContext.class,0);</span>
		}
		public InnerCreatorContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10678">			super(parent, invokingState);</span>
<span class="fc" id="L10679">		}</span>
<span class="nc" id="L10680">		@Override public int getRuleIndex() { return RULE_innerCreator; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10683" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitInnerCreator(this);</span>
<span class="nc" id="L10684">			else return visitor.visitChildren(this);</span>
		}
	}

	public final InnerCreatorContext innerCreator() throws RecognitionException {
<span class="fc" id="L10689">		InnerCreatorContext _localctx = new InnerCreatorContext(_ctx, getState());</span>
<span class="fc" id="L10690">		enterRule(_localctx, 238, RULE_innerCreator);</span>
		int _la;
		try {
<span class="fc" id="L10693">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L10695">			setState(1569);</span>
<span class="fc" id="L10696">			annotations(false);</span>
<span class="fc" id="L10697">			setState(1570);</span>
<span class="fc" id="L10698">			id();</span>
<span class="fc" id="L10699">			setState(1572);</span>
<span class="fc" id="L10700">			_errHandler.sync(this);</span>
<span class="fc" id="L10701">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L10702" title="All 2 branches covered.">			if (_la==LT) {</span>
				{
<span class="fc" id="L10704">				setState(1571);</span>
<span class="fc" id="L10705">				nonWildcardTypeArgumentsOrDiamond();</span>
				}
			}

<span class="fc" id="L10709">			setState(1574);</span>
<span class="fc" id="L10710">			classCreatorRest();</span>
			}
		}
<span class="nc" id="L10713">		catch (RecognitionException re) {</span>
<span class="nc" id="L10714">			_localctx.exception = re;</span>
<span class="nc" id="L10715">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10716">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10719">			exitRule();</span>
		}
<span class="fc" id="L10721">		return _localctx;</span>
	}

	public static class ArrayCreatorRestContext extends ParserRuleContext {
<span class="fc" id="L10725">		public TerminalNode LBRACK() { return getToken(JavaLanguageParser.LBRACK, 0); }</span>
<span class="fc" id="L10726">		public TerminalNode RBRACK() { return getToken(JavaLanguageParser.RBRACK, 0); }</span>
		public ArrayInitializerContext arrayInitializer() {
<span class="nc" id="L10728">			return getRuleContext(ArrayInitializerContext.class,0);</span>
		}
		public ExpressionContext expression() {
<span class="fc" id="L10731">			return getRuleContext(ExpressionContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L10734">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L10737">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
		public List&lt;BracketsWithExpContext&gt; bracketsWithExp() {
<span class="nc" id="L10740">			return getRuleContexts(BracketsWithExpContext.class);</span>
		}
		public BracketsWithExpContext bracketsWithExp(int i) {
<span class="nc" id="L10743">			return getRuleContext(BracketsWithExpContext.class,i);</span>
		}
		public ArrayCreatorRestContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10746">			super(parent, invokingState);</span>
<span class="fc" id="L10747">		}</span>
<span class="nc" id="L10748">		@Override public int getRuleIndex() { return RULE_arrayCreatorRest; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10751" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitArrayCreatorRest(this);</span>
<span class="nc" id="L10752">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ArrayCreatorRestContext arrayCreatorRest() throws RecognitionException {
<span class="fc" id="L10757">		ArrayCreatorRestContext _localctx = new ArrayCreatorRestContext(_ctx, getState());</span>
<span class="fc" id="L10758">		enterRule(_localctx, 240, RULE_arrayCreatorRest);</span>
		int _la;
		try {
			int _alt;
<span class="fc" id="L10762">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L10764">			setState(1576);</span>
<span class="fc" id="L10765">			match(LBRACK);</span>
<span class="fc" id="L10766">			setState(1599);</span>
<span class="fc" id="L10767">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L10768" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case RBRACK:
				{
<span class="fc" id="L10771">				setState(1577);</span>
<span class="fc" id="L10772">				match(RBRACK);</span>
<span class="fc" id="L10773">				setState(1581);</span>
<span class="fc" id="L10774">				_errHandler.sync(this);</span>
<span class="fc" id="L10775">				_la = _input.LA(1);</span>
<span class="pc bpc" id="L10776" title="1 of 4 branches missed.">				while (_la==LBRACK || _la==AT) {</span>
					{
					{
<span class="fc" id="L10779">					setState(1578);</span>
<span class="fc" id="L10780">					arrayDeclarator();</span>
					}
					}
<span class="fc" id="L10783">					setState(1583);</span>
<span class="fc" id="L10784">					_errHandler.sync(this);</span>
<span class="fc" id="L10785">					_la = _input.LA(1);</span>
				}
<span class="fc" id="L10787">				setState(1584);</span>
<span class="fc" id="L10788">				arrayInitializer();</span>
				}
<span class="fc" id="L10790">				break;</span>
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LPAREN:
			case LITERAL_THIS:
			case LITERAL_SUPER:
			case LITERAL_SWITCH:
			case PLUS:
			case MINUS:
			case INC:
			case DEC:
			case BNOT:
			case LNOT:
			case LITERAL_TRUE:
			case LITERAL_FALSE:
			case LITERAL_NULL:
			case LITERAL_NEW:
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case AT:
			case FLOAT_LITERAL:
			case DOUBLE_LITERAL:
			case HEX_FLOAT_LITERAL:
			case HEX_DOUBLE_LITERAL:
			case LITERAL_RECORD:
			case TEXT_BLOCK_LITERAL_BEGIN:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
			case DECIMAL_LITERAL_LONG:
			case DECIMAL_LITERAL:
			case HEX_LITERAL_LONG:
			case HEX_LITERAL:
			case OCT_LITERAL_LONG:
			case OCT_LITERAL:
			case BINARY_LITERAL_LONG:
			case BINARY_LITERAL:
				{
<span class="fc" id="L10837">				setState(1585);</span>
<span class="fc" id="L10838">				expression();</span>
<span class="fc" id="L10839">				setState(1586);</span>
<span class="fc" id="L10840">				match(RBRACK);</span>
<span class="fc" id="L10841">				setState(1590);</span>
<span class="fc" id="L10842">				_errHandler.sync(this);</span>
<span class="fc" id="L10843">				_alt = getInterpreter().adaptivePredict(_input,186,_ctx);</span>
<span class="pc bpc" id="L10844" title="1 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L10845" title="1 of 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="fc" id="L10848">						setState(1587);</span>
<span class="fc" id="L10849">						bracketsWithExp();</span>
						}
						} 
					}
<span class="fc" id="L10853">					setState(1592);</span>
<span class="fc" id="L10854">					_errHandler.sync(this);</span>
<span class="fc" id="L10855">					_alt = getInterpreter().adaptivePredict(_input,186,_ctx);</span>
				}
<span class="fc" id="L10857">				setState(1596);</span>
<span class="fc" id="L10858">				_errHandler.sync(this);</span>
<span class="fc" id="L10859">				_alt = getInterpreter().adaptivePredict(_input,187,_ctx);</span>
<span class="pc bpc" id="L10860" title="3 of 4 branches missed.">				while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="nc bnc" id="L10861" title="All 2 branches missed.">					if ( _alt==1 ) {</span>
						{
						{
<span class="nc" id="L10864">						setState(1593);</span>
<span class="nc" id="L10865">						arrayDeclarator();</span>
						}
						} 
					}
<span class="nc" id="L10869">					setState(1598);</span>
<span class="nc" id="L10870">					_errHandler.sync(this);</span>
<span class="nc" id="L10871">					_alt = getInterpreter().adaptivePredict(_input,187,_ctx);</span>
				}
				}
				break;
			default:
<span class="nc" id="L10876">				throw new NoViableAltException(this);</span>
			}
			}
		}
<span class="nc" id="L10880">		catch (RecognitionException re) {</span>
<span class="nc" id="L10881">			_localctx.exception = re;</span>
<span class="nc" id="L10882">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10883">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10886">			exitRule();</span>
		}
<span class="fc" id="L10888">		return _localctx;</span>
	}

	public static class BracketsWithExpContext extends ParserRuleContext {
		public AnnotationsContext annotations() {
<span class="fc" id="L10893">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
<span class="fc" id="L10895">		public TerminalNode LBRACK() { return getToken(JavaLanguageParser.LBRACK, 0); }</span>
		public ExpressionContext expression() {
<span class="fc" id="L10897">			return getRuleContext(ExpressionContext.class,0);</span>
		}
<span class="nc" id="L10899">		public TerminalNode RBRACK() { return getToken(JavaLanguageParser.RBRACK, 0); }</span>
		public BracketsWithExpContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10901">			super(parent, invokingState);</span>
<span class="fc" id="L10902">		}</span>
<span class="nc" id="L10903">		@Override public int getRuleIndex() { return RULE_bracketsWithExp; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10906" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitBracketsWithExp(this);</span>
<span class="nc" id="L10907">			else return visitor.visitChildren(this);</span>
		}
	}

	public final BracketsWithExpContext bracketsWithExp() throws RecognitionException {
<span class="fc" id="L10912">		BracketsWithExpContext _localctx = new BracketsWithExpContext(_ctx, getState());</span>
<span class="fc" id="L10913">		enterRule(_localctx, 242, RULE_bracketsWithExp);</span>
		try {
<span class="fc" id="L10915">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L10917">			setState(1601);</span>
<span class="fc" id="L10918">			annotations(false);</span>
<span class="fc" id="L10919">			setState(1602);</span>
<span class="fc" id="L10920">			match(LBRACK);</span>
<span class="fc" id="L10921">			setState(1603);</span>
<span class="fc" id="L10922">			expression();</span>
<span class="fc" id="L10923">			setState(1604);</span>
<span class="fc" id="L10924">			match(RBRACK);</span>
			}
		}
<span class="nc" id="L10927">		catch (RecognitionException re) {</span>
<span class="nc" id="L10928">			_localctx.exception = re;</span>
<span class="nc" id="L10929">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10930">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10933">			exitRule();</span>
		}
<span class="fc" id="L10935">		return _localctx;</span>
	}

	public static class ClassCreatorRestContext extends ParserRuleContext {
		public ArgumentsContext arguments() {
<span class="nc" id="L10940">			return getRuleContext(ArgumentsContext.class,0);</span>
		}
		public ClassBodyContext classBody() {
<span class="nc" id="L10943">			return getRuleContext(ClassBodyContext.class,0);</span>
		}
		public ClassCreatorRestContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10946">			super(parent, invokingState);</span>
<span class="fc" id="L10947">		}</span>
<span class="nc" id="L10948">		@Override public int getRuleIndex() { return RULE_classCreatorRest; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L10951" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassCreatorRest(this);</span>
<span class="nc" id="L10952">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassCreatorRestContext classCreatorRest() throws RecognitionException {
<span class="fc" id="L10957">		ClassCreatorRestContext _localctx = new ClassCreatorRestContext(_ctx, getState());</span>
<span class="fc" id="L10958">		enterRule(_localctx, 244, RULE_classCreatorRest);</span>
		try {
<span class="fc" id="L10960">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L10962">			setState(1606);</span>
<span class="fc" id="L10963">			arguments();</span>
<span class="fc" id="L10964">			setState(1608);</span>
<span class="fc" id="L10965">			_errHandler.sync(this);</span>
<span class="fc bfc" id="L10966" title="All 2 branches covered.">			switch ( getInterpreter().adaptivePredict(_input,189,_ctx) ) {</span>
			case 1:
				{
<span class="fc" id="L10969">				setState(1607);</span>
<span class="fc" id="L10970">				classBody();</span>
				}
				break;
			}
			}
		}
<span class="nc" id="L10976">		catch (RecognitionException re) {</span>
<span class="nc" id="L10977">			_localctx.exception = re;</span>
<span class="nc" id="L10978">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L10979">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L10982">			exitRule();</span>
		}
<span class="fc" id="L10984">		return _localctx;</span>
	}

	public static class TypeArgumentsOrDiamondContext extends ParserRuleContext {
		public TypeArgumentsOrDiamondContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L10989">			super(parent, invokingState);</span>
<span class="fc" id="L10990">		}</span>
<span class="nc" id="L10991">		@Override public int getRuleIndex() { return RULE_typeArgumentsOrDiamond; }</span>
	 
<span class="fc" id="L10993">		public TypeArgumentsOrDiamondContext() { }</span>
		public void copyFrom(TypeArgumentsOrDiamondContext ctx) {
<span class="fc" id="L10995">			super.copyFrom(ctx);</span>
<span class="fc" id="L10996">		}</span>
	}
	public static class TypeArgsContext extends TypeArgumentsOrDiamondContext {
		public TypeArgumentsContext typeArguments() {
<span class="nc" id="L11000">			return getRuleContext(TypeArgumentsContext.class,0);</span>
		}
<span class="fc" id="L11002">		public TypeArgsContext(TypeArgumentsOrDiamondContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11005" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeArgs(this);</span>
<span class="nc" id="L11006">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class DiamondContext extends TypeArgumentsOrDiamondContext {
<span class="fc" id="L11010">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
<span class="fc" id="L11011">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
<span class="fc" id="L11012">		public DiamondContext(TypeArgumentsOrDiamondContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11015" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitDiamond(this);</span>
<span class="nc" id="L11016">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeArgumentsOrDiamondContext typeArgumentsOrDiamond() throws RecognitionException {
<span class="fc" id="L11021">		TypeArgumentsOrDiamondContext _localctx = new TypeArgumentsOrDiamondContext(_ctx, getState());</span>
<span class="fc" id="L11022">		enterRule(_localctx, 246, RULE_typeArgumentsOrDiamond);</span>
		try {
<span class="fc" id="L11024">			setState(1613);</span>
<span class="fc" id="L11025">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11026" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,190,_ctx) ) {</span>
			case 1:
<span class="fc" id="L11028">				_localctx = new DiamondContext(_localctx);</span>
<span class="fc" id="L11029">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L11031">				setState(1610);</span>
<span class="fc" id="L11032">				match(LT);</span>
<span class="fc" id="L11033">				setState(1611);</span>
<span class="fc" id="L11034">				match(GT);</span>
				}
<span class="fc" id="L11036">				break;</span>
			case 2:
<span class="fc" id="L11038">				_localctx = new TypeArgsContext(_localctx);</span>
<span class="fc" id="L11039">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L11041">				setState(1612);</span>
<span class="fc" id="L11042">				typeArguments();</span>
				}
				break;
			}
		}
<span class="nc" id="L11047">		catch (RecognitionException re) {</span>
<span class="nc" id="L11048">			_localctx.exception = re;</span>
<span class="nc" id="L11049">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11050">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11053">			exitRule();</span>
		}
<span class="fc" id="L11055">		return _localctx;</span>
	}

	public static class NonWildcardTypeArgumentsOrDiamondContext extends ParserRuleContext {
		public NonWildcardTypeArgumentsOrDiamondContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11060">			super(parent, invokingState);</span>
<span class="fc" id="L11061">		}</span>
<span class="nc" id="L11062">		@Override public int getRuleIndex() { return RULE_nonWildcardTypeArgumentsOrDiamond; }</span>
	 
<span class="fc" id="L11064">		public NonWildcardTypeArgumentsOrDiamondContext() { }</span>
		public void copyFrom(NonWildcardTypeArgumentsOrDiamondContext ctx) {
<span class="fc" id="L11066">			super.copyFrom(ctx);</span>
<span class="fc" id="L11067">		}</span>
	}
	public static class NonWildcardDiamondContext extends NonWildcardTypeArgumentsOrDiamondContext {
<span class="fc" id="L11070">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
<span class="fc" id="L11071">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
<span class="fc" id="L11072">		public NonWildcardDiamondContext(NonWildcardTypeArgumentsOrDiamondContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11075" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitNonWildcardDiamond(this);</span>
<span class="nc" id="L11076">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class NonWildcardTypeArgsContext extends NonWildcardTypeArgumentsOrDiamondContext {
		public NonWildcardTypeArgumentsContext nonWildcardTypeArguments() {
<span class="nc" id="L11081">			return getRuleContext(NonWildcardTypeArgumentsContext.class,0);</span>
		}
<span class="fc" id="L11083">		public NonWildcardTypeArgsContext(NonWildcardTypeArgumentsOrDiamondContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11086" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitNonWildcardTypeArgs(this);</span>
<span class="nc" id="L11087">			else return visitor.visitChildren(this);</span>
		}
	}

	public final NonWildcardTypeArgumentsOrDiamondContext nonWildcardTypeArgumentsOrDiamond() throws RecognitionException {
<span class="fc" id="L11092">		NonWildcardTypeArgumentsOrDiamondContext _localctx = new NonWildcardTypeArgumentsOrDiamondContext(_ctx, getState());</span>
<span class="fc" id="L11093">		enterRule(_localctx, 248, RULE_nonWildcardTypeArgumentsOrDiamond);</span>
		try {
<span class="fc" id="L11095">			setState(1618);</span>
<span class="fc" id="L11096">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11097" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,191,_ctx) ) {</span>
			case 1:
<span class="fc" id="L11099">				_localctx = new NonWildcardDiamondContext(_localctx);</span>
<span class="fc" id="L11100">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L11102">				setState(1615);</span>
<span class="fc" id="L11103">				match(LT);</span>
<span class="fc" id="L11104">				setState(1616);</span>
<span class="fc" id="L11105">				match(GT);</span>
				}
<span class="fc" id="L11107">				break;</span>
			case 2:
<span class="fc" id="L11109">				_localctx = new NonWildcardTypeArgsContext(_localctx);</span>
<span class="fc" id="L11110">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L11112">				setState(1617);</span>
<span class="fc" id="L11113">				nonWildcardTypeArguments();</span>
				}
				break;
			}
		}
<span class="nc" id="L11118">		catch (RecognitionException re) {</span>
<span class="nc" id="L11119">			_localctx.exception = re;</span>
<span class="nc" id="L11120">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11121">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11124">			exitRule();</span>
		}
<span class="fc" id="L11126">		return _localctx;</span>
	}

	public static class NonWildcardTypeArgumentsContext extends ParserRuleContext {
<span class="fc" id="L11130">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
		public TypeArgumentsTypeListContext typeArgumentsTypeList() {
<span class="fc" id="L11132">			return getRuleContext(TypeArgumentsTypeListContext.class,0);</span>
		}
<span class="fc" id="L11134">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
		public NonWildcardTypeArgumentsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11136">			super(parent, invokingState);</span>
<span class="fc" id="L11137">		}</span>
<span class="nc" id="L11138">		@Override public int getRuleIndex() { return RULE_nonWildcardTypeArguments; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11141" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitNonWildcardTypeArguments(this);</span>
<span class="nc" id="L11142">			else return visitor.visitChildren(this);</span>
		}
	}

	public final NonWildcardTypeArgumentsContext nonWildcardTypeArguments() throws RecognitionException {
<span class="fc" id="L11147">		NonWildcardTypeArgumentsContext _localctx = new NonWildcardTypeArgumentsContext(_ctx, getState());</span>
<span class="fc" id="L11148">		enterRule(_localctx, 250, RULE_nonWildcardTypeArguments);</span>
		try {
<span class="fc" id="L11150">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11152">			setState(1620);</span>
<span class="fc" id="L11153">			match(LT);</span>
<span class="fc" id="L11154">			setState(1621);</span>
<span class="fc" id="L11155">			typeArgumentsTypeList();</span>
<span class="fc" id="L11156">			setState(1622);</span>
<span class="fc" id="L11157">			match(GT);</span>
			}
		}
<span class="nc" id="L11160">		catch (RecognitionException re) {</span>
<span class="nc" id="L11161">			_localctx.exception = re;</span>
<span class="nc" id="L11162">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11163">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11166">			exitRule();</span>
		}
<span class="fc" id="L11168">		return _localctx;</span>
	}

	public static class TypeArgumentsTypeListContext extends ParserRuleContext {
		public List&lt;TypeTypeContext&gt; typeType() {
<span class="nc" id="L11173">			return getRuleContexts(TypeTypeContext.class);</span>
		}
		public TypeTypeContext typeType(int i) {
<span class="fc" id="L11176">			return getRuleContext(TypeTypeContext.class,i);</span>
		}
<span class="fc" id="L11178">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="fc" id="L11180">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public TypeArgumentsTypeListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11183">			super(parent, invokingState);</span>
<span class="fc" id="L11184">		}</span>
<span class="nc" id="L11185">		@Override public int getRuleIndex() { return RULE_typeArgumentsTypeList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11188" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeArgumentsTypeList(this);</span>
<span class="nc" id="L11189">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeArgumentsTypeListContext typeArgumentsTypeList() throws RecognitionException {
<span class="fc" id="L11194">		TypeArgumentsTypeListContext _localctx = new TypeArgumentsTypeListContext(_ctx, getState());</span>
<span class="fc" id="L11195">		enterRule(_localctx, 252, RULE_typeArgumentsTypeList);</span>
		int _la;
		try {
<span class="fc" id="L11198">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11200">			setState(1624);</span>
<span class="fc" id="L11201">			typeType(false);</span>
<span class="fc" id="L11202">			setState(1629);</span>
<span class="fc" id="L11203">			_errHandler.sync(this);</span>
<span class="fc" id="L11204">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L11205" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L11208">				setState(1625);</span>
<span class="fc" id="L11209">				match(COMMA);</span>
<span class="fc" id="L11210">				setState(1626);</span>
<span class="fc" id="L11211">				typeType(false);</span>
				}
				}
<span class="fc" id="L11214">				setState(1631);</span>
<span class="fc" id="L11215">				_errHandler.sync(this);</span>
<span class="fc" id="L11216">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L11220">		catch (RecognitionException re) {</span>
<span class="nc" id="L11221">			_localctx.exception = re;</span>
<span class="nc" id="L11222">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11223">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11226">			exitRule();</span>
		}
<span class="fc" id="L11228">		return _localctx;</span>
	}

	public static class TypeListContext extends ParserRuleContext {
		public List&lt;TypeTypeContext&gt; typeType() {
<span class="nc" id="L11233">			return getRuleContexts(TypeTypeContext.class);</span>
		}
		public TypeTypeContext typeType(int i) {
<span class="nc" id="L11236">			return getRuleContext(TypeTypeContext.class,i);</span>
		}
<span class="nc" id="L11238">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L11240">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public TypeListContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11243">			super(parent, invokingState);</span>
<span class="fc" id="L11244">		}</span>
<span class="nc" id="L11245">		@Override public int getRuleIndex() { return RULE_typeList; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11248" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeList(this);</span>
<span class="nc" id="L11249">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeListContext typeList() throws RecognitionException {
<span class="fc" id="L11254">		TypeListContext _localctx = new TypeListContext(_ctx, getState());</span>
<span class="fc" id="L11255">		enterRule(_localctx, 254, RULE_typeList);</span>
		int _la;
		try {
<span class="fc" id="L11258">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11260">			setState(1632);</span>
<span class="fc" id="L11261">			typeType(false);</span>
<span class="fc" id="L11262">			setState(1637);</span>
<span class="fc" id="L11263">			_errHandler.sync(this);</span>
<span class="fc" id="L11264">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L11265" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L11268">				setState(1633);</span>
<span class="fc" id="L11269">				match(COMMA);</span>
<span class="fc" id="L11270">				setState(1634);</span>
<span class="fc" id="L11271">				typeType(false);</span>
				}
				}
<span class="fc" id="L11274">				setState(1639);</span>
<span class="fc" id="L11275">				_errHandler.sync(this);</span>
<span class="fc" id="L11276">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L11280">		catch (RecognitionException re) {</span>
<span class="nc" id="L11281">			_localctx.exception = re;</span>
<span class="nc" id="L11282">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11283">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11286">			exitRule();</span>
		}
<span class="fc" id="L11288">		return _localctx;</span>
	}

	public static class TypeTypeContext extends ParserRuleContext {
		public boolean createImaginaryNode;
		public AnnotationsContext annotations() {
<span class="nc" id="L11294">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() {
<span class="nc" id="L11297">			return getRuleContext(ClassOrInterfaceOrPrimitiveTypeContext.class,0);</span>
		}
		public List&lt;ArrayDeclaratorContext&gt; arrayDeclarator() {
<span class="nc" id="L11300">			return getRuleContexts(ArrayDeclaratorContext.class);</span>
		}
		public ArrayDeclaratorContext arrayDeclarator(int i) {
<span class="nc" id="L11303">			return getRuleContext(ArrayDeclaratorContext.class,i);</span>
		}
<span class="nc" id="L11305">		public TypeTypeContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }</span>
		public TypeTypeContext(ParserRuleContext parent, int invokingState, boolean createImaginaryNode) {
<span class="fc" id="L11307">			super(parent, invokingState);</span>
<span class="fc" id="L11308">			this.createImaginaryNode = createImaginaryNode;</span>
<span class="fc" id="L11309">		}</span>
<span class="nc" id="L11310">		@Override public int getRuleIndex() { return RULE_typeType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11313" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeType(this);</span>
<span class="nc" id="L11314">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeTypeContext typeType(boolean createImaginaryNode) throws RecognitionException {
<span class="fc" id="L11319">		TypeTypeContext _localctx = new TypeTypeContext(_ctx, getState(), createImaginaryNode);</span>
<span class="fc" id="L11320">		enterRule(_localctx, 256, RULE_typeType);</span>
		try {
			int _alt;
<span class="fc" id="L11323">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11325">			setState(1640);</span>
<span class="fc" id="L11326">			annotations(false);</span>
<span class="fc" id="L11327">			setState(1641);</span>
<span class="fc" id="L11328">			classOrInterfaceOrPrimitiveType();</span>
<span class="fc" id="L11329">			setState(1645);</span>
<span class="fc" id="L11330">			_errHandler.sync(this);</span>
<span class="fc" id="L11331">			_alt = getInterpreter().adaptivePredict(_input,194,_ctx);</span>
<span class="pc bpc" id="L11332" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L11333" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L11336">					setState(1642);</span>
<span class="fc" id="L11337">					arrayDeclarator();</span>
					}
					} 
				}
<span class="fc" id="L11341">				setState(1647);</span>
<span class="fc" id="L11342">				_errHandler.sync(this);</span>
<span class="fc" id="L11343">				_alt = getInterpreter().adaptivePredict(_input,194,_ctx);</span>
			}
			}
		}
<span class="nc" id="L11347">		catch (RecognitionException re) {</span>
<span class="nc" id="L11348">			_localctx.exception = re;</span>
<span class="nc" id="L11349">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11350">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11353">			exitRule();</span>
		}
<span class="fc" id="L11355">		return _localctx;</span>
	}

	public static class ClassOrInterfaceOrPrimitiveTypeContext extends ParserRuleContext {
		public ClassOrInterfaceTypeContext classOrInterfaceType() {
<span class="nc" id="L11360">			return getRuleContext(ClassOrInterfaceTypeContext.class,0);</span>
		}
		public PrimitiveTypeContext primitiveType() {
<span class="nc" id="L11363">			return getRuleContext(PrimitiveTypeContext.class,0);</span>
		}
		public ClassOrInterfaceOrPrimitiveTypeContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11366">			super(parent, invokingState);</span>
<span class="fc" id="L11367">		}</span>
<span class="nc" id="L11368">		@Override public int getRuleIndex() { return RULE_classOrInterfaceOrPrimitiveType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11371" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitClassOrInterfaceOrPrimitiveType(this);</span>
<span class="nc" id="L11372">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ClassOrInterfaceOrPrimitiveTypeContext classOrInterfaceOrPrimitiveType() throws RecognitionException {
<span class="fc" id="L11377">		ClassOrInterfaceOrPrimitiveTypeContext _localctx = new ClassOrInterfaceOrPrimitiveTypeContext(_ctx, getState());</span>
<span class="fc" id="L11378">		enterRule(_localctx, 258, RULE_classOrInterfaceOrPrimitiveType);</span>
		try {
<span class="fc" id="L11380">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11382">			setState(1650);</span>
<span class="fc" id="L11383">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11384" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case IDENT:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
				{
<span class="fc" id="L11393">				setState(1648);</span>
<span class="fc" id="L11394">				classOrInterfaceType(false);</span>
				}
<span class="fc" id="L11396">				break;</span>
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
				{
<span class="fc" id="L11407">				setState(1649);</span>
<span class="fc" id="L11408">				primitiveType();</span>
				}
<span class="fc" id="L11410">				break;</span>
			default:
<span class="nc" id="L11412">				throw new NoViableAltException(this);</span>
			}
			}
		}
<span class="nc" id="L11416">		catch (RecognitionException re) {</span>
<span class="nc" id="L11417">			_localctx.exception = re;</span>
<span class="nc" id="L11418">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11419">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11422">			exitRule();</span>
		}
<span class="fc" id="L11424">		return _localctx;</span>
	}

	public static class ArrayDeclaratorContext extends ParserRuleContext {
		public AnnotationsContext anno;
<span class="fc" id="L11429">		public TerminalNode LBRACK() { return getToken(JavaLanguageParser.LBRACK, 0); }</span>
<span class="fc" id="L11430">		public TerminalNode RBRACK() { return getToken(JavaLanguageParser.RBRACK, 0); }</span>
		public AnnotationsContext annotations() {
<span class="nc" id="L11432">			return getRuleContext(AnnotationsContext.class,0);</span>
		}
		public ArrayDeclaratorContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11435">			super(parent, invokingState);</span>
<span class="fc" id="L11436">		}</span>
<span class="nc" id="L11437">		@Override public int getRuleIndex() { return RULE_arrayDeclarator; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11440" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitArrayDeclarator(this);</span>
<span class="nc" id="L11441">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ArrayDeclaratorContext arrayDeclarator() throws RecognitionException {
<span class="fc" id="L11446">		ArrayDeclaratorContext _localctx = new ArrayDeclaratorContext(_ctx, getState());</span>
<span class="fc" id="L11447">		enterRule(_localctx, 260, RULE_arrayDeclarator);</span>
		try {
<span class="fc" id="L11449">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11451">			setState(1652);</span>
<span class="fc" id="L11452">			((ArrayDeclaratorContext)_localctx).anno = annotations(false);</span>
<span class="fc" id="L11453">			setState(1653);</span>
<span class="fc" id="L11454">			match(LBRACK);</span>
<span class="fc" id="L11455">			setState(1654);</span>
<span class="fc" id="L11456">			match(RBRACK);</span>
			}
		}
<span class="nc" id="L11459">		catch (RecognitionException re) {</span>
<span class="nc" id="L11460">			_localctx.exception = re;</span>
<span class="nc" id="L11461">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11462">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11465">			exitRule();</span>
		}
<span class="fc" id="L11467">		return _localctx;</span>
	}

	public static class PrimitiveTypeContext extends ParserRuleContext {
<span class="nc" id="L11471">		public TerminalNode LITERAL_BOOLEAN() { return getToken(JavaLanguageParser.LITERAL_BOOLEAN, 0); }</span>
<span class="nc" id="L11472">		public TerminalNode LITERAL_CHAR() { return getToken(JavaLanguageParser.LITERAL_CHAR, 0); }</span>
<span class="nc" id="L11473">		public TerminalNode LITERAL_BYTE() { return getToken(JavaLanguageParser.LITERAL_BYTE, 0); }</span>
<span class="nc" id="L11474">		public TerminalNode LITERAL_SHORT() { return getToken(JavaLanguageParser.LITERAL_SHORT, 0); }</span>
<span class="nc" id="L11475">		public TerminalNode LITERAL_INT() { return getToken(JavaLanguageParser.LITERAL_INT, 0); }</span>
<span class="nc" id="L11476">		public TerminalNode LITERAL_LONG() { return getToken(JavaLanguageParser.LITERAL_LONG, 0); }</span>
<span class="nc" id="L11477">		public TerminalNode LITERAL_FLOAT() { return getToken(JavaLanguageParser.LITERAL_FLOAT, 0); }</span>
<span class="nc" id="L11478">		public TerminalNode LITERAL_DOUBLE() { return getToken(JavaLanguageParser.LITERAL_DOUBLE, 0); }</span>
<span class="nc" id="L11479">		public TerminalNode LITERAL_VOID() { return getToken(JavaLanguageParser.LITERAL_VOID, 0); }</span>
		public PrimitiveTypeContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11481">			super(parent, invokingState);</span>
<span class="fc" id="L11482">		}</span>
<span class="nc" id="L11483">		@Override public int getRuleIndex() { return RULE_primitiveType; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11486" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPrimitiveType(this);</span>
<span class="nc" id="L11487">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PrimitiveTypeContext primitiveType() throws RecognitionException {
<span class="fc" id="L11492">		PrimitiveTypeContext _localctx = new PrimitiveTypeContext(_ctx, getState());</span>
<span class="fc" id="L11493">		enterRule(_localctx, 262, RULE_primitiveType);</span>
		int _la;
		try {
<span class="fc" id="L11496">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11498">			setState(1656);</span>
<span class="fc" id="L11499">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L11500" title="2 of 4 branches missed.">			if ( !((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE))) != 0)) ) {</span>
<span class="nc" id="L11501">			_errHandler.recoverInline(this);</span>
			}
			else {
<span class="pc bpc" id="L11504" title="1 of 2 branches missed.">				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L11505">				_errHandler.reportMatch(this);</span>
<span class="fc" id="L11506">				consume();</span>
			}
			}
		}
<span class="nc" id="L11510">		catch (RecognitionException re) {</span>
<span class="nc" id="L11511">			_localctx.exception = re;</span>
<span class="nc" id="L11512">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11513">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11516">			exitRule();</span>
		}
<span class="fc" id="L11518">		return _localctx;</span>
	}

	public static class TypeArgumentsContext extends ParserRuleContext {
<span class="fc" id="L11522">		public TerminalNode LT() { return getToken(JavaLanguageParser.LT, 0); }</span>
		public List&lt;TypeArgumentContext&gt; typeArgument() {
<span class="nc" id="L11524">			return getRuleContexts(TypeArgumentContext.class);</span>
		}
		public TypeArgumentContext typeArgument(int i) {
<span class="nc" id="L11527">			return getRuleContext(TypeArgumentContext.class,i);</span>
		}
<span class="fc" id="L11529">		public TerminalNode GT() { return getToken(JavaLanguageParser.GT, 0); }</span>
<span class="nc" id="L11530">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L11532">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public TypeArgumentsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11535">			super(parent, invokingState);</span>
<span class="fc" id="L11536">		}</span>
<span class="nc" id="L11537">		@Override public int getRuleIndex() { return RULE_typeArguments; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11540" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypeArguments(this);</span>
<span class="nc" id="L11541">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypeArgumentsContext typeArguments() throws RecognitionException {
<span class="fc" id="L11546">		TypeArgumentsContext _localctx = new TypeArgumentsContext(_ctx, getState());</span>
<span class="fc" id="L11547">		enterRule(_localctx, 264, RULE_typeArguments);</span>
		int _la;
		try {
<span class="fc" id="L11550">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11552">			setState(1658);</span>
<span class="fc" id="L11553">			match(LT);</span>
<span class="fc" id="L11554">			setState(1659);</span>
<span class="fc" id="L11555">			typeArgument();</span>
<span class="fc" id="L11556">			setState(1664);</span>
<span class="fc" id="L11557">			_errHandler.sync(this);</span>
<span class="fc" id="L11558">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L11559" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L11562">				setState(1660);</span>
<span class="fc" id="L11563">				match(COMMA);</span>
<span class="fc" id="L11564">				setState(1661);</span>
<span class="fc" id="L11565">				typeArgument();</span>
				}
				}
<span class="fc" id="L11568">				setState(1666);</span>
<span class="fc" id="L11569">				_errHandler.sync(this);</span>
<span class="fc" id="L11570">				_la = _input.LA(1);</span>
			}
<span class="fc" id="L11572">			setState(1667);</span>
<span class="fc" id="L11573">			match(GT);</span>
			}
		}
<span class="nc" id="L11576">		catch (RecognitionException re) {</span>
<span class="nc" id="L11577">			_localctx.exception = re;</span>
<span class="nc" id="L11578">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11579">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11582">			exitRule();</span>
		}
<span class="fc" id="L11584">		return _localctx;</span>
	}

	public static class SuperSuffixContext extends ParserRuleContext {
		public SuperSuffixContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11589">			super(parent, invokingState);</span>
<span class="fc" id="L11590">		}</span>
<span class="nc" id="L11591">		@Override public int getRuleIndex() { return RULE_superSuffix; }</span>
	 
<span class="fc" id="L11593">		public SuperSuffixContext() { }</span>
		public void copyFrom(SuperSuffixContext ctx) {
<span class="fc" id="L11595">			super.copyFrom(ctx);</span>
<span class="fc" id="L11596">		}</span>
	}
	public static class SuperSuffixDotContext extends SuperSuffixContext {
<span class="fc" id="L11599">		public TerminalNode DOT() { return getToken(JavaLanguageParser.DOT, 0); }</span>
		public IdContext id() {
<span class="fc" id="L11601">			return getRuleContext(IdContext.class,0);</span>
		}
<span class="fc" id="L11603">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L11604">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="fc" id="L11606">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="fc" id="L11608">		public SuperSuffixDotContext(SuperSuffixContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11611" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSuperSuffixDot(this);</span>
<span class="nc" id="L11612">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class SuperSuffixSimpleContext extends SuperSuffixContext {
<span class="nc" id="L11616">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="nc" id="L11617">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="nc" id="L11619">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
<span class="nc" id="L11621">		public SuperSuffixSimpleContext(SuperSuffixContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="nc bnc" id="L11624" title="All 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitSuperSuffixSimple(this);</span>
<span class="nc" id="L11625">			else return visitor.visitChildren(this);</span>
		}
	}

	public final SuperSuffixContext superSuffix() throws RecognitionException {
<span class="fc" id="L11630">		SuperSuffixContext _localctx = new SuperSuffixContext(_ctx, getState());</span>
<span class="fc" id="L11631">		enterRule(_localctx, 266, RULE_superSuffix);</span>
		int _la;
		try {
<span class="fc" id="L11634">			setState(1683);</span>
<span class="fc" id="L11635">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11636" title="2 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case LPAREN:
<span class="nc" id="L11638">				_localctx = new SuperSuffixSimpleContext(_localctx);</span>
<span class="nc" id="L11639">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="nc" id="L11641">				setState(1669);</span>
<span class="nc" id="L11642">				match(LPAREN);</span>
<span class="nc" id="L11643">				setState(1671);</span>
<span class="nc" id="L11644">				_errHandler.sync(this);</span>
<span class="nc" id="L11645">				_la = _input.LA(1);</span>
<span class="nc bnc" id="L11646" title="All 12 branches missed.">				if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
					{
<span class="nc" id="L11648">					setState(1670);</span>
<span class="nc" id="L11649">					expressionList();</span>
					}
				}

<span class="nc" id="L11653">				setState(1673);</span>
<span class="nc" id="L11654">				match(RPAREN);</span>
				}
<span class="nc" id="L11656">				break;</span>
			case DOT:
<span class="fc" id="L11658">				_localctx = new SuperSuffixDotContext(_localctx);</span>
<span class="fc" id="L11659">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L11661">				setState(1674);</span>
<span class="fc" id="L11662">				match(DOT);</span>
<span class="fc" id="L11663">				setState(1675);</span>
<span class="fc" id="L11664">				id();</span>
<span class="fc" id="L11665">				setState(1681);</span>
<span class="fc" id="L11666">				_errHandler.sync(this);</span>
<span class="fc bfc" id="L11667" title="All 2 branches covered.">				switch ( getInterpreter().adaptivePredict(_input,199,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L11670">					setState(1676);</span>
<span class="fc" id="L11671">					match(LPAREN);</span>
<span class="fc" id="L11672">					setState(1678);</span>
<span class="fc" id="L11673">					_errHandler.sync(this);</span>
<span class="fc" id="L11674">					_la = _input.LA(1);</span>
<span class="pc bpc" id="L11675" title="7 of 12 branches missed.">					if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
						{
<span class="fc" id="L11677">						setState(1677);</span>
<span class="fc" id="L11678">						expressionList();</span>
						}
					}

<span class="fc" id="L11682">					setState(1680);</span>
<span class="fc" id="L11683">					match(RPAREN);</span>
					}
					break;
				}
				}
<span class="fc" id="L11688">				break;</span>
			default:
<span class="nc" id="L11690">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L11693">		catch (RecognitionException re) {</span>
<span class="nc" id="L11694">			_localctx.exception = re;</span>
<span class="nc" id="L11695">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11696">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11699">			exitRule();</span>
		}
<span class="fc" id="L11701">		return _localctx;</span>
	}

	public static class ArgumentsContext extends ParserRuleContext {
<span class="fc" id="L11705">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L11706">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public ExpressionListContext expressionList() {
<span class="fc" id="L11708">			return getRuleContext(ExpressionListContext.class,0);</span>
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11711">			super(parent, invokingState);</span>
<span class="fc" id="L11712">		}</span>
<span class="nc" id="L11713">		@Override public int getRuleIndex() { return RULE_arguments; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11716" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitArguments(this);</span>
<span class="nc" id="L11717">			else return visitor.visitChildren(this);</span>
		}
	}

	public final ArgumentsContext arguments() throws RecognitionException {
<span class="fc" id="L11722">		ArgumentsContext _localctx = new ArgumentsContext(_ctx, getState());</span>
<span class="fc" id="L11723">		enterRule(_localctx, 268, RULE_arguments);</span>
		int _la;
		try {
<span class="fc" id="L11726">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11728">			setState(1685);</span>
<span class="fc" id="L11729">			match(LPAREN);</span>
<span class="fc" id="L11730">			setState(1687);</span>
<span class="fc" id="L11731">			_errHandler.sync(this);</span>
<span class="fc" id="L11732">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L11733" title="2 of 12 branches missed.">			if ((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; ((1L &lt;&lt; LITERAL_VOID) | (1L &lt;&lt; LITERAL_BOOLEAN) | (1L &lt;&lt; LITERAL_BYTE) | (1L &lt;&lt; LITERAL_CHAR) | (1L &lt;&lt; LITERAL_SHORT) | (1L &lt;&lt; LITERAL_INT) | (1L &lt;&lt; LITERAL_FLOAT) | (1L &lt;&lt; LITERAL_LONG) | (1L &lt;&lt; LITERAL_DOUBLE) | (1L &lt;&lt; IDENT))) != 0) || ((((_la - 76)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 76)) &amp; ((1L &lt;&lt; (LPAREN - 76)) | (1L &lt;&lt; (LITERAL_THIS - 76)) | (1L &lt;&lt; (LITERAL_SUPER - 76)) | (1L &lt;&lt; (LITERAL_SWITCH - 76)) | (1L &lt;&lt; (PLUS - 76)) | (1L &lt;&lt; (MINUS - 76)) | (1L &lt;&lt; (INC - 76)) | (1L &lt;&lt; (DEC - 76)) | (1L &lt;&lt; (BNOT - 76)) | (1L &lt;&lt; (LNOT - 76)) | (1L &lt;&lt; (LITERAL_TRUE - 76)) | (1L &lt;&lt; (LITERAL_FALSE - 76)) | (1L &lt;&lt; (LITERAL_NULL - 76)) | (1L &lt;&lt; (LITERAL_NEW - 76)) | (1L &lt;&lt; (CHAR_LITERAL - 76)) | (1L &lt;&lt; (STRING_LITERAL - 76)))) != 0) || ((((_la - 170)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 170)) &amp; ((1L &lt;&lt; (AT - 170)) | (1L &lt;&lt; (FLOAT_LITERAL - 170)) | (1L &lt;&lt; (DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (HEX_FLOAT_LITERAL - 170)) | (1L &lt;&lt; (HEX_DOUBLE_LITERAL - 170)) | (1L &lt;&lt; (LITERAL_RECORD - 170)) | (1L &lt;&lt; (TEXT_BLOCK_LITERAL_BEGIN - 170)) | (1L &lt;&lt; (LITERAL_YIELD - 170)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 170)) | (1L &lt;&lt; (LITERAL_SEALED - 170)) | (1L &lt;&lt; (LITERAL_PERMITS - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL_LONG - 170)) | (1L &lt;&lt; (DECIMAL_LITERAL - 170)) | (1L &lt;&lt; (HEX_LITERAL_LONG - 170)) | (1L &lt;&lt; (HEX_LITERAL - 170)) | (1L &lt;&lt; (OCT_LITERAL_LONG - 170)) | (1L &lt;&lt; (OCT_LITERAL - 170)) | (1L &lt;&lt; (BINARY_LITERAL_LONG - 170)) | (1L &lt;&lt; (BINARY_LITERAL - 170)))) != 0)) {</span>
				{
<span class="fc" id="L11735">				setState(1686);</span>
<span class="fc" id="L11736">				expressionList();</span>
				}
			}

<span class="fc" id="L11740">			setState(1689);</span>
<span class="fc" id="L11741">			match(RPAREN);</span>
			}
		}
<span class="nc" id="L11744">		catch (RecognitionException re) {</span>
<span class="nc" id="L11745">			_localctx.exception = re;</span>
<span class="nc" id="L11746">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11747">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11750">			exitRule();</span>
		}
<span class="fc" id="L11752">		return _localctx;</span>
	}

	public static class PatternContext extends ParserRuleContext {
		public GuardedPatternContext guardedPattern() {
<span class="nc" id="L11757">			return getRuleContext(GuardedPatternContext.class,0);</span>
		}
		public PrimaryPatternContext primaryPattern() {
<span class="fc" id="L11760">			return getRuleContext(PrimaryPatternContext.class,0);</span>
		}
		public PatternContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11763">			super(parent, invokingState);</span>
<span class="fc" id="L11764">		}</span>
<span class="nc" id="L11765">		@Override public int getRuleIndex() { return RULE_pattern; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11768" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPattern(this);</span>
<span class="nc" id="L11769">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PatternContext pattern() throws RecognitionException {
<span class="fc" id="L11774">		PatternContext _localctx = new PatternContext(_ctx, getState());</span>
<span class="fc" id="L11775">		enterRule(_localctx, 270, RULE_pattern);</span>
		try {
<span class="fc" id="L11777">			setState(1693);</span>
<span class="fc" id="L11778">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11779" title="1 of 3 branches missed.">			switch ( getInterpreter().adaptivePredict(_input,202,_ctx) ) {</span>
			case 1:
<span class="fc" id="L11781">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L11783">				setState(1691);</span>
<span class="fc" id="L11784">				guardedPattern();</span>
				}
<span class="fc" id="L11786">				break;</span>
			case 2:
<span class="fc" id="L11788">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L11790">				setState(1692);</span>
<span class="fc" id="L11791">				primaryPattern();</span>
				}
				break;
			}
		}
<span class="nc" id="L11796">		catch (RecognitionException re) {</span>
<span class="nc" id="L11797">			_localctx.exception = re;</span>
<span class="nc" id="L11798">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11799">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11802">			exitRule();</span>
		}
<span class="fc" id="L11804">		return _localctx;</span>
	}

	public static class GuardedPatternContext extends ParserRuleContext {
		public PrimaryPatternContext primaryPattern() {
<span class="fc" id="L11809">			return getRuleContext(PrimaryPatternContext.class,0);</span>
		}
<span class="fc" id="L11811">		public TerminalNode LAND() { return getToken(JavaLanguageParser.LAND, 0); }</span>
		public ExprContext expr() {
<span class="fc" id="L11813">			return getRuleContext(ExprContext.class,0);</span>
		}
		public GuardedPatternContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11816">			super(parent, invokingState);</span>
<span class="fc" id="L11817">		}</span>
<span class="nc" id="L11818">		@Override public int getRuleIndex() { return RULE_guardedPattern; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11821" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitGuardedPattern(this);</span>
<span class="nc" id="L11822">			else return visitor.visitChildren(this);</span>
		}
	}

	public final GuardedPatternContext guardedPattern() throws RecognitionException {
<span class="fc" id="L11827">		GuardedPatternContext _localctx = new GuardedPatternContext(_ctx, getState());</span>
<span class="fc" id="L11828">		enterRule(_localctx, 272, RULE_guardedPattern);</span>
		try {
<span class="fc" id="L11830">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L11832">			setState(1695);</span>
<span class="fc" id="L11833">			primaryPattern();</span>
<span class="fc" id="L11834">			setState(1696);</span>
<span class="fc" id="L11835">			match(LAND);</span>
<span class="fc" id="L11836">			setState(1697);</span>
<span class="fc" id="L11837">			expr(0);</span>
			}
		}
<span class="nc" id="L11840">		catch (RecognitionException re) {</span>
<span class="nc" id="L11841">			_localctx.exception = re;</span>
<span class="nc" id="L11842">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11843">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11846">			exitRule();</span>
		}
<span class="fc" id="L11848">		return _localctx;</span>
	}

	public static class PrimaryPatternContext extends ParserRuleContext {
		public PrimaryPatternContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11853">			super(parent, invokingState);</span>
<span class="fc" id="L11854">		}</span>
<span class="nc" id="L11855">		@Override public int getRuleIndex() { return RULE_primaryPattern; }</span>
	 
<span class="fc" id="L11857">		public PrimaryPatternContext() { }</span>
		public void copyFrom(PrimaryPatternContext ctx) {
<span class="fc" id="L11859">			super.copyFrom(ctx);</span>
<span class="fc" id="L11860">		}</span>
	}
	public static class PatternVariableDefContext extends PrimaryPatternContext {
		public TypePatternContext typePattern() {
<span class="nc" id="L11864">			return getRuleContext(TypePatternContext.class,0);</span>
		}
<span class="fc" id="L11866">		public PatternVariableDefContext(PrimaryPatternContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11869" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPatternVariableDef(this);</span>
<span class="nc" id="L11870">			else return visitor.visitChildren(this);</span>
		}
	}
	public static class ParenPatternContext extends PrimaryPatternContext {
<span class="fc" id="L11874">		public TerminalNode LPAREN() { return getToken(JavaLanguageParser.LPAREN, 0); }</span>
<span class="fc" id="L11875">		public TerminalNode RPAREN() { return getToken(JavaLanguageParser.RPAREN, 0); }</span>
		public GuardedPatternContext guardedPattern() {
<span class="nc" id="L11877">			return getRuleContext(GuardedPatternContext.class,0);</span>
		}
		public PrimaryPatternContext primaryPattern() {
<span class="nc" id="L11880">			return getRuleContext(PrimaryPatternContext.class,0);</span>
		}
<span class="fc" id="L11882">		public ParenPatternContext(PrimaryPatternContext ctx) { copyFrom(ctx); }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11885" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitParenPattern(this);</span>
<span class="nc" id="L11886">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PrimaryPatternContext primaryPattern() throws RecognitionException {
<span class="fc" id="L11891">		PrimaryPatternContext _localctx = new PrimaryPatternContext(_ctx, getState());</span>
<span class="fc" id="L11892">		enterRule(_localctx, 274, RULE_primaryPattern);</span>
		try {
<span class="fc" id="L11894">			setState(1707);</span>
<span class="fc" id="L11895">			_errHandler.sync(this);</span>
<span class="pc bpc" id="L11896" title="1 of 3 branches missed.">			switch (_input.LA(1)) {</span>
			case FINAL:
			case ABSTRACT:
			case STRICTFP:
			case LITERAL_VOID:
			case LITERAL_BOOLEAN:
			case LITERAL_BYTE:
			case LITERAL_CHAR:
			case LITERAL_SHORT:
			case LITERAL_INT:
			case LITERAL_FLOAT:
			case LITERAL_LONG:
			case LITERAL_DOUBLE:
			case IDENT:
			case LITERAL_PRIVATE:
			case LITERAL_PUBLIC:
			case LITERAL_PROTECTED:
			case LITERAL_STATIC:
			case LITERAL_TRANSIENT:
			case LITERAL_NATIVE:
			case LITERAL_SYNCHRONIZED:
			case LITERAL_VOLATILE:
			case LITERAL_DEFAULT:
			case AT:
			case LITERAL_RECORD:
			case LITERAL_YIELD:
			case LITERAL_NON_SEALED:
			case LITERAL_SEALED:
			case LITERAL_PERMITS:
<span class="fc" id="L11925">				_localctx = new PatternVariableDefContext(_localctx);</span>
<span class="fc" id="L11926">				enterOuterAlt(_localctx, 1);</span>
				{
<span class="fc" id="L11928">				setState(1699);</span>
<span class="fc" id="L11929">				typePattern();</span>
				}
<span class="fc" id="L11931">				break;</span>
			case LPAREN:
<span class="fc" id="L11933">				_localctx = new ParenPatternContext(_localctx);</span>
<span class="fc" id="L11934">				enterOuterAlt(_localctx, 2);</span>
				{
<span class="fc" id="L11936">				setState(1700);</span>
<span class="fc" id="L11937">				match(LPAREN);</span>
<span class="fc" id="L11938">				setState(1703);</span>
<span class="fc" id="L11939">				_errHandler.sync(this);</span>
<span class="pc bpc" id="L11940" title="1 of 3 branches missed.">				switch ( getInterpreter().adaptivePredict(_input,203,_ctx) ) {</span>
				case 1:
					{
<span class="fc" id="L11943">					setState(1701);</span>
<span class="fc" id="L11944">					guardedPattern();</span>
					}
<span class="fc" id="L11946">					break;</span>
				case 2:
					{
<span class="fc" id="L11949">					setState(1702);</span>
<span class="fc" id="L11950">					primaryPattern();</span>
					}
					break;
				}
<span class="fc" id="L11954">				setState(1705);</span>
<span class="fc" id="L11955">				match(RPAREN);</span>
				}
<span class="fc" id="L11957">				break;</span>
			default:
<span class="nc" id="L11959">				throw new NoViableAltException(this);</span>
			}
		}
<span class="nc" id="L11962">		catch (RecognitionException re) {</span>
<span class="nc" id="L11963">			_localctx.exception = re;</span>
<span class="nc" id="L11964">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L11965">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L11968">			exitRule();</span>
		}
<span class="fc" id="L11970">		return _localctx;</span>
	}

	public static class TypePatternContext extends ParserRuleContext {
		public ModifierContext modifier;
<span class="fc" id="L11975">		public List&lt;ModifierContext&gt; mods = new ArrayList&lt;ModifierContext&gt;();</span>
		public TypeTypeContext type;
		public IdContext id() {
<span class="fc" id="L11978">			return getRuleContext(IdContext.class,0);</span>
		}
		public TypeTypeContext typeType() {
<span class="nc" id="L11981">			return getRuleContext(TypeTypeContext.class,0);</span>
		}
		public List&lt;ModifierContext&gt; modifier() {
<span class="nc" id="L11984">			return getRuleContexts(ModifierContext.class);</span>
		}
		public ModifierContext modifier(int i) {
<span class="nc" id="L11987">			return getRuleContext(ModifierContext.class,i);</span>
		}
		public TypePatternContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L11990">			super(parent, invokingState);</span>
<span class="fc" id="L11991">		}</span>
<span class="nc" id="L11992">		@Override public int getRuleIndex() { return RULE_typePattern; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L11995" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitTypePattern(this);</span>
<span class="nc" id="L11996">			else return visitor.visitChildren(this);</span>
		}
	}

	public final TypePatternContext typePattern() throws RecognitionException {
<span class="fc" id="L12001">		TypePatternContext _localctx = new TypePatternContext(_ctx, getState());</span>
<span class="fc" id="L12002">		enterRule(_localctx, 276, RULE_typePattern);</span>
		try {
			int _alt;
<span class="fc" id="L12005">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L12007">			setState(1712);</span>
<span class="fc" id="L12008">			_errHandler.sync(this);</span>
<span class="fc" id="L12009">			_alt = getInterpreter().adaptivePredict(_input,205,_ctx);</span>
<span class="pc bpc" id="L12010" title="1 of 4 branches missed.">			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</span>
<span class="pc bpc" id="L12011" title="1 of 2 branches missed.">				if ( _alt==1 ) {</span>
					{
					{
<span class="fc" id="L12014">					setState(1709);</span>
<span class="fc" id="L12015">					((TypePatternContext)_localctx).modifier = modifier();</span>
<span class="fc" id="L12016">					((TypePatternContext)_localctx).mods.add(((TypePatternContext)_localctx).modifier);</span>
					}
					} 
				}
<span class="fc" id="L12020">				setState(1714);</span>
<span class="fc" id="L12021">				_errHandler.sync(this);</span>
<span class="fc" id="L12022">				_alt = getInterpreter().adaptivePredict(_input,205,_ctx);</span>
			}
<span class="fc" id="L12024">			setState(1715);</span>
<span class="fc" id="L12025">			((TypePatternContext)_localctx).type = typeType(true);</span>
<span class="fc" id="L12026">			setState(1716);</span>
<span class="fc" id="L12027">			id();</span>
			}
		}
<span class="nc" id="L12030">		catch (RecognitionException re) {</span>
<span class="nc" id="L12031">			_localctx.exception = re;</span>
<span class="nc" id="L12032">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L12033">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L12036">			exitRule();</span>
		}
<span class="fc" id="L12038">		return _localctx;</span>
	}

	public static class PermittedSubclassesAndInterfacesContext extends ParserRuleContext {
<span class="fc" id="L12042">		public TerminalNode LITERAL_PERMITS() { return getToken(JavaLanguageParser.LITERAL_PERMITS, 0); }</span>
		public List&lt;ClassOrInterfaceTypeContext&gt; classOrInterfaceType() {
<span class="nc" id="L12044">			return getRuleContexts(ClassOrInterfaceTypeContext.class);</span>
		}
		public ClassOrInterfaceTypeContext classOrInterfaceType(int i) {
<span class="nc" id="L12047">			return getRuleContext(ClassOrInterfaceTypeContext.class,i);</span>
		}
<span class="nc" id="L12049">		public List&lt;TerminalNode&gt; COMMA() { return getTokens(JavaLanguageParser.COMMA); }</span>
		public TerminalNode COMMA(int i) {
<span class="nc" id="L12051">			return getToken(JavaLanguageParser.COMMA, i);</span>
		}
		public PermittedSubclassesAndInterfacesContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L12054">			super(parent, invokingState);</span>
<span class="fc" id="L12055">		}</span>
<span class="nc" id="L12056">		@Override public int getRuleIndex() { return RULE_permittedSubclassesAndInterfaces; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L12059" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitPermittedSubclassesAndInterfaces(this);</span>
<span class="nc" id="L12060">			else return visitor.visitChildren(this);</span>
		}
	}

	public final PermittedSubclassesAndInterfacesContext permittedSubclassesAndInterfaces() throws RecognitionException {
<span class="fc" id="L12065">		PermittedSubclassesAndInterfacesContext _localctx = new PermittedSubclassesAndInterfacesContext(_ctx, getState());</span>
<span class="fc" id="L12066">		enterRule(_localctx, 278, RULE_permittedSubclassesAndInterfaces);</span>
		int _la;
		try {
<span class="fc" id="L12069">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L12071">			setState(1718);</span>
<span class="fc" id="L12072">			match(LITERAL_PERMITS);</span>
<span class="fc" id="L12073">			setState(1719);</span>
<span class="fc" id="L12074">			classOrInterfaceType(false);</span>
<span class="fc" id="L12075">			setState(1724);</span>
<span class="fc" id="L12076">			_errHandler.sync(this);</span>
<span class="fc" id="L12077">			_la = _input.LA(1);</span>
<span class="fc bfc" id="L12078" title="All 2 branches covered.">			while (_la==COMMA) {</span>
				{
				{
<span class="fc" id="L12081">				setState(1720);</span>
<span class="fc" id="L12082">				match(COMMA);</span>
<span class="fc" id="L12083">				setState(1721);</span>
<span class="fc" id="L12084">				classOrInterfaceType(false);</span>
				}
				}
<span class="fc" id="L12087">				setState(1726);</span>
<span class="fc" id="L12088">				_errHandler.sync(this);</span>
<span class="fc" id="L12089">				_la = _input.LA(1);</span>
			}
			}
		}
<span class="nc" id="L12093">		catch (RecognitionException re) {</span>
<span class="nc" id="L12094">			_localctx.exception = re;</span>
<span class="nc" id="L12095">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L12096">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L12099">			exitRule();</span>
		}
<span class="fc" id="L12101">		return _localctx;</span>
	}

	public static class IdContext extends ParserRuleContext {
<span class="nc" id="L12105">		public TerminalNode LITERAL_RECORD() { return getToken(JavaLanguageParser.LITERAL_RECORD, 0); }</span>
<span class="nc" id="L12106">		public TerminalNode LITERAL_YIELD() { return getToken(JavaLanguageParser.LITERAL_YIELD, 0); }</span>
<span class="nc" id="L12107">		public TerminalNode LITERAL_NON_SEALED() { return getToken(JavaLanguageParser.LITERAL_NON_SEALED, 0); }</span>
<span class="nc" id="L12108">		public TerminalNode LITERAL_SEALED() { return getToken(JavaLanguageParser.LITERAL_SEALED, 0); }</span>
<span class="nc" id="L12109">		public TerminalNode LITERAL_PERMITS() { return getToken(JavaLanguageParser.LITERAL_PERMITS, 0); }</span>
<span class="nc" id="L12110">		public TerminalNode IDENT() { return getToken(JavaLanguageParser.IDENT, 0); }</span>
		public IdContext(ParserRuleContext parent, int invokingState) {
<span class="fc" id="L12112">			super(parent, invokingState);</span>
<span class="fc" id="L12113">		}</span>
<span class="nc" id="L12114">		@Override public int getRuleIndex() { return RULE_id; }</span>
		@Override
		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<span class="pc bpc" id="L12117" title="1 of 2 branches missed.">			if ( visitor instanceof JavaLanguageParserVisitor ) return ((JavaLanguageParserVisitor&lt;? extends T&gt;)visitor).visitId(this);</span>
<span class="nc" id="L12118">			else return visitor.visitChildren(this);</span>
		}
	}

	public final IdContext id() throws RecognitionException {
<span class="fc" id="L12123">		IdContext _localctx = new IdContext(_ctx, getState());</span>
<span class="fc" id="L12124">		enterRule(_localctx, 280, RULE_id);</span>
		int _la;
		try {
<span class="fc" id="L12127">			enterOuterAlt(_localctx, 1);</span>
			{
<span class="fc" id="L12129">			setState(1727);</span>
<span class="fc" id="L12130">			_la = _input.LA(1);</span>
<span class="pc bpc" id="L12131" title="2 of 6 branches missed.">			if ( !(_la==IDENT || ((((_la - 200)) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; (_la - 200)) &amp; ((1L &lt;&lt; (LITERAL_RECORD - 200)) | (1L &lt;&lt; (LITERAL_YIELD - 200)) | (1L &lt;&lt; (LITERAL_NON_SEALED - 200)) | (1L &lt;&lt; (LITERAL_SEALED - 200)) | (1L &lt;&lt; (LITERAL_PERMITS - 200)))) != 0)) ) {</span>
<span class="nc" id="L12132">			_errHandler.recoverInline(this);</span>
			}
			else {
<span class="pc bpc" id="L12135" title="1 of 2 branches missed.">				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</span>
<span class="fc" id="L12136">				_errHandler.reportMatch(this);</span>
<span class="fc" id="L12137">				consume();</span>
			}
			}
		}
<span class="nc" id="L12141">		catch (RecognitionException re) {</span>
<span class="nc" id="L12142">			_localctx.exception = re;</span>
<span class="nc" id="L12143">			_errHandler.reportError(this, re);</span>
<span class="nc" id="L12144">			_errHandler.recover(this, re);</span>
		}
		finally {
<span class="fc" id="L12147">			exitRule();</span>
		}
<span class="fc" id="L12149">		return _localctx;</span>
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
<span class="pc bpc" id="L12153" title="2 of 3 branches missed.">		switch (ruleIndex) {</span>
		case 77:
<span class="fc" id="L12155">			return blockStatement_sempred((BlockStatementContext)_localctx, predIndex);</span>
		case 108:
<span class="nc" id="L12157">			return expr_sempred((ExprContext)_localctx, predIndex);</span>
		}
<span class="nc" id="L12159">		return true;</span>
	}
	private boolean blockStatement_sempred(BlockStatementContext _localctx, int predIndex) {
<span class="pc bpc" id="L12162" title="1 of 2 branches missed.">		switch (predIndex) {</span>
		case 0:
<span class="fc bfc" id="L12164" title="All 2 branches covered.">			return !isYieldStatement();</span>
		}
<span class="nc" id="L12166">		return true;</span>
	}
	private boolean expr_sempred(ExprContext _localctx, int predIndex) {
<span class="nc bnc" id="L12169" title="All 23 branches missed.">		switch (predIndex) {</span>
		case 1:
<span class="nc" id="L12171">			return precpred(_ctx, 14);</span>
		case 2:
<span class="nc" id="L12173">			return precpred(_ctx, 13);</span>
		case 3:
<span class="nc" id="L12175">			return precpred(_ctx, 12);</span>
		case 4:
<span class="nc" id="L12177">			return precpred(_ctx, 10);</span>
		case 5:
<span class="nc" id="L12179">			return precpred(_ctx, 9);</span>
		case 6:
<span class="nc" id="L12181">			return precpred(_ctx, 8);</span>
		case 7:
<span class="nc" id="L12183">			return precpred(_ctx, 7);</span>
		case 8:
<span class="nc" id="L12185">			return precpred(_ctx, 6);</span>
		case 9:
<span class="nc" id="L12187">			return precpred(_ctx, 5);</span>
		case 10:
<span class="nc" id="L12189">			return precpred(_ctx, 4);</span>
		case 11:
<span class="nc" id="L12191">			return precpred(_ctx, 3);</span>
		case 12:
<span class="nc" id="L12193">			return precpred(_ctx, 2);</span>
		case 13:
<span class="nc" id="L12195">			return precpred(_ctx, 30);</span>
		case 14:
<span class="nc" id="L12197">			return precpred(_ctx, 29);</span>
		case 15:
<span class="nc" id="L12199">			return precpred(_ctx, 28);</span>
		case 16:
<span class="nc" id="L12201">			return precpred(_ctx, 27);</span>
		case 17:
<span class="nc" id="L12203">			return precpred(_ctx, 26);</span>
		case 18:
<span class="nc" id="L12205">			return precpred(_ctx, 25);</span>
		case 19:
<span class="nc" id="L12207">			return precpred(_ctx, 24);</span>
		case 20:
<span class="nc" id="L12209">			return precpred(_ctx, 21);</span>
		case 21:
<span class="nc" id="L12211">			return precpred(_ctx, 18);</span>
		case 22:
<span class="nc" id="L12213">			return precpred(_ctx, 11);</span>
		}
<span class="nc" id="L12215">		return true;</span>
	}

	public static final String _serializedATN =
		&quot;\u0004\u0001\u00df\u06c2\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001&quot;+
		&quot;\u0002\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002\u0004\u0007\u0004&quot;+
		&quot;\u0002\u0005\u0007\u0005\u0002\u0006\u0007\u0006\u0002\u0007\u0007\u0007&quot;+
		&quot;\u0002\b\u0007\b\u0002\t\u0007\t\u0002\n\u0007\n\u0002\u000b\u0007\u000b&quot;+
		&quot;\u0002\f\u0007\f\u0002\r\u0007\r\u0002\u000e\u0007\u000e\u0002\u000f\u0007&quot;+
		&quot;\u000f\u0002\u0010\u0007\u0010\u0002\u0011\u0007\u0011\u0002\u0012\u0007&quot;+
		&quot;\u0012\u0002\u0013\u0007\u0013\u0002\u0014\u0007\u0014\u0002\u0015\u0007&quot;+
		&quot;\u0015\u0002\u0016\u0007\u0016\u0002\u0017\u0007\u0017\u0002\u0018\u0007&quot;+
		&quot;\u0018\u0002\u0019\u0007\u0019\u0002\u001a\u0007\u001a\u0002\u001b\u0007&quot;+
		&quot;\u001b\u0002\u001c\u0007\u001c\u0002\u001d\u0007\u001d\u0002\u001e\u0007&quot;+
		&quot;\u001e\u0002\u001f\u0007\u001f\u0002 \u0007 \u0002!\u0007!\u0002\&quot;\u0007&quot;+
		&quot;\&quot;\u0002#\u0007#\u0002$\u0007$\u0002%\u0007%\u0002&amp;\u0007&amp;\u0002\'\u0007&quot;+
		&quot;\'\u0002(\u0007(\u0002)\u0007)\u0002*\u0007*\u0002+\u0007+\u0002,\u0007&quot;+
		&quot;,\u0002-\u0007-\u0002.\u0007.\u0002/\u0007/\u00020\u00070\u00021\u0007&quot;+
		&quot;1\u00022\u00072\u00023\u00073\u00024\u00074\u00025\u00075\u00026\u0007&quot;+
		&quot;6\u00027\u00077\u00028\u00078\u00029\u00079\u0002:\u0007:\u0002;\u0007&quot;+
		&quot;;\u0002&lt;\u0007&lt;\u0002=\u0007=\u0002&gt;\u0007&gt;\u0002?\u0007?\u0002@\u0007&quot;+
		&quot;@\u0002A\u0007A\u0002B\u0007B\u0002C\u0007C\u0002D\u0007D\u0002E\u0007&quot;+
		&quot;E\u0002F\u0007F\u0002G\u0007G\u0002H\u0007H\u0002I\u0007I\u0002J\u0007&quot;+
		&quot;J\u0002K\u0007K\u0002L\u0007L\u0002M\u0007M\u0002N\u0007N\u0002O\u0007&quot;+
		&quot;O\u0002P\u0007P\u0002Q\u0007Q\u0002R\u0007R\u0002S\u0007S\u0002T\u0007&quot;+
		&quot;T\u0002U\u0007U\u0002V\u0007V\u0002W\u0007W\u0002X\u0007X\u0002Y\u0007&quot;+
		&quot;Y\u0002Z\u0007Z\u0002[\u0007[\u0002\\\u0007\\\u0002]\u0007]\u0002^\u0007&quot;+
		&quot;^\u0002_\u0007_\u0002`\u0007`\u0002a\u0007a\u0002b\u0007b\u0002c\u0007&quot;+
		&quot;c\u0002d\u0007d\u0002e\u0007e\u0002f\u0007f\u0002g\u0007g\u0002h\u0007&quot;+
		&quot;h\u0002i\u0007i\u0002j\u0007j\u0002k\u0007k\u0002l\u0007l\u0002m\u0007&quot;+
		&quot;m\u0002n\u0007n\u0002o\u0007o\u0002p\u0007p\u0002q\u0007q\u0002r\u0007&quot;+
		&quot;r\u0002s\u0007s\u0002t\u0007t\u0002u\u0007u\u0002v\u0007v\u0002w\u0007&quot;+
		&quot;w\u0002x\u0007x\u0002y\u0007y\u0002z\u0007z\u0002{\u0007{\u0002|\u0007&quot;+
		&quot;|\u0002}\u0007}\u0002~\u0007~\u0002\u007f\u0007\u007f\u0002\u0080\u0007&quot;+
		&quot;\u0080\u0002\u0081\u0007\u0081\u0002\u0082\u0007\u0082\u0002\u0083\u0007&quot;+
		&quot;\u0083\u0002\u0084\u0007\u0084\u0002\u0085\u0007\u0085\u0002\u0086\u0007&quot;+
		&quot;\u0086\u0002\u0087\u0007\u0087\u0002\u0088\u0007\u0088\u0002\u0089\u0007&quot;+
		&quot;\u0089\u0002\u008a\u0007\u008a\u0002\u008b\u0007\u008b\u0002\u008c\u0007&quot;+
		&quot;\u008c\u0001\u0000\u0003\u0000\u011c\b\u0000\u0001\u0000\u0005\u0000\u011f&quot;+
		&quot;\b\u0000\n\u0000\f\u0000\u0122\t\u0000\u0001\u0000\u0005\u0000\u0125\b&quot;+
		&quot;\u0000\n\u0000\f\u0000\u0128\t\u0000\u0001\u0000\u0001\u0000\u0001\u0001&quot;+
		&quot;\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0002\u0001\u0002&quot;+
		&quot;\u0003\u0002\u0133\b\u0002\u0001\u0002\u0001\u0002\u0001\u0002\u0003\u0002&quot;+
		&quot;\u0138\b\u0002\u0001\u0002\u0001\u0002\u0001\u0002\u0003\u0002\u013d\b&quot;+
		&quot;\u0002\u0001\u0003\u0005\u0003\u0140\b\u0003\n\u0003\f\u0003\u0143\t\u0003&quot;+
		&quot;\u0001\u0003\u0001\u0003\u0004\u0003\u0147\b\u0003\u000b\u0003\f\u0003&quot;+
		&quot;\u0148\u0003\u0003\u014b\b\u0003\u0001\u0004\u0001\u0004\u0001\u0004\u0001&quot;+
		&quot;\u0004\u0001\u0004\u0003\u0004\u0152\b\u0004\u0001\u0005\u0001\u0005\u0001&quot;+
		&quot;\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001&quot;+
		&quot;\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001&quot;+
		&quot;\u0005\u0003\u0005\u0163\b\u0005\u0001\u0006\u0001\u0006\u0003\u0006\u0167&quot;+
		&quot;\b\u0006\u0001\u0007\u0001\u0007\u0001\u0007\u0003\u0007\u016c\b\u0007&quot;+
		&quot;\u0001\u0007\u0003\u0007\u016f\b\u0007\u0001\u0007\u0003\u0007\u0172\b&quot;+
		&quot;\u0007\u0001\u0007\u0003\u0007\u0175\b\u0007\u0001\u0007\u0001\u0007\u0001&quot;+
		&quot;\b\u0001\b\u0001\b\u0003\b\u017c\b\b\u0001\b\u0001\b\u0003\b\u0180\b\b&quot;+
		&quot;\u0001\b\u0001\b\u0001\t\u0001\t\u0003\t\u0186\b\t\u0001\t\u0001\t\u0001&quot;+
		&quot;\n\u0001\n\u0001\n\u0005\n\u018d\b\n\n\n\f\n\u0190\t\n\u0001\n\u0001\n&quot;+
		&quot;\u0003\n\u0194\b\n\u0001\n\u0003\n\u0197\b\n\u0001\u000b\u0001\u000b\u0001&quot;+
		&quot;\u000b\u0001\u000b\u0001\f\u0001\f\u0001\f\u0001\f\u0001\f\u0001\r\u0001&quot;+
		&quot;\r\u0005\r\u01a4\b\r\n\r\f\r\u01a7\t\r\u0001\r\u0001\r\u0001\u000e\u0001&quot;+
		&quot;\u000e\u0003\u000e\u01ad\b\u000e\u0001\u000f\u0005\u000f\u01b0\b\u000f&quot;+
		&quot;\n\u000f\f\u000f\u01b3\t\u000f\u0001\u000f\u0001\u000f\u0001\u000f\u0001&quot;+
		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0011\u0001\u0011\u0001\u0011\u0001&quot;+
		&quot;\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0005\u0012\u01c2\b\u0012\n&quot;+
		&quot;\u0012\f\u0012\u01c5\t\u0012\u0001\u0012\u0001\u0012\u0001\u0013\u0001&quot;+
		&quot;\u0013\u0001\u0013\u0003\u0013\u01cc\b\u0013\u0001\u0014\u0001\u0014\u0001&quot;+
		&quot;\u0014\u0001\u0014\u0001\u0015\u0001\u0015\u0001\u0015\u0005\u0015\u01d5&quot;+
		&quot;\b\u0015\n\u0015\f\u0015\u01d8\t\u0015\u0001\u0016\u0001\u0016\u0001\u0016&quot;+
		&quot;\u0005\u0016\u01dd\b\u0016\n\u0016\f\u0016\u01e0\t\u0016\u0001\u0017\u0001&quot;+
		&quot;\u0017\u0001\u0017\u0003\u0017\u01e5\b\u0017\u0001\u0017\u0001\u0017\u0001&quot;+
		&quot;\u0018\u0001\u0018\u0003\u0018\u01eb\b\u0018\u0001\u0018\u0003\u0018\u01ee&quot;+
		&quot;\b\u0018\u0001\u0018\u0003\u0018\u01f1\b\u0018\u0001\u0018\u0001\u0018&quot;+
		&quot;\u0001\u0019\u0001\u0019\u0001\u0019\u0005\u0019\u01f8\b\u0019\n\u0019&quot;+
		&quot;\f\u0019\u01fb\t\u0019\u0001\u001a\u0001\u001a\u0001\u001a\u0003\u001a&quot;+
		&quot;\u0200\b\u001a\u0001\u001a\u0003\u001a\u0203\b\u001a\u0001\u001b\u0001&quot;+
		&quot;\u001b\u0005\u001b\u0207\b\u001b\n\u001b\f\u001b\u020a\t\u001b\u0001\u001c&quot;+
		&quot;\u0001\u001c\u0001\u001c\u0003\u001c\u020f\b\u001c\u0001\u001c\u0003\u001c&quot;+
		&quot;\u0212\b\u001c\u0001\u001c\u0003\u001c\u0215\b\u001c\u0001\u001c\u0001&quot;+
		&quot;\u001c\u0001\u001d\u0001\u001d\u0001\u001d\u0001\u001e\u0001\u001e\u0005&quot;+
		&quot;\u001e\u021e\b\u001e\n\u001e\f\u001e\u0221\t\u001e\u0001\u001e\u0001\u001e&quot;+
		&quot;\u0001\u001f\u0001\u001f\u0005\u001f\u0227\b\u001f\n\u001f\f\u001f\u022a&quot;+
		&quot;\t\u001f\u0001\u001f\u0001\u001f\u0001 \u0001 \u0003 \u0230\b \u0001 &quot;+
		&quot;\u0001 \u0005 \u0234\b \n \f \u0237\t \u0001 \u0003 \u023a\b \u0001!\u0001&quot;+
		&quot;!\u0001!\u0001!\u0001!\u0001!\u0001!\u0001!\u0003!\u0244\b!\u0001\&quot;\u0003&quot;+
		&quot;\&quot;\u0247\b\&quot;\u0001\&quot;\u0001\&quot;\u0001\&quot;\u0001\&quot;\u0005\&quot;\u024d\b\&quot;\n\&quot;\f\&quot;&quot;+
		&quot;\u0250\t\&quot;\u0001\&quot;\u0003\&quot;\u0253\b\&quot;\u0001\&quot;\u0001\&quot;\u0001#\u0001#\u0003&quot;+
		&quot;#\u0259\b#\u0001$\u0001$\u0001$\u0001%\u0003%\u025f\b%\u0001%\u0001%\u0001&quot;+
		&quot;%\u0003%\u0264\b%\u0001%\u0001%\u0001&amp;\u0001&amp;\u0001&amp;\u0001&amp;\u0001\'\u0005&quot;+
		&quot;\'\u026d\b\'\n\'\f\'\u0270\t\'\u0001\'\u0001\'\u0003\'\u0274\b\'\u0001&quot;+
		&quot;(\u0001(\u0001(\u0001(\u0001(\u0001(\u0001(\u0003(\u027d\b(\u0001)\u0003&quot;+
		&quot;)\u0280\b)\u0001)\u0001)\u0001)\u0001)\u0005)\u0286\b)\n)\f)\u0289\t)&quot;+
		&quot;\u0001)\u0003)\u028c\b)\u0001)\u0001)\u0001*\u0001*\u0001*\u0005*\u0293&quot;+
		&quot;\b*\n*\f*\u0296\t*\u0001+\u0001+\u0005+\u029a\b+\n+\f+\u029d\t+\u0001&quot;+
		&quot;+\u0001+\u0003+\u02a1\b+\u0001,\u0001,\u0001,\u0001,\u0003,\u02a7\b,\u0003&quot;+
		&quot;,\u02a9\b,\u0001,\u0005,\u02ac\b,\n,\f,\u02af\t,\u0001-\u0001-\u0003-&quot;+
		&quot;\u02b3\b-\u0001.\u0001.\u0001.\u0001.\u0005.\u02b9\b.\n.\f.\u02bc\t.\u0003&quot;+
		&quot;.\u02be\b.\u0001.\u0003.\u02c1\b.\u0001.\u0001.\u0001/\u0001/\u0001/\u0003&quot;+
		&quot;/\u02c8\b/\u0001/\u0005/\u02cb\b/\n/\f/\u02ce\t/\u00010\u00010\u00010&quot;+
		&quot;\u00010\u00030\u02d4\b0\u00011\u00011\u00011\u00011\u00011\u00031\u02db&quot;+
		&quot;\b1\u00011\u00031\u02de\b1\u00031\u02e0\b1\u00012\u00012\u00012\u0001&quot;+
		&quot;2\u00012\u00012\u00052\u02e8\b2\n2\f2\u02eb\t2\u00013\u00013\u00033\u02ef&quot;+
		&quot;\b3\u00013\u00013\u00014\u00014\u00014\u00054\u02f6\b4\n4\f4\u02f9\t4&quot;+
		&quot;\u00014\u00014\u00034\u02fd\b4\u00014\u00034\u0300\b4\u00015\u00055\u0303&quot;+
		&quot;\b5\n5\f5\u0306\t5\u00015\u00015\u00015\u00016\u00056\u030c\b6\n6\f6\u030f&quot;+
		&quot;\t6\u00016\u00016\u00016\u00016\u00016\u00017\u00017\u00057\u0318\b7\n&quot;+
		&quot;7\f7\u031b\t7\u00018\u00018\u00018\u00018\u00019\u00019\u00019\u00019&quot;+
		&quot;\u00019\u00019\u00019\u00019\u00039\u0329\b9\u0001:\u0001:\u0001;\u0001&quot;+
		&quot;;\u0001&lt;\u0001&lt;\u0001&lt;\u0001&lt;\u0001=\u0005=\u0334\b=\n=\f=\u0337\t=\u0001&quot;+
		&quot;&gt;\u0001&gt;\u0001&gt;\u0001&gt;\u0001&gt;\u0003&gt;\u033e\b&gt;\u0001&gt;\u0003&gt;\u0341\b&gt;\u0001&quot;+
		&quot;?\u0001?\u0001?\u0005?\u0346\b?\n?\f?\u0349\t?\u0001@\u0001@\u0001@\u0001&quot;+
		&quot;@\u0001A\u0001A\u0001A\u0003A\u0352\bA\u0001B\u0001B\u0001B\u0001B\u0005&quot;+
		&quot;B\u0358\bB\nB\fB\u035b\tB\u0003B\u035d\bB\u0001B\u0003B\u0360\bB\u0001&quot;+
		&quot;B\u0001B\u0001C\u0001C\u0001C\u0001C\u0001C\u0001D\u0001D\u0005D\u036b&quot;+
		&quot;\bD\nD\fD\u036e\tD\u0001D\u0001D\u0001E\u0005E\u0373\bE\nE\fE\u0376\t&quot;+
		&quot;E\u0001E\u0001E\u0003E\u037a\bE\u0001F\u0001F\u0001F\u0003F\u037f\bF\u0001&quot;+
		&quot;F\u0001F\u0001F\u0001F\u0001F\u0001F\u0001F\u0003F\u0388\bF\u0001F\u0001&quot;+
		&quot;F\u0003F\u038c\bF\u0001F\u0001F\u0003F\u0390\bF\u0001F\u0001F\u0003F\u0394&quot;+
		&quot;\bF\u0001F\u0001F\u0003F\u0398\bF\u0003F\u039a\bF\u0001G\u0001G\u0001&quot;+
		&quot;G\u0001G\u0005G\u03a0\bG\nG\fG\u03a3\tG\u0001G\u0003G\u03a6\bG\u0001H&quot;+
		&quot;\u0001H\u0001I\u0001I\u0001I\u0001J\u0001J\u0003J\u03af\bJ\u0001J\u0005&quot;+
		&quot;J\u03b2\bJ\nJ\fJ\u03b5\tJ\u0001J\u0001J\u0001K\u0003K\u03ba\bK\u0001K&quot;+
		&quot;\u0001K\u0001K\u0001K\u0001K\u0001K\u0001K\u0003K\u03c3\bK\u0001K\u0001&quot;+
		&quot;K\u0001K\u0001K\u0003K\u03c9\bK\u0001L\u0001L\u0005L\u03cd\bL\nL\fL\u03d0&quot;+
		&quot;\tL\u0001L\u0001L\u0001M\u0001M\u0001M\u0001M\u0001M\u0001M\u0003M\u03da&quot;+
		&quot;\bM\u0001N\u0005N\u03dd\bN\nN\fN\u03e0\tN\u0001N\u0001N\u0001N\u0001O&quot;+
		&quot;\u0005O\u03e6\bO\nO\fO\u03e9\tO\u0001O\u0001O\u0001O\u0001O\u0003O\u03ef&quot;+
		&quot;\bO\u0001O\u0003O\u03f2\bO\u0001P\u0001P\u0001P\u0001P\u0001P\u0003P\u03f9&quot;+
		&quot;\bP\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0003P\u0401\bP\u0001P\u0001&quot;+
		&quot;P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001&quot;+
		&quot;P\u0001P\u0001P\u0001P\u0001P\u0001P\u0004P\u0414\bP\u000bP\fP\u0415\u0001&quot;+
		&quot;P\u0003P\u0419\bP\u0001P\u0003P\u041c\bP\u0001P\u0001P\u0001P\u0001P\u0005&quot;+
		&quot;P\u0422\bP\nP\fP\u0425\tP\u0001P\u0003P\u0428\bP\u0001P\u0001P\u0001P&quot;+
		&quot;\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0003P\u0435&quot;+
		&quot;\bP\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0001P\u0003P\u043e\bP\u0001&quot;+
		&quot;P\u0001P\u0001P\u0003P\u0443\bP\u0001P\u0001P\u0001P\u0001P\u0001P\u0001&quot;+
		&quot;P\u0001P\u0001P\u0001P\u0003P\u044e\bP\u0001Q\u0001Q\u0001Q\u0001Q\u0001&quot;+
		&quot;Q\u0001Q\u0001Q\u0001Q\u0001R\u0004R\u0459\bR\u000bR\fR\u045a\u0001R\u0005&quot;+
		&quot;R\u045e\bR\nR\fR\u0461\tR\u0001R\u0005R\u0464\bR\nR\fR\u0467\tR\u0003&quot;+
		&quot;R\u0469\bR\u0001S\u0001S\u0001S\u0003S\u046e\bS\u0001T\u0001T\u0001T\u0001&quot;+
		&quot;T\u0001T\u0001U\u0001U\u0001U\u0001U\u0001V\u0001V\u0001V\u0001V\u0001&quot;+
		&quot;V\u0001V\u0001W\u0001W\u0001W\u0001X\u0001X\u0001X\u0001X\u0001X\u0001&quot;+
		&quot;X\u0001Y\u0005Y\u0489\bY\nY\fY\u048c\tY\u0001Y\u0001Y\u0001Y\u0001Z\u0001&quot;+
		&quot;Z\u0001Z\u0005Z\u0494\bZ\nZ\fZ\u0497\tZ\u0001[\u0001[\u0001[\u0001\\\u0001&quot;+
		&quot;\\\u0001\\\u0003\\\u049f\b\\\u0001\\\u0001\\\u0001]\u0001]\u0001]\u0005&quot;+
		&quot;]\u04a6\b]\n]\f]\u04a9\t]\u0001^\u0001^\u0003^\u04ad\b^\u0001_\u0005_&quot;+
		&quot;\u04b0\b_\n_\f_\u04b3\t_\u0001_\u0001_\u0001_\u0001_\u0001_\u0001`\u0005&quot;+
		&quot;`\u04bb\b`\n`\f`\u04be\t`\u0001`\u0001`\u0003`\u04c2\b`\u0001a\u0001a&quot;+
		&quot;\u0001a\u0001b\u0004b\u04c8\bb\u000bb\fb\u04c9\u0001b\u0004b\u04cd\bb&quot;+
		&quot;\u000bb\fb\u04ce\u0001c\u0001c\u0001c\u0003c\u04d4\bc\u0001c\u0001c\u0003&quot;+
		&quot;c\u04d8\bc\u0003c\u04da\bc\u0001d\u0001d\u0001d\u0005d\u04df\bd\nd\fd&quot;+
		&quot;\u04e2\td\u0001e\u0001e\u0001e\u0003e\u04e7\be\u0001f\u0001f\u0001f\u0001&quot;+
		&quot;f\u0001f\u0001f\u0003f\u04ef\bf\u0001f\u0001f\u0003f\u04f3\bf\u0001f\u0001&quot;+
		&quot;f\u0003f\u04f7\bf\u0001f\u0003f\u04fa\bf\u0001g\u0001g\u0003g\u04fe\b&quot;+
		&quot;g\u0001h\u0005h\u0501\bh\nh\fh\u0504\th\u0001h\u0001h\u0001h\u0001h\u0001&quot;+
		&quot;h\u0001i\u0001i\u0001i\u0001i\u0001j\u0001j\u0001j\u0005j\u0512\bj\nj&quot;+
		&quot;\fj\u0515\tj\u0001k\u0001k\u0001l\u0001l\u0001l\u0001l\u0001l\u0003l\u051e&quot;+
		&quot;\bl\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0001l\u0003l\u052b\bl\u0001l\u0001l\u0003l\u052f\bl\u0001l\u0001l\u0001&quot;+
		&quot;l\u0003l\u0534\bl\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0003l\u053e\bl\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0003l\u054e\bl\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0003l\u0577\bl\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0003l\u0582&quot;+
		&quot;\bl\u0001l\u0001l\u0001l\u0001l\u0003l\u0588\bl\u0001l\u0001l\u0003l\u058c&quot;+
		&quot;\bl\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0003l\u0594\bl\u0001l\u0001&quot;+
		&quot;l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0003l\u05a2\bl\u0001l\u0001l\u0003l\u05a6\bl\u0001l\u0001l\u0001l\u0001&quot;+
		&quot;l\u0003l\u05ac\bl\u0005l\u05ae\bl\nl\fl\u05b1\tl\u0001m\u0001m\u0001m&quot;+
		&quot;\u0005m\u05b6\bm\nm\fm\u05b9\tm\u0001n\u0001n\u0001n\u0001n\u0001o\u0001&quot;+
		&quot;o\u0001o\u0003o\u05c2\bo\u0001o\u0001o\u0001o\u0001o\u0001o\u0003o\u05c9&quot;+
		&quot;\bo\u0001p\u0001p\u0001p\u0005p\u05ce\bp\np\fp\u05d1\tp\u0001q\u0001q&quot;+
		&quot;\u0003q\u05d5\bq\u0001r\u0001r\u0001r\u0001r\u0001r\u0001r\u0001r\u0001&quot;+
		&quot;r\u0001r\u0001r\u0001r\u0005r\u05e2\br\nr\fr\u05e5\tr\u0001r\u0001r\u0001&quot;+
		&quot;r\u0001r\u0001r\u0005r\u05ec\br\nr\fr\u05ef\tr\u0001r\u0001r\u0001r\u0003&quot;+
		&quot;r\u05f4\br\u0001s\u0001s\u0001s\u0003s\u05f9\bs\u0001s\u0001s\u0001s\u0003&quot;+
		&quot;s\u05fe\bs\u0001t\u0001t\u0001t\u0001t\u0001t\u0001t\u0001t\u0001t\u0001&quot;+
		&quot;t\u0001t\u0003t\u060a\bt\u0003t\u060c\bt\u0001u\u0001u\u0001u\u0003u\u0611&quot;+
		&quot;\bu\u0001u\u0005u\u0614\bu\nu\fu\u0617\tu\u0001u\u0003u\u061a\bu\u0001&quot;+
		&quot;v\u0001v\u0001v\u0001v\u0003v\u0620\bv\u0001w\u0001w\u0001w\u0003w\u0625&quot;+
		&quot;\bw\u0001w\u0001w\u0001x\u0001x\u0001x\u0005x\u062c\bx\nx\fx\u062f\tx&quot;+
		&quot;\u0001x\u0001x\u0001x\u0001x\u0005x\u0635\bx\nx\fx\u0638\tx\u0001x\u0005&quot;+
		&quot;x\u063b\bx\nx\fx\u063e\tx\u0003x\u0640\bx\u0001y\u0001y\u0001y\u0001y&quot;+
		&quot;\u0001y\u0001z\u0001z\u0003z\u0649\bz\u0001{\u0001{\u0001{\u0003{\u064e&quot;+
		&quot;\b{\u0001|\u0001|\u0001|\u0003|\u0653\b|\u0001}\u0001}\u0001}\u0001}\u0001&quot;+
		&quot;~\u0001~\u0001~\u0005~\u065c\b~\n~\f~\u065f\t~\u0001\u007f\u0001\u007f&quot;+
		&quot;\u0001\u007f\u0005\u007f\u0664\b\u007f\n\u007f\f\u007f\u0667\t\u007f\u0001&quot;+
		&quot;\u0080\u0001\u0080\u0001\u0080\u0005\u0080\u066c\b\u0080\n\u0080\f\u0080&quot;+
		&quot;\u066f\t\u0080\u0001\u0081\u0001\u0081\u0003\u0081\u0673\b\u0081\u0001&quot;+
		&quot;\u0082\u0001\u0082\u0001\u0082\u0001\u0082\u0001\u0083\u0001\u0083\u0001&quot;+
		&quot;\u0084\u0001\u0084\u0001\u0084\u0001\u0084\u0005\u0084\u067f\b\u0084\n&quot;+
		&quot;\u0084\f\u0084\u0682\t\u0084\u0001\u0084\u0001\u0084\u0001\u0085\u0001&quot;+
		&quot;\u0085\u0003\u0085\u0688\b\u0085\u0001\u0085\u0001\u0085\u0001\u0085\u0001&quot;+
		&quot;\u0085\u0001\u0085\u0003\u0085\u068f\b\u0085\u0001\u0085\u0003\u0085\u0692&quot;+
		&quot;\b\u0085\u0003\u0085\u0694\b\u0085\u0001\u0086\u0001\u0086\u0003\u0086&quot;+
		&quot;\u0698\b\u0086\u0001\u0086\u0001\u0086\u0001\u0087\u0001\u0087\u0003\u0087&quot;+
		&quot;\u069e\b\u0087\u0001\u0088\u0001\u0088\u0001\u0088\u0001\u0088\u0001\u0089&quot;+
		&quot;\u0001\u0089\u0001\u0089\u0001\u0089\u0003\u0089\u06a8\b\u0089\u0001\u0089&quot;+
		&quot;\u0001\u0089\u0003\u0089\u06ac\b\u0089\u0001\u008a\u0005\u008a\u06af\b&quot;+
		&quot;\u008a\n\u008a\f\u008a\u06b2\t\u008a\u0001\u008a\u0001\u008a\u0001\u008a&quot;+
		&quot;\u0001\u008b\u0001\u008b\u0001\u008b\u0001\u008b\u0005\u008b\u06bb\b\u008b&quot;+
		&quot;\n\u008b\f\u008b\u06be\t\u008b\u0001\u008c\u0001\u008c\u0001\u008c\u0000&quot;+
		&quot;\u0001\u00d8\u008d\u0000\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014&quot;+
		&quot;\u0016\u0018\u001a\u001c\u001e \&quot;$&amp;(*,.02468:&lt;&gt;@BDFHJLNPRTVXZ\\^`bdfh&quot;+
		&quot;jlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092&quot;+
		&quot;\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa&quot;+
		&quot;\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2&quot;+
		&quot;\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8\u00da&quot;+
		&quot;\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2&quot;+
		&quot;\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a&quot;+
		&quot;\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u0000\r\u0001\u0000\u00d8\u00df&quot;+
		&quot;\u0001\u0000\u00c0\u00c3\u0001\u0000NO\u0002\u0000}~\u0081\u0082\u0001&quot;+
		&quot;\u0000\u0083\u0084\u0002\u0000&lt;&lt;\u007f\u0080\u0001\u0000}~\u0001\u0000&quot;+
		&quot;ux\u0001\u0000st\u0002\u0000PPbl\u0001\u0000\u0081\u0082\u0001\u00001&quot;+
		&quot;9\u0004\u0000::\u00c8\u00c8\u00cf\u00cf\u00d1\u00d3\u0764\u0000\u011b&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0002\u012b\u0001\u0000\u0000\u0000\u0004\u013c&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0006\u014a\u0001\u0000\u0000\u0000\b\u0151\u0001&quot;+
		&quot;\u0000\u0000\u0000\n\u0162\u0001\u0000\u0000\u0000\f\u0166\u0001\u0000&quot;+
		&quot;\u0000\u0000\u000e\u0168\u0001\u0000\u0000\u0000\u0010\u0178\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0012\u0183\u0001\u0000\u0000\u0000\u0014\u0196\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0016\u0198\u0001\u0000\u0000\u0000\u0018\u019c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u001a\u01a1\u0001\u0000\u0000\u0000\u001c\u01ac\u0001\u0000&quot;+
		&quot;\u0000\u0000\u001e\u01b1\u0001\u0000\u0000\u0000 \u01b7\u0001\u0000\u0000&quot;+
		&quot;\u0000\&quot;\u01ba\u0001\u0000\u0000\u0000$\u01bd\u0001\u0000\u0000\u0000&quot;+
		&quot;&amp;\u01c8\u0001\u0000\u0000\u0000(\u01cd\u0001\u0000\u0000\u0000*\u01d1&quot;+
		&quot;\u0001\u0000\u0000\u0000,\u01d9\u0001\u0000\u0000\u0000.\u01e1\u0001\u0000&quot;+
		&quot;\u0000\u00000\u01e8\u0001\u0000\u0000\u00002\u01f4\u0001\u0000\u0000\u0000&quot;+
		&quot;4\u01fc\u0001\u0000\u0000\u00006\u0204\u0001\u0000\u0000\u00008\u020b&quot;+
		&quot;\u0001\u0000\u0000\u0000:\u0218\u0001\u0000\u0000\u0000&lt;\u021b\u0001\u0000&quot;+
		&quot;\u0000\u0000&gt;\u0224\u0001\u0000\u0000\u0000@\u0239\u0001\u0000\u0000\u0000&quot;+
		&quot;B\u0243\u0001\u0000\u0000\u0000D\u0246\u0001\u0000\u0000\u0000F\u0258&quot;+
		&quot;\u0001\u0000\u0000\u0000H\u025a\u0001\u0000\u0000\u0000J\u025e\u0001\u0000&quot;+
		&quot;\u0000\u0000L\u0267\u0001\u0000\u0000\u0000N\u0273\u0001\u0000\u0000\u0000&quot;+
		&quot;P\u027c\u0001\u0000\u0000\u0000R\u027f\u0001\u0000\u0000\u0000T\u028f&quot;+
		&quot;\u0001\u0000\u0000\u0000V\u0297\u0001\u0000\u0000\u0000X\u02a8\u0001\u0000&quot;+
		&quot;\u0000\u0000Z\u02b2\u0001\u0000\u0000\u0000\\\u02b4\u0001\u0000\u0000&quot;+
		&quot;\u0000^\u02c4\u0001\u0000\u0000\u0000`\u02cf\u0001\u0000\u0000\u0000b&quot;+
		&quot;\u02df\u0001\u0000\u0000\u0000d\u02e1\u0001\u0000\u0000\u0000f\u02ec\u0001&quot;+
		&quot;\u0000\u0000\u0000h\u02ff\u0001\u0000\u0000\u0000j\u0304\u0001\u0000\u0000&quot;+
		&quot;\u0000l\u030d\u0001\u0000\u0000\u0000n\u0315\u0001\u0000\u0000\u0000p&quot;+
		&quot;\u031c\u0001\u0000\u0000\u0000r\u0328\u0001\u0000\u0000\u0000t\u032a\u0001&quot;+
		&quot;\u0000\u0000\u0000v\u032c\u0001\u0000\u0000\u0000x\u032e\u0001\u0000\u0000&quot;+
		&quot;\u0000z\u0335\u0001\u0000\u0000\u0000|\u0338\u0001\u0000\u0000\u0000~&quot;+
		&quot;\u0342\u0001\u0000\u0000\u0000\u0080\u034a\u0001\u0000\u0000\u0000\u0082&quot;+
		&quot;\u0351\u0001\u0000\u0000\u0000\u0084\u0353\u0001\u0000\u0000\u0000\u0086&quot;+
		&quot;\u0363\u0001\u0000\u0000\u0000\u0088\u0368\u0001\u0000\u0000\u0000\u008a&quot;+
		&quot;\u0379\u0001\u0000\u0000\u0000\u008c\u0399\u0001\u0000\u0000\u0000\u008e&quot;+
		&quot;\u039b\u0001\u0000\u0000\u0000\u0090\u03a7\u0001\u0000\u0000\u0000\u0092&quot;+
		&quot;\u03a9\u0001\u0000\u0000\u0000\u0094\u03ac\u0001\u0000\u0000\u0000\u0096&quot;+
		&quot;\u03c8\u0001\u0000\u0000\u0000\u0098\u03ca\u0001\u0000\u0000\u0000\u009a&quot;+
		&quot;\u03d9\u0001\u0000\u0000\u0000\u009c\u03de\u0001\u0000\u0000\u0000\u009e&quot;+
		&quot;\u03f1\u0001\u0000\u0000\u0000\u00a0\u044d\u0001\u0000\u0000\u0000\u00a2&quot;+
		&quot;\u044f\u0001\u0000\u0000\u0000\u00a4\u0468\u0001\u0000\u0000\u0000\u00a6&quot;+
		&quot;\u046d\u0001\u0000\u0000\u0000\u00a8\u046f\u0001\u0000\u0000\u0000\u00aa&quot;+
		&quot;\u0474\u0001\u0000\u0000\u0000\u00ac\u0478\u0001\u0000\u0000\u0000\u00ae&quot;+
		&quot;\u047e\u0001\u0000\u0000\u0000\u00b0\u0481\u0001\u0000\u0000\u0000\u00b2&quot;+
		&quot;\u048a\u0001\u0000\u0000\u0000\u00b4\u0490\u0001\u0000\u0000\u0000\u00b6&quot;+
		&quot;\u0498\u0001\u0000\u0000\u0000\u00b8\u049b\u0001\u0000\u0000\u0000\u00ba&quot;+
		&quot;\u04a2\u0001\u0000\u0000\u0000\u00bc\u04ac\u0001\u0000\u0000\u0000\u00be&quot;+
		&quot;\u04b1\u0001\u0000\u0000\u0000\u00c0\u04bc\u0001\u0000\u0000\u0000\u00c2&quot;+
		&quot;\u04c3\u0001\u0000\u0000\u0000\u00c4\u04c7\u0001\u0000\u0000\u0000\u00c6&quot;+
		&quot;\u04d9\u0001\u0000\u0000\u0000\u00c8\u04db\u0001\u0000\u0000\u0000\u00ca&quot;+
		&quot;\u04e6\u0001\u0000\u0000\u0000\u00cc\u04f9\u0001\u0000\u0000\u0000\u00ce&quot;+
		&quot;\u04fd\u0001\u0000\u0000\u0000\u00d0\u0502\u0001\u0000\u0000\u0000\u00d2&quot;+
		&quot;\u050a\u0001\u0000\u0000\u0000\u00d4\u050e\u0001\u0000\u0000\u0000\u00d6&quot;+
		&quot;\u0516\u0001\u0000\u0000\u0000\u00d8\u053d\u0001\u0000\u0000\u0000\u00da&quot;+
		&quot;\u05b2\u0001\u0000\u0000\u0000\u00dc\u05ba\u0001\u0000\u0000\u0000\u00de&quot;+
		&quot;\u05c8\u0001\u0000\u0000\u0000\u00e0\u05ca\u0001\u0000\u0000\u0000\u00e2&quot;+
		&quot;\u05d4\u0001\u0000\u0000\u0000\u00e4\u05f3\u0001\u0000\u0000\u0000\u00e6&quot;+
		&quot;\u05f8\u0001\u0000\u0000\u0000\u00e8\u060b\u0001\u0000\u0000\u0000\u00ea&quot;+
		&quot;\u0619\u0001\u0000\u0000\u0000\u00ec\u061b\u0001\u0000\u0000\u0000\u00ee&quot;+
		&quot;\u0621\u0001\u0000\u0000\u0000\u00f0\u0628\u0001\u0000\u0000\u0000\u00f2&quot;+
		&quot;\u0641\u0001\u0000\u0000\u0000\u00f4\u0646\u0001\u0000\u0000\u0000\u00f6&quot;+
		&quot;\u064d\u0001\u0000\u0000\u0000\u00f8\u0652\u0001\u0000\u0000\u0000\u00fa&quot;+
		&quot;\u0654\u0001\u0000\u0000\u0000\u00fc\u0658\u0001\u0000\u0000\u0000\u00fe&quot;+
		&quot;\u0660\u0001\u0000\u0000\u0000\u0100\u0668\u0001\u0000\u0000\u0000\u0102&quot;+
		&quot;\u0672\u0001\u0000\u0000\u0000\u0104\u0674\u0001\u0000\u0000\u0000\u0106&quot;+
		&quot;\u0678\u0001\u0000\u0000\u0000\u0108\u067a\u0001\u0000\u0000\u0000\u010a&quot;+
		&quot;\u0693\u0001\u0000\u0000\u0000\u010c\u0695\u0001\u0000\u0000\u0000\u010e&quot;+
		&quot;\u069d\u0001\u0000\u0000\u0000\u0110\u069f\u0001\u0000\u0000\u0000\u0112&quot;+
		&quot;\u06ab\u0001\u0000\u0000\u0000\u0114\u06b0\u0001\u0000\u0000\u0000\u0116&quot;+
		&quot;\u06b6\u0001\u0000\u0000\u0000\u0118\u06bf\u0001\u0000\u0000\u0000\u011a&quot;+
		&quot;\u011c\u0003\u0002\u0001\u0000\u011b\u011a\u0001\u0000\u0000\u0000\u011b&quot;+
		&quot;\u011c\u0001\u0000\u0000\u0000\u011c\u0120\u0001\u0000\u0000\u0000\u011d&quot;+
		&quot;\u011f\u0003\u0004\u0002\u0000\u011e\u011d\u0001\u0000\u0000\u0000\u011f&quot;+
		&quot;\u0122\u0001\u0000\u0000\u0000\u0120\u011e\u0001\u0000\u0000\u0000\u0120&quot;+
		&quot;\u0121\u0001\u0000\u0000\u0000\u0121\u0126\u0001\u0000\u0000\u0000\u0122&quot;+
		&quot;\u0120\u0001\u0000\u0000\u0000\u0123\u0125\u0003\u0006\u0003\u0000\u0124&quot;+
		&quot;\u0123\u0001\u0000\u0000\u0000\u0125\u0128\u0001\u0000\u0000\u0000\u0126&quot;+
		&quot;\u0124\u0001\u0000\u0000\u0000\u0126\u0127\u0001\u0000\u0000\u0000\u0127&quot;+
		&quot;\u0129\u0001\u0000\u0000\u0000\u0128\u0126\u0001\u0000\u0000\u0000\u0129&quot;+
		&quot;\u012a\u0005\u0000\u0000\u0001\u012a\u0001\u0001\u0000\u0000\u0000\u012b&quot;+
		&quot;\u012c\u0003z=\u0000\u012c\u012d\u0005,\u0000\u0000\u012d\u012e\u0003&quot;+
		&quot;n7\u0000\u012e\u012f\u0005-\u0000\u0000\u012f\u0003\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0130\u0132\u0005\u001e\u0000\u0000\u0131\u0133\u0005@\u0000\u0000&quot;+
		&quot;\u0132\u0131\u0001\u0000\u0000\u0000\u0132\u0133\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0133\u0134\u0001\u0000\u0000\u0000\u0134\u0137\u0003n7\u0000\u0135\u0136&quot;+
		&quot;\u0005;\u0000\u0000\u0136\u0138\u0005&lt;\u0000\u0000\u0137\u0135\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0137\u0138\u0001\u0000\u0000\u0000\u0138\u0139\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0139\u013a\u0005-\u0000\u0000\u013a\u013d\u0001\u0000\u0000&quot;+
		&quot;\u0000\u013b\u013d\u0005-\u0000\u0000\u013c\u0130\u0001\u0000\u0000\u0000&quot;+
		&quot;\u013c\u013b\u0001\u0000\u0000\u0000\u013d\u0005\u0001\u0000\u0000\u0000&quot;+
		&quot;\u013e\u0140\u0003\n\u0005\u0000\u013f\u013e\u0001\u0000\u0000\u0000\u0140&quot;+
		&quot;\u0143\u0001\u0000\u0000\u0000\u0141\u013f\u0001\u0000\u0000\u0000\u0141&quot;+
		&quot;\u0142\u0001\u0000\u0000\u0000\u0142\u0144\u0001\u0000\u0000\u0000\u0143&quot;+
		&quot;\u0141\u0001\u0000\u0000\u0000\u0144\u014b\u0003\b\u0004\u0000\u0145\u0147&quot;+
		&quot;\u0005-\u0000\u0000\u0146\u0145\u0001\u0000\u0000\u0000\u0147\u0148\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0148\u0146\u0001\u0000\u0000\u0000\u0148\u0149\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0149\u014b\u0001\u0000\u0000\u0000\u014a\u0141\u0001&quot;+
		&quot;\u0000\u0000\u0000\u014a\u0146\u0001\u0000\u0000\u0000\u014b\u0007\u0001&quot;+
		&quot;\u0000\u0000\u0000\u014c\u0152\u0003\u000e\u0007\u0000\u014d\u0152\u0003&quot;+
		&quot;.\u0017\u0000\u014e\u0152\u00038\u001c\u0000\u014f\u0152\u0003\u0086C&quot;+
		&quot;\u0000\u0150\u0152\u0003\u0010\b\u0000\u0151\u014c\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0151\u014d\u0001\u0000\u0000\u0000\u0151\u014e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0151\u014f\u0001\u0000\u0000\u0000\u0151\u0150\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0152\t\u0001\u0000\u0000\u0000\u0153\u0163\u0003|&gt;\u0000\u0154\u0163&quot;+
		&quot;\u0005&gt;\u0000\u0000\u0155\u0163\u0005?\u0000\u0000\u0156\u0163\u0005=&quot;+
		&quot;\u0000\u0000\u0157\u0163\u0005@\u0000\u0000\u0158\u0163\u0005(\u0000\u0000&quot;+
		&quot;\u0159\u0163\u0005^\u0000\u0000\u015a\u0163\u0005\'\u0000\u0000\u015b&quot;+
		&quot;\u0163\u0005)\u0000\u0000\u015c\u0163\u0005B\u0000\u0000\u015d\u0163\u0005&quot;+
		&quot;C\u0000\u0000\u015e\u0163\u0005A\u0000\u0000\u015f\u0163\u0005D\u0000&quot;+
		&quot;\u0000\u0160\u0163\u0005\u00d1\u0000\u0000\u0161\u0163\u0005\u00d2\u0000&quot;+
		&quot;\u0000\u0162\u0153\u0001\u0000\u0000\u0000\u0162\u0154\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u0155\u0001\u0000\u0000\u0000\u0162\u0156\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u0157\u0001\u0000\u0000\u0000\u0162\u0158\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u0159\u0001\u0000\u0000\u0000\u0162\u015a\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u015b\u0001\u0000\u0000\u0000\u0162\u015c\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u015d\u0001\u0000\u0000\u0000\u0162\u015e\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u015f\u0001\u0000\u0000\u0000\u0162\u0160\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0162\u0161\u0001\u0000\u0000\u0000\u0163\u000b\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0164\u0167\u0005\'\u0000\u0000\u0165\u0167\u0003|&gt;\u0000\u0166&quot;+
		&quot;\u0164\u0001\u0000\u0000\u0000\u0166\u0165\u0001\u0000\u0000\u0000\u0167&quot;+
		&quot;\r\u0001\u0000\u0000\u0000\u0168\u0169\u0005E\u0000\u0000\u0169\u016b&quot;+
		&quot;\u0003\u0118\u008c\u0000\u016a\u016c\u0003$\u0012\u0000\u016b\u016a\u0001&quot;+
		&quot;\u0000\u0000\u0000\u016b\u016c\u0001\u0000\u0000\u0000\u016c\u016e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u016d\u016f\u0003 \u0010\u0000\u016e\u016d\u0001\u0000&quot;+
		&quot;\u0000\u0000\u016e\u016f\u0001\u0000\u0000\u0000\u016f\u0171\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0170\u0172\u0003\&quot;\u0011\u0000\u0171\u0170\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0171\u0172\u0001\u0000\u0000\u0000\u0172\u0174\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0173\u0175\u0003\u0116\u008b\u0000\u0174\u0173\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0174\u0175\u0001\u0000\u0000\u0000\u0175\u0176\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0176\u0177\u0003&lt;\u001e\u0000\u0177\u000f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0178\u0179\u0005\u00c8\u0000\u0000\u0179\u017b\u0003\u0118\u008c\u0000&quot;+
		&quot;\u017a\u017c\u0003$\u0012\u0000\u017b\u017a\u0001\u0000\u0000\u0000\u017b&quot;+
		&quot;\u017c\u0001\u0000\u0000\u0000\u017c\u017d\u0001\u0000\u0000\u0000\u017d&quot;+
		&quot;\u017f\u0003\u0012\t\u0000\u017e\u0180\u0003\&quot;\u0011\u0000\u017f\u017e&quot;+
		&quot;\u0001\u0000\u0000\u0000\u017f\u0180\u0001\u0000\u0000\u0000\u0180\u0181&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0181\u0182\u0003\u001a\r\u0000\u0182\u0011\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0183\u0185\u0005L\u0000\u0000\u0184\u0186\u0003\u0014&quot;+
		&quot;\n\u0000\u0185\u0184\u0001\u0000\u0000\u0000\u0185\u0186\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0186\u0187\u0001\u0000\u0000\u0000\u0187\u0188\u0005M\u0000\u0000&quot;+
		&quot;\u0188\u0013\u0001\u0000\u0000\u0000\u0189\u018e\u0003\u0016\u000b\u0000&quot;+
		&quot;\u018a\u018b\u0005J\u0000\u0000\u018b\u018d\u0003\u0016\u000b\u0000\u018c&quot;+
		&quot;\u018a\u0001\u0000\u0000\u0000\u018d\u0190\u0001\u0000\u0000\u0000\u018e&quot;+
		&quot;\u018c\u0001\u0000\u0000\u0000\u018e\u018f\u0001\u0000\u0000\u0000\u018f&quot;+
		&quot;\u0193\u0001\u0000\u0000\u0000\u0190\u018e\u0001\u0000\u0000\u0000\u0191&quot;+
		&quot;\u0192\u0005J\u0000\u0000\u0192\u0194\u0003\u0018\f\u0000\u0193\u0191&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0193\u0194\u0001\u0000\u0000\u0000\u0194\u0197&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0195\u0197\u0003\u0018\f\u0000\u0196\u0189\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0196\u0195\u0001\u0000\u0000\u0000\u0197\u0015\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0198\u0199\u0003z=\u0000\u0199\u019a\u0003\u0100\u0080&quot;+
		&quot;\u0000\u019a\u019b\u0003\u0118\u008c\u0000\u019b\u0017\u0001\u0000\u0000&quot;+
		&quot;\u0000\u019c\u019d\u0003z=\u0000\u019d\u019e\u0003\u0100\u0080\u0000\u019e&quot;+
		&quot;\u019f\u0005\u00ab\u0000\u0000\u019f\u01a0\u0003\u0118\u008c\u0000\u01a0&quot;+
		&quot;\u0019\u0001\u0000\u0000\u0000\u01a1\u01a5\u0005H\u0000\u0000\u01a2\u01a4&quot;+
		&quot;\u0003\u001c\u000e\u0000\u01a3\u01a2\u0001\u0000\u0000\u0000\u01a4\u01a7&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01a5\u01a3\u0001\u0000\u0000\u0000\u01a5\u01a6&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01a6\u01a8\u0001\u0000\u0000\u0000\u01a7\u01a5&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01a8\u01a9\u0005I\u0000\u0000\u01a9\u001b\u0001&quot;+
		&quot;\u0000\u0000\u0000\u01aa\u01ad\u0003\u001e\u000f\u0000\u01ab\u01ad\u0003&quot;+
		&quot;@ \u0000\u01ac\u01aa\u0001\u0000\u0000\u0000\u01ac\u01ab\u0001\u0000\u0000&quot;+
		&quot;\u0000\u01ad\u001d\u0001\u0000\u0000\u0000\u01ae\u01b0\u0003\n\u0005\u0000&quot;+
		&quot;\u01af\u01ae\u0001\u0000\u0000\u0000\u01b0\u01b3\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01b1\u01af\u0001\u0000\u0000\u0000\u01b1\u01b2\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01b2\u01b4\u0001\u0000\u0000\u0000\u01b3\u01b1\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01b4\u01b5\u0003\u0118\u008c\u0000\u01b5\u01b6\u0003\u0094J\u0000\u01b6&quot;+
		&quot;\u001f\u0001\u0000\u0000\u0000\u01b7\u01b8\u0005\u0012\u0000\u0000\u01b8&quot;+
		&quot;\u01b9\u0003\u0100\u0080\u0000\u01b9!\u0001\u0000\u0000\u0000\u01ba\u01bb&quot;+
		&quot;\u0005K\u0000\u0000\u01bb\u01bc\u0003\u00fe\u007f\u0000\u01bc#\u0001\u0000&quot;+
		&quot;\u0000\u0000\u01bd\u01be\u0005u\u0000\u0000\u01be\u01c3\u0003&amp;\u0013\u0000&quot;+
		&quot;\u01bf\u01c0\u0005J\u0000\u0000\u01c0\u01c2\u0003&amp;\u0013\u0000\u01c1\u01bf&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01c2\u01c5\u0001\u0000\u0000\u0000\u01c3\u01c1&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01c3\u01c4\u0001\u0000\u0000\u0000\u01c4\u01c6&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01c5\u01c3\u0001\u0000\u0000\u0000\u01c6\u01c7&quot;+
		&quot;\u0005v\u0000\u0000\u01c7%\u0001\u0000\u0000\u0000\u01c8\u01c9\u0003z&quot;+
		&quot;=\u0000\u01c9\u01cb\u0003\u0118\u008c\u0000\u01ca\u01cc\u0003(\u0014\u0000&quot;+
		&quot;\u01cb\u01ca\u0001\u0000\u0000\u0000\u01cb\u01cc\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01cc\'\u0001\u0000\u0000\u0000\u01cd\u01ce\u0005\u0012\u0000\u0000\u01ce&quot;+
		&quot;\u01cf\u0003z=\u0000\u01cf\u01d0\u0003*\u0015\u0000\u01d0)\u0001\u0000&quot;+
		&quot;\u0000\u0000\u01d1\u01d6\u0003,\u0016\u0000\u01d2\u01d3\u0005r\u0000\u0000&quot;+
		&quot;\u01d3\u01d5\u0003,\u0016\u0000\u01d4\u01d2\u0001\u0000\u0000\u0000\u01d5&quot;+
		&quot;\u01d8\u0001\u0000\u0000\u0000\u01d6\u01d4\u0001\u0000\u0000\u0000\u01d6&quot;+
		&quot;\u01d7\u0001\u0000\u0000\u0000\u01d7+\u0001\u0000\u0000\u0000\u01d8\u01d6&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01d9\u01da\u0003z=\u0000\u01da\u01de\u0003\u0102&quot;+
		&quot;\u0081\u0000\u01db\u01dd\u0003\u0104\u0082\u0000\u01dc\u01db\u0001\u0000&quot;+
		&quot;\u0000\u0000\u01dd\u01e0\u0001\u0000\u0000\u0000\u01de\u01dc\u0001\u0000&quot;+
		&quot;\u0000\u0000\u01de\u01df\u0001\u0000\u0000\u0000\u01df-\u0001\u0000\u0000&quot;+
		&quot;\u0000\u01e0\u01de\u0001\u0000\u0000\u0000\u01e1\u01e2\u0005\u0099\u0000&quot;+
		&quot;\u0000\u01e2\u01e4\u0003\u0118\u008c\u0000\u01e3\u01e5\u0003\&quot;\u0011\u0000&quot;+
		&quot;\u01e4\u01e3\u0001\u0000\u0000\u0000\u01e4\u01e5\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01e5\u01e6\u0001\u0000\u0000\u0000\u01e6\u01e7\u00030\u0018\u0000\u01e7&quot;+
		&quot;/\u0001\u0000\u0000\u0000\u01e8\u01ea\u0005H\u0000\u0000\u01e9\u01eb\u0003&quot;+
		&quot;2\u0019\u0000\u01ea\u01e9\u0001\u0000\u0000\u0000\u01ea\u01eb\u0001\u0000&quot;+
		&quot;\u0000\u0000\u01eb\u01ed\u0001\u0000\u0000\u0000\u01ec\u01ee\u0005J\u0000&quot;+
		&quot;\u0000\u01ed\u01ec\u0001\u0000\u0000\u0000\u01ed\u01ee\u0001\u0000\u0000&quot;+
		&quot;\u0000\u01ee\u01f0\u0001\u0000\u0000\u0000\u01ef\u01f1\u00036\u001b\u0000&quot;+
		&quot;\u01f0\u01ef\u0001\u0000\u0000\u0000\u01f0\u01f1\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01f1\u01f2\u0001\u0000\u0000\u0000\u01f2\u01f3\u0005I\u0000\u0000\u01f3&quot;+
		&quot;1\u0001\u0000\u0000\u0000\u01f4\u01f9\u00034\u001a\u0000\u01f5\u01f6\u0005&quot;+
		&quot;J\u0000\u0000\u01f6\u01f8\u00034\u001a\u0000\u01f7\u01f5\u0001\u0000\u0000&quot;+
		&quot;\u0000\u01f8\u01fb\u0001\u0000\u0000\u0000\u01f9\u01f7\u0001\u0000\u0000&quot;+
		&quot;\u0000\u01f9\u01fa\u0001\u0000\u0000\u0000\u01fa3\u0001\u0000\u0000\u0000&quot;+
		&quot;\u01fb\u01f9\u0001\u0000\u0000\u0000\u01fc\u01fd\u0003z=\u0000\u01fd\u01ff&quot;+
		&quot;\u0003\u0118\u008c\u0000\u01fe\u0200\u0003\u010c\u0086\u0000\u01ff\u01fe&quot;+
		&quot;\u0001\u0000\u0000\u0000\u01ff\u0200\u0001\u0000\u0000\u0000\u0200\u0202&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0201\u0203\u0003&lt;\u001e\u0000\u0202\u0201\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0202\u0203\u0001\u0000\u0000\u0000\u02035\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0204\u0208\u0005-\u0000\u0000\u0205\u0207\u0003@ \u0000&quot;+
		&quot;\u0206\u0205\u0001\u0000\u0000\u0000\u0207\u020a\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0208\u0206\u0001\u0000\u0000\u0000\u0208\u0209\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02097\u0001\u0000\u0000\u0000\u020a\u0208\u0001\u0000\u0000\u0000\u020b&quot;+
		&quot;\u020c\u0005G\u0000\u0000\u020c\u020e\u0003\u0118\u008c\u0000\u020d\u020f&quot;+
		&quot;\u0003$\u0012\u0000\u020e\u020d\u0001\u0000\u0000\u0000\u020e\u020f\u0001&quot;+
		&quot;\u0000\u0000\u0000\u020f\u0211\u0001\u0000\u0000\u0000\u0210\u0212\u0003&quot;+
		&quot;:\u001d\u0000\u0211\u0210\u0001\u0000\u0000\u0000\u0211\u0212\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0212\u0214\u0001\u0000\u0000\u0000\u0213\u0215\u0003\u0116&quot;+
		&quot;\u008b\u0000\u0214\u0213\u0001\u0000\u0000\u0000\u0214\u0215\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0215\u0216\u0001\u0000\u0000\u0000\u0216\u0217\u0003&gt;\u001f&quot;+
		&quot;\u0000\u02179\u0001\u0000\u0000\u0000\u0218\u0219\u0005\u0012\u0000\u0000&quot;+
		&quot;\u0219\u021a\u0003\u00fe\u007f\u0000\u021a;\u0001\u0000\u0000\u0000\u021b&quot;+
		&quot;\u021f\u0005H\u0000\u0000\u021c\u021e\u0003@ \u0000\u021d\u021c\u0001&quot;+
		&quot;\u0000\u0000\u0000\u021e\u0221\u0001\u0000\u0000\u0000\u021f\u021d\u0001&quot;+
		&quot;\u0000\u0000\u0000\u021f\u0220\u0001\u0000\u0000\u0000\u0220\u0222\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0221\u021f\u0001\u0000\u0000\u0000\u0222\u0223\u0005&quot;+
		&quot;I\u0000\u0000\u0223=\u0001\u0000\u0000\u0000\u0224\u0228\u0005H\u0000&quot;+
		&quot;\u0000\u0225\u0227\u0003N\'\u0000\u0226\u0225\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0227\u022a\u0001\u0000\u0000\u0000\u0228\u0226\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0228\u0229\u0001\u0000\u0000\u0000\u0229\u022b\u0001\u0000\u0000\u0000&quot;+
		&quot;\u022a\u0228\u0001\u0000\u0000\u0000\u022b\u022c\u0005I\u0000\u0000\u022c&quot;+
		&quot;?\u0001\u0000\u0000\u0000\u022d\u023a\u0005-\u0000\u0000\u022e\u0230\u0005&quot;+
		&quot;@\u0000\u0000\u022f\u022e\u0001\u0000\u0000\u0000\u022f\u0230\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0230\u0231\u0001\u0000\u0000\u0000\u0231\u023a\u0003\u0098&quot;+
		&quot;L\u0000\u0232\u0234\u0003\n\u0005\u0000\u0233\u0232\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0234\u0237\u0001\u0000\u0000\u0000\u0235\u0233\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0235\u0236\u0001\u0000\u0000\u0000\u0236\u0238\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0237\u0235\u0001\u0000\u0000\u0000\u0238\u023a\u0003B!\u0000\u0239&quot;+
		&quot;\u022d\u0001\u0000\u0000\u0000\u0239\u022f\u0001\u0000\u0000\u0000\u0239&quot;+
		&quot;\u0235\u0001\u0000\u0000\u0000\u023aA\u0001\u0000\u0000\u0000\u023b\u0244&quot;+
		&quot;\u0003\u0010\b\u0000\u023c\u0244\u0003D\&quot;\u0000\u023d\u0244\u0003L&amp;\u0000&quot;+
		&quot;\u023e\u0244\u0003J%\u0000\u023f\u0244\u00038\u001c\u0000\u0240\u0244&quot;+
		&quot;\u0003\u0086C\u0000\u0241\u0244\u0003\u000e\u0007\u0000\u0242\u0244\u0003&quot;+
		&quot;.\u0017\u0000\u0243\u023b\u0001\u0000\u0000\u0000\u0243\u023c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0243\u023d\u0001\u0000\u0000\u0000\u0243\u023e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0243\u023f\u0001\u0000\u0000\u0000\u0243\u0240\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0243\u0241\u0001\u0000\u0000\u0000\u0243\u0242\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0244C\u0001\u0000\u0000\u0000\u0245\u0247\u0003$\u0012\u0000&quot;+
		&quot;\u0246\u0245\u0001\u0000\u0000\u0000\u0246\u0247\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0247\u0248\u0001\u0000\u0000\u0000\u0248\u0249\u0003\u0100\u0080\u0000&quot;+
		&quot;\u0249\u024a\u0003\u0118\u008c\u0000\u024a\u024e\u0003f3\u0000\u024b\u024d&quot;+
		&quot;\u0003\u0104\u0082\u0000\u024c\u024b\u0001\u0000\u0000\u0000\u024d\u0250&quot;+
		&quot;\u0001\u0000\u0000\u0000\u024e\u024c\u0001\u0000\u0000\u0000\u024e\u024f&quot;+
		&quot;\u0001\u0000\u0000\u0000\u024f\u0252\u0001\u0000\u0000\u0000\u0250\u024e&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0251\u0253\u0003H$\u0000\u0252\u0251\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0252\u0253\u0001\u0000\u0000\u0000\u0253\u0254\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0254\u0255\u0003F#\u0000\u0255E\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0256\u0259\u0003\u0098L\u0000\u0257\u0259\u0005-\u0000\u0000\u0258\u0256&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0258\u0257\u0001\u0000\u0000\u0000\u0259G\u0001&quot;+
		&quot;\u0000\u0000\u0000\u025a\u025b\u0005Q\u0000\u0000\u025b\u025c\u0003d2&quot;+
		&quot;\u0000\u025cI\u0001\u0000\u0000\u0000\u025d\u025f\u0003$\u0012\u0000\u025e&quot;+
		&quot;\u025d\u0001\u0000\u0000\u0000\u025e\u025f\u0001\u0000\u0000\u0000\u025f&quot;+
		&quot;\u0260\u0001\u0000\u0000\u0000\u0260\u0261\u0003\u0118\u008c\u0000\u0261&quot;+
		&quot;\u0263\u0003f3\u0000\u0262\u0264\u0003H$\u0000\u0263\u0262\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0263\u0264\u0001\u0000\u0000\u0000\u0264\u0265\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0265\u0266\u0003\u0094J\u0000\u0266K\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0267\u0268\u0003\u0100\u0080\u0000\u0268\u0269\u0003T*\u0000\u0269\u026a&quot;+
		&quot;\u0005-\u0000\u0000\u026aM\u0001\u0000\u0000\u0000\u026b\u026d\u0003\n&quot;+
		&quot;\u0005\u0000\u026c\u026b\u0001\u0000\u0000\u0000\u026d\u0270\u0001\u0000&quot;+
		&quot;\u0000\u0000\u026e\u026c\u0001\u0000\u0000\u0000\u026e\u026f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u026f\u0271\u0001\u0000\u0000\u0000\u0270\u026e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0271\u0274\u0003P(\u0000\u0272\u0274\u0005-\u0000\u0000&quot;+
		&quot;\u0273\u026e\u0001\u0000\u0000\u0000\u0273\u0272\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0274O\u0001\u0000\u0000\u0000\u0275\u027d\u0003L&amp;\u0000\u0276\u027d&quot;+
		&quot;\u0003\u0010\b\u0000\u0277\u027d\u0003R)\u0000\u0278\u027d\u00038\u001c&quot;+
		&quot;\u0000\u0279\u027d\u0003\u0086C\u0000\u027a\u027d\u0003\u000e\u0007\u0000&quot;+
		&quot;\u027b\u027d\u0003.\u0017\u0000\u027c\u0275\u0001\u0000\u0000\u0000\u027c&quot;+
		&quot;\u0276\u0001\u0000\u0000\u0000\u027c\u0277\u0001\u0000\u0000\u0000\u027c&quot;+
		&quot;\u0278\u0001\u0000\u0000\u0000\u027c\u0279\u0001\u0000\u0000\u0000\u027c&quot;+
		&quot;\u027a\u0001\u0000\u0000\u0000\u027c\u027b\u0001\u0000\u0000\u0000\u027d&quot;+
		&quot;Q\u0001\u0000\u0000\u0000\u027e\u0280\u0003$\u0012\u0000\u027f\u027e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u027f\u0280\u0001\u0000\u0000\u0000\u0280\u0281\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0281\u0282\u0003\u0100\u0080\u0000\u0282\u0283\u0003&quot;+
		&quot;\u0118\u008c\u0000\u0283\u0287\u0003f3\u0000\u0284\u0286\u0003\u0104\u0082&quot;+
		&quot;\u0000\u0285\u0284\u0001\u0000\u0000\u0000\u0286\u0289\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0287\u0285\u0001\u0000\u0000\u0000\u0287\u0288\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0288\u028b\u0001\u0000\u0000\u0000\u0289\u0287\u0001\u0000\u0000&quot;+
		&quot;\u0000\u028a\u028c\u0003H$\u0000\u028b\u028a\u0001\u0000\u0000\u0000\u028b&quot;+
		&quot;\u028c\u0001\u0000\u0000\u0000\u028c\u028d\u0001\u0000\u0000\u0000\u028d&quot;+
		&quot;\u028e\u0003F#\u0000\u028eS\u0001\u0000\u0000\u0000\u028f\u0294\u0003&quot;+
		&quot;V+\u0000\u0290\u0291\u0005J\u0000\u0000\u0291\u0293\u0003V+\u0000\u0292&quot;+
		&quot;\u0290\u0001\u0000\u0000\u0000\u0293\u0296\u0001\u0000\u0000\u0000\u0294&quot;+
		&quot;\u0292\u0001\u0000\u0000\u0000\u0294\u0295\u0001\u0000\u0000\u0000\u0295&quot;+
		&quot;U\u0001\u0000\u0000\u0000\u0296\u0294\u0001\u0000\u0000\u0000\u0297\u029b&quot;+
		&quot;\u0003\u0118\u008c\u0000\u0298\u029a\u0003\u0104\u0082\u0000\u0299\u0298&quot;+
		&quot;\u0001\u0000\u0000\u0000\u029a\u029d\u0001\u0000\u0000\u0000\u029b\u0299&quot;+
		&quot;\u0001\u0000\u0000\u0000\u029b\u029c\u0001\u0000\u0000\u0000\u029c\u02a0&quot;+
		&quot;\u0001\u0000\u0000\u0000\u029d\u029b\u0001\u0000\u0000\u0000\u029e\u029f&quot;+
		&quot;\u0005P\u0000\u0000\u029f\u02a1\u0003Z-\u0000\u02a0\u029e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02a0\u02a1\u0001\u0000\u0000\u0000\u02a1W\u0001\u0000\u0000&quot;+
		&quot;\u0000\u02a2\u02a9\u0005N\u0000\u0000\u02a3\u02a6\u0003n7\u0000\u02a4&quot;+
		&quot;\u02a5\u0005;\u0000\u0000\u02a5\u02a7\u0005N\u0000\u0000\u02a6\u02a4\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02a6\u02a7\u0001\u0000\u0000\u0000\u02a7\u02a9\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02a8\u02a2\u0001\u0000\u0000\u0000\u02a8\u02a3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02a9\u02ad\u0001\u0000\u0000\u0000\u02aa\u02ac\u0003&quot;+
		&quot;\u0104\u0082\u0000\u02ab\u02aa\u0001\u0000\u0000\u0000\u02ac\u02af\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02ad\u02ab\u0001\u0000\u0000\u0000\u02ad\u02ae\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02aeY\u0001\u0000\u0000\u0000\u02af\u02ad\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02b0\u02b3\u0003\\.\u0000\u02b1\u02b3\u0003\u00d6k\u0000&quot;+
		&quot;\u02b2\u02b0\u0001\u0000\u0000\u0000\u02b2\u02b1\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02b3[\u0001\u0000\u0000\u0000\u02b4\u02bd\u0005H\u0000\u0000\u02b5\u02ba&quot;+
		&quot;\u0003Z-\u0000\u02b6\u02b7\u0005J\u0000\u0000\u02b7\u02b9\u0003Z-\u0000&quot;+
		&quot;\u02b8\u02b6\u0001\u0000\u0000\u0000\u02b9\u02bc\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02ba\u02b8\u0001\u0000\u0000\u0000\u02ba\u02bb\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02bb\u02be\u0001\u0000\u0000\u0000\u02bc\u02ba\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02bd\u02b5\u0001\u0000\u0000\u0000\u02bd\u02be\u0001\u0000\u0000\u0000&quot;+
		&quot;\u02be\u02c0\u0001\u0000\u0000\u0000\u02bf\u02c1\u0005J\u0000\u0000\u02c0&quot;+
		&quot;\u02bf\u0001\u0000\u0000\u0000\u02c0\u02c1\u0001\u0000\u0000\u0000\u02c1&quot;+
		&quot;\u02c2\u0001\u0000\u0000\u0000\u02c2\u02c3\u0005I\u0000\u0000\u02c3]\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02c4\u02c5\u0003z=\u0000\u02c5\u02c7\u0003\u0118\u008c&quot;+
		&quot;\u0000\u02c6\u02c8\u0003\u0108\u0084\u0000\u02c7\u02c6\u0001\u0000\u0000&quot;+
		&quot;\u0000\u02c7\u02c8\u0001\u0000\u0000\u0000\u02c8\u02cc\u0001\u0000\u0000&quot;+
		&quot;\u0000\u02c9\u02cb\u0003`0\u0000\u02ca\u02c9\u0001\u0000\u0000\u0000\u02cb&quot;+
		&quot;\u02ce\u0001\u0000\u0000\u0000\u02cc\u02ca\u0001\u0000\u0000\u0000\u02cc&quot;+
		&quot;\u02cd\u0001\u0000\u0000\u0000\u02cd_\u0001\u0000\u0000\u0000\u02ce\u02cc&quot;+
		&quot;\u0001\u0000\u0000\u0000\u02cf\u02d0\u0005;\u0000\u0000\u02d0\u02d1\u0003&quot;+
		&quot;z=\u0000\u02d1\u02d3\u0003\u0118\u008c\u0000\u02d2\u02d4\u0003\u0108\u0084&quot;+
		&quot;\u0000\u02d3\u02d2\u0001\u0000\u0000\u0000\u02d3\u02d4\u0001\u0000\u0000&quot;+
		&quot;\u0000\u02d4a\u0001\u0000\u0000\u0000\u02d5\u02e0\u0003\u0100\u0080\u0000&quot;+
		&quot;\u02d6\u02d7\u0003z=\u0000\u02d7\u02dd\u0005m\u0000\u0000\u02d8\u02db&quot;+
		&quot;\u0005\u0012\u0000\u0000\u02d9\u02db\u0005O\u0000\u0000\u02da\u02d8\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02da\u02d9\u0001\u0000\u0000\u0000\u02db\u02dc\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02dc\u02de\u0003\u0100\u0080\u0000\u02dd\u02da\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02dd\u02de\u0001\u0000\u0000\u0000\u02de\u02e0\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02df\u02d5\u0001\u0000\u0000\u0000\u02df\u02d6\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02e0c\u0001\u0000\u0000\u0000\u02e1\u02e2\u0003z=&quot;+
		&quot;\u0000\u02e2\u02e9\u0003n7\u0000\u02e3\u02e4\u0005J\u0000\u0000\u02e4&quot;+
		&quot;\u02e5\u0003z=\u0000\u02e5\u02e6\u0003n7\u0000\u02e6\u02e8\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02e7\u02e3\u0001\u0000\u0000\u0000\u02e8\u02eb\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02e9\u02e7\u0001\u0000\u0000\u0000\u02e9\u02ea\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02eae\u0001\u0000\u0000\u0000\u02eb\u02e9\u0001\u0000\u0000&quot;+
		&quot;\u0000\u02ec\u02ee\u0005L\u0000\u0000\u02ed\u02ef\u0003h4\u0000\u02ee&quot;+
		&quot;\u02ed\u0001\u0000\u0000\u0000\u02ee\u02ef\u0001\u0000\u0000\u0000\u02ef&quot;+
		&quot;\u02f0\u0001\u0000\u0000\u0000\u02f0\u02f1\u0005M\u0000\u0000\u02f1g\u0001&quot;+
		&quot;\u0000\u0000\u0000\u02f2\u02f7\u0003j5\u0000\u02f3\u02f4\u0005J\u0000&quot;+
		&quot;\u0000\u02f4\u02f6\u0003j5\u0000\u02f5\u02f3\u0001\u0000\u0000\u0000\u02f6&quot;+
		&quot;\u02f9\u0001\u0000\u0000\u0000\u02f7\u02f5\u0001\u0000\u0000\u0000\u02f7&quot;+
		&quot;\u02f8\u0001\u0000\u0000\u0000\u02f8\u02fc\u0001\u0000\u0000\u0000\u02f9&quot;+
		&quot;\u02f7\u0001\u0000\u0000\u0000\u02fa\u02fb\u0005J\u0000\u0000\u02fb\u02fd&quot;+
		&quot;\u0003l6\u0000\u02fc\u02fa\u0001\u0000\u0000\u0000\u02fc\u02fd\u0001\u0000&quot;+
		&quot;\u0000\u0000\u02fd\u0300\u0001\u0000\u0000\u0000\u02fe\u0300\u0003l6\u0000&quot;+
		&quot;\u02ff\u02f2\u0001\u0000\u0000\u0000\u02ff\u02fe\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0300i\u0001\u0000\u0000\u0000\u0301\u0303\u0003\f\u0006\u0000\u0302&quot;+
		&quot;\u0301\u0001\u0000\u0000\u0000\u0303\u0306\u0001\u0000\u0000\u0000\u0304&quot;+
		&quot;\u0302\u0001\u0000\u0000\u0000\u0304\u0305\u0001\u0000\u0000\u0000\u0305&quot;+
		&quot;\u0307\u0001\u0000\u0000\u0000\u0306\u0304\u0001\u0000\u0000\u0000\u0307&quot;+
		&quot;\u0308\u0003\u0100\u0080\u0000\u0308\u0309\u0003X,\u0000\u0309k\u0001&quot;+
		&quot;\u0000\u0000\u0000\u030a\u030c\u0003\f\u0006\u0000\u030b\u030a\u0001\u0000&quot;+
		&quot;\u0000\u0000\u030c\u030f\u0001\u0000\u0000\u0000\u030d\u030b\u0001\u0000&quot;+
		&quot;\u0000\u0000\u030d\u030e\u0001\u0000\u0000\u0000\u030e\u0310\u0001\u0000&quot;+
		&quot;\u0000\u0000\u030f\u030d\u0001\u0000\u0000\u0000\u0310\u0311\u0003\u0100&quot;+
		&quot;\u0080\u0000\u0311\u0312\u0003z=\u0000\u0312\u0313\u0005\u00ab\u0000\u0000&quot;+
		&quot;\u0313\u0314\u0003X,\u0000\u0314m\u0001\u0000\u0000\u0000\u0315\u0319&quot;+
		&quot;\u0003\u0118\u008c\u0000\u0316\u0318\u0003p8\u0000\u0317\u0316\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0318\u031b\u0001\u0000\u0000\u0000\u0319\u0317\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0319\u031a\u0001\u0000\u0000\u0000\u031ao\u0001\u0000\u0000&quot;+
		&quot;\u0000\u031b\u0319\u0001\u0000\u0000\u0000\u031c\u031d\u0005;\u0000\u0000&quot;+
		&quot;\u031d\u031e\u0003z=\u0000\u031e\u031f\u0003\u0118\u008c\u0000\u031fq&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0320\u0329\u0003t:\u0000\u0321\u0329\u0003v&quot;+
		&quot;;\u0000\u0322\u0329\u0003x&lt;\u0000\u0323\u0329\u0005\u008a\u0000\u0000&quot;+
		&quot;\u0324\u0329\u0005\u008b\u0000\u0000\u0325\u0329\u0005\u0085\u0000\u0000&quot;+
		&quot;\u0326\u0329\u0005\u0086\u0000\u0000\u0327\u0329\u0005\u0087\u0000\u0000&quot;+
		&quot;\u0328\u0320\u0001\u0000\u0000\u0000\u0328\u0321\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0328\u0322\u0001\u0000\u0000\u0000\u0328\u0323\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0328\u0324\u0001\u0000\u0000\u0000\u0328\u0325\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0328\u0326\u0001\u0000\u0000\u0000\u0328\u0327\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0329s\u0001\u0000\u0000\u0000\u032a\u032b\u0007\u0000\u0000\u0000\u032b&quot;+
		&quot;u\u0001\u0000\u0000\u0000\u032c\u032d\u0007\u0001\u0000\u0000\u032dw\u0001&quot;+
		&quot;\u0000\u0000\u0000\u032e\u032f\u0005\u00cc\u0000\u0000\u032f\u0330\u0005&quot;+
		&quot;\u00cd\u0000\u0000\u0330\u0331\u0005\u00ce\u0000\u0000\u0331y\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0332\u0334\u0003|&gt;\u0000\u0333\u0332\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0334\u0337\u0001\u0000\u0000\u0000\u0335\u0333\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0335\u0336\u0001\u0000\u0000\u0000\u0336{\u0001\u0000\u0000\u0000\u0337&quot;+
		&quot;\u0335\u0001\u0000\u0000\u0000\u0338\u0339\u0005\u00aa\u0000\u0000\u0339&quot;+
		&quot;\u0340\u0003n7\u0000\u033a\u033d\u0005L\u0000\u0000\u033b\u033e\u0003&quot;+
		&quot;~?\u0000\u033c\u033e\u0003\u0082A\u0000\u033d\u033b\u0001\u0000\u0000&quot;+
		&quot;\u0000\u033d\u033c\u0001\u0000\u0000\u0000\u033d\u033e\u0001\u0000\u0000&quot;+
		&quot;\u0000\u033e\u033f\u0001\u0000\u0000\u0000\u033f\u0341\u0005M\u0000\u0000&quot;+
		&quot;\u0340\u033a\u0001\u0000\u0000\u0000\u0340\u0341\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0341}\u0001\u0000\u0000\u0000\u0342\u0347\u0003\u0080@\u0000\u0343\u0344&quot;+
		&quot;\u0005J\u0000\u0000\u0344\u0346\u0003\u0080@\u0000\u0345\u0343\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0346\u0349\u0001\u0000\u0000\u0000\u0347\u0345\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0347\u0348\u0001\u0000\u0000\u0000\u0348\u007f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0349\u0347\u0001\u0000\u0000\u0000\u034a\u034b\u0003\u0118&quot;+
		&quot;\u008c\u0000\u034b\u034c\u0005P\u0000\u0000\u034c\u034d\u0003\u0082A\u0000&quot;+
		&quot;\u034d\u0081\u0001\u0000\u0000\u0000\u034e\u0352\u0003\u00d6k\u0000\u034f&quot;+
		&quot;\u0352\u0003|&gt;\u0000\u0350\u0352\u0003\u0084B\u0000\u0351\u034e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0351\u034f\u0001\u0000\u0000\u0000\u0351\u0350\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0352\u0083\u0001\u0000\u0000\u0000\u0353\u035c\u0005&quot;+
		&quot;H\u0000\u0000\u0354\u0359\u0003\u0082A\u0000\u0355\u0356\u0005J\u0000&quot;+
		&quot;\u0000\u0356\u0358\u0003\u0082A\u0000\u0357\u0355\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0358\u035b\u0001\u0000\u0000\u0000\u0359\u0357\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0359\u035a\u0001\u0000\u0000\u0000\u035a\u035d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u035b\u0359\u0001\u0000\u0000\u0000\u035c\u0354\u0001\u0000\u0000\u0000&quot;+
		&quot;\u035c\u035d\u0001\u0000\u0000\u0000\u035d\u035f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u035e\u0360\u0005J\u0000\u0000\u035f\u035e\u0001\u0000\u0000\u0000\u035f&quot;+
		&quot;\u0360\u0001\u0000\u0000\u0000\u0360\u0361\u0001\u0000\u0000\u0000\u0361&quot;+
		&quot;\u0362\u0005I\u0000\u0000\u0362\u0085\u0001\u0000\u0000\u0000\u0363\u0364&quot;+
		&quot;\u0005\u00aa\u0000\u0000\u0364\u0365\u0005G\u0000\u0000\u0365\u0366\u0003&quot;+
		&quot;\u0118\u008c\u0000\u0366\u0367\u0003\u0088D\u0000\u0367\u0087\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0368\u036c\u0005H\u0000\u0000\u0369\u036b\u0003\u008aE\u0000&quot;+
		&quot;\u036a\u0369\u0001\u0000\u0000\u0000\u036b\u036e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u036c\u036a\u0001\u0000\u0000\u0000\u036c\u036d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u036d\u036f\u0001\u0000\u0000\u0000\u036e\u036c\u0001\u0000\u0000\u0000&quot;+
		&quot;\u036f\u0370\u0005I\u0000\u0000\u0370\u0089\u0001\u0000\u0000\u0000\u0371&quot;+
		&quot;\u0373\u0003\n\u0005\u0000\u0372\u0371\u0001\u0000\u0000\u0000\u0373\u0376&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0374\u0372\u0001\u0000\u0000\u0000\u0374\u0375&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0375\u0377\u0001\u0000\u0000\u0000\u0376\u0374&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0377\u037a\u0003\u008cF\u0000\u0378\u037a\u0005&quot;+
		&quot;-\u0000\u0000\u0379\u0374\u0001\u0000\u0000\u0000\u0379\u0378\u0001\u0000&quot;+
		&quot;\u0000\u0000\u037a\u008b\u0001\u0000\u0000\u0000\u037b\u037e\u0003\u0100&quot;+
		&quot;\u0080\u0000\u037c\u037f\u0003\u008eG\u0000\u037d\u037f\u0003\u0090H\u0000&quot;+
		&quot;\u037e\u037c\u0001\u0000\u0000\u0000\u037e\u037d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u037f\u0380\u0001\u0000\u0000\u0000\u0380\u0381\u0005-\u0000\u0000\u0381&quot;+
		&quot;\u039a\u0001\u0000\u0000\u0000\u0382\u0383\u0003\u0100\u0080\u0000\u0383&quot;+
		&quot;\u0384\u0005-\u0000\u0000\u0384\u039a\u0001\u0000\u0000\u0000\u0385\u0387&quot;+
		&quot;\u0003\u000e\u0007\u0000\u0386\u0388\u0005-\u0000\u0000\u0387\u0386\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0387\u0388\u0001\u0000\u0000\u0000\u0388\u039a\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0389\u038b\u0003\u0010\b\u0000\u038a\u038c\u0005-&quot;+
		&quot;\u0000\u0000\u038b\u038a\u0001\u0000\u0000\u0000\u038b\u038c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u038c\u039a\u0001\u0000\u0000\u0000\u038d\u038f\u00038\u001c&quot;+
		&quot;\u0000\u038e\u0390\u0005-\u0000\u0000\u038f\u038e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u038f\u0390\u0001\u0000\u0000\u0000\u0390\u039a\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0391\u0393\u0003.\u0017\u0000\u0392\u0394\u0005-\u0000\u0000\u0393\u0392&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0393\u0394\u0001\u0000\u0000\u0000\u0394\u039a&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0395\u0397\u0003\u0086C\u0000\u0396\u0398\u0005&quot;+
		&quot;-\u0000\u0000\u0397\u0396\u0001\u0000\u0000\u0000\u0397\u0398\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0398\u039a\u0001\u0000\u0000\u0000\u0399\u037b\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0399\u0382\u0001\u0000\u0000\u0000\u0399\u0385\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0399\u0389\u0001\u0000\u0000\u0000\u0399\u038d\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0399\u0391\u0001\u0000\u0000\u0000\u0399\u0395\u0001\u0000&quot;+
		&quot;\u0000\u0000\u039a\u008d\u0001\u0000\u0000\u0000\u039b\u039c\u0003\u0118&quot;+
		&quot;\u008c\u0000\u039c\u039d\u0005L\u0000\u0000\u039d\u03a1\u0005M\u0000\u0000&quot;+
		&quot;\u039e\u03a0\u0003\u0104\u0082\u0000\u039f\u039e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u03a0\u03a3\u0001\u0000\u0000\u0000\u03a1\u039f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u03a1\u03a2\u0001\u0000\u0000\u0000\u03a2\u03a5\u0001\u0000\u0000\u0000&quot;+
		&quot;\u03a3\u03a1\u0001\u0000\u0000\u0000\u03a4\u03a6\u0003\u0092I\u0000\u03a5&quot;+
		&quot;\u03a4\u0001\u0000\u0000\u0000\u03a5\u03a6\u0001\u0000\u0000\u0000\u03a6&quot;+
		&quot;\u008f\u0001\u0000\u0000\u0000\u03a7\u03a8\u0003T*\u0000\u03a8\u0091\u0001&quot;+
		&quot;\u0000\u0000\u0000\u03a9\u03aa\u0005^\u0000\u0000\u03aa\u03ab\u0003\u0082&quot;+
		&quot;A\u0000\u03ab\u0093\u0001\u0000\u0000\u0000\u03ac\u03ae\u0005H\u0000\u0000&quot;+
		&quot;\u03ad\u03af\u0003\u0096K\u0000\u03ae\u03ad\u0001\u0000\u0000\u0000\u03ae&quot;+
		&quot;\u03af\u0001\u0000\u0000\u0000\u03af\u03b3\u0001\u0000\u0000\u0000\u03b0&quot;+
		&quot;\u03b2\u0003\u009aM\u0000\u03b1\u03b0\u0001\u0000\u0000\u0000\u03b2\u03b5&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03b3\u03b1\u0001\u0000\u0000\u0000\u03b3\u03b4&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03b4\u03b6\u0001\u0000\u0000\u0000\u03b5\u03b3&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03b6\u03b7\u0005I\u0000\u0000\u03b7\u0095\u0001&quot;+
		&quot;\u0000\u0000\u0000\u03b8\u03ba\u0003\u0108\u0084\u0000\u03b9\u03b8\u0001&quot;+
		&quot;\u0000\u0000\u0000\u03b9\u03ba\u0001\u0000\u0000\u0000\u03ba\u03bb\u0001&quot;+
		&quot;\u0000\u0000\u0000\u03bb\u03bc\u0007\u0002\u0000\u0000\u03bc\u03bd\u0003&quot;+
		&quot;\u010c\u0086\u0000\u03bd\u03be\u0005-\u0000\u0000\u03be\u03c9\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03bf\u03c0\u0003\u00d8l\u0000\u03c0\u03c2\u0005;\u0000\u0000&quot;+
		&quot;\u03c1\u03c3\u0003\u0108\u0084\u0000\u03c2\u03c1\u0001\u0000\u0000\u0000&quot;+
		&quot;\u03c2\u03c3\u0001\u0000\u0000\u0000\u03c3\u03c4\u0001\u0000\u0000\u0000&quot;+
		&quot;\u03c4\u03c5\u0005O\u0000\u0000\u03c5\u03c6\u0003\u010c\u0086\u0000\u03c6&quot;+
		&quot;\u03c7\u0005-\u0000\u0000\u03c7\u03c9\u0001\u0000\u0000\u0000\u03c8\u03b9&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03c8\u03bf\u0001\u0000\u0000\u0000\u03c9\u0097&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03ca\u03ce\u0005H\u0000\u0000\u03cb\u03cd\u0003&quot;+
		&quot;\u009aM\u0000\u03cc\u03cb\u0001\u0000\u0000\u0000\u03cd\u03d0\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03ce\u03cc\u0001\u0000\u0000\u0000\u03ce\u03cf\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03cf\u03d1\u0001\u0000\u0000\u0000\u03d0\u03ce\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03d1\u03d2\u0005I\u0000\u0000\u03d2\u0099\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03d3\u03d4\u0004M\u0000\u0000\u03d4\u03d5\u0003\u009cN\u0000\u03d5&quot;+
		&quot;\u03d6\u0005-\u0000\u0000\u03d6\u03da\u0001\u0000\u0000\u0000\u03d7\u03da&quot;+
		&quot;\u0003\u00a0P\u0000\u03d8\u03da\u0003\u009eO\u0000\u03d9\u03d3\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03d9\u03d7\u0001\u0000\u0000\u0000\u03d9\u03d8\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03da\u009b\u0001\u0000\u0000\u0000\u03db\u03dd\u0003\n\u0005&quot;+
		&quot;\u0000\u03dc\u03db\u0001\u0000\u0000\u0000\u03dd\u03e0\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03de\u03dc\u0001\u0000\u0000\u0000\u03de\u03df\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03df\u03e1\u0001\u0000\u0000\u0000\u03e0\u03de\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03e1\u03e2\u0003\u0100\u0080\u0000\u03e2\u03e3\u0003T*\u0000\u03e3&quot;+
		&quot;\u009d\u0001\u0000\u0000\u0000\u03e4\u03e6\u0003\n\u0005\u0000\u03e5\u03e4&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03e6\u03e9\u0001\u0000\u0000\u0000\u03e7\u03e5&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03e7\u03e8\u0001\u0000\u0000\u0000\u03e8\u03ee&quot;+
		&quot;\u0001\u0000\u0000\u0000\u03e9\u03e7\u0001\u0000\u0000\u0000\u03ea\u03ef&quot;+
		&quot;\u0003\u000e\u0007\u0000\u03eb\u03ef\u0003.\u0017\u0000\u03ec\u03ef\u0003&quot;+
		&quot;8\u001c\u0000\u03ed\u03ef\u0003\u0010\b\u0000\u03ee\u03ea\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03ee\u03eb\u0001\u0000\u0000\u0000\u03ee\u03ec\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03ee\u03ed\u0001\u0000\u0000\u0000\u03ef\u03f2\u0001\u0000&quot;+
		&quot;\u0000\u0000\u03f0\u03f2\u0005-\u0000\u0000\u03f1\u03e7\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03f1\u03f0\u0001\u0000\u0000\u0000\u03f2\u009f\u0001\u0000\u0000&quot;+
		&quot;\u0000\u03f3\u044e\u0003\u0098L\u0000\u03f4\u03f5\u0005\u0097\u0000\u0000&quot;+
		&quot;\u03f5\u03f8\u0003\u00d6k\u0000\u03f6\u03f7\u0005R\u0000\u0000\u03f7\u03f9&quot;+
		&quot;\u0003\u00d6k\u0000\u03f8\u03f6\u0001\u0000\u0000\u0000\u03f8\u03f9\u0001&quot;+
		&quot;\u0000\u0000\u0000\u03f9\u03fa\u0001\u0000\u0000\u0000\u03fa\u03fb\u0005&quot;+
		&quot;-\u0000\u0000\u03fb\u044e\u0001\u0000\u0000\u0000\u03fc\u03fd\u0005S\u0000&quot;+
		&quot;\u0000\u03fd\u03fe\u0003\u00d2i\u0000\u03fe\u0400\u0003\u00a0P\u0000\u03ff&quot;+
		&quot;\u0401\u0003\u00aeW\u0000\u0400\u03ff\u0001\u0000\u0000\u0000\u0400\u0401&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0401\u044e\u0001\u0000\u0000\u0000\u0402\u0403&quot;+
		&quot;\u0005[\u0000\u0000\u0403\u0404\u0003\u00ccf\u0000\u0404\u0405\u0003\u00a0&quot;+
		&quot;P\u0000\u0405\u044e\u0001\u0000\u0000\u0000\u0406\u0407\u0005T\u0000\u0000&quot;+
		&quot;\u0407\u0408\u0003\u00d2i\u0000\u0408\u0409\u0003\u00a0P\u0000\u0409\u044e&quot;+
		&quot;\u0001\u0000\u0000\u0000\u040a\u040b\u0005U\u0000\u0000\u040b\u040c\u0003&quot;+
		&quot;\u00a0P\u0000\u040c\u040d\u0005T\u0000\u0000\u040d\u040e\u0003\u00d2i&quot;+
		&quot;\u0000\u040e\u040f\u0005-\u0000\u0000\u040f\u044e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0410\u0411\u0005_\u0000\u0000\u0411\u041b\u0003\u0098L\u0000\u0412\u0414&quot;+
		&quot;\u0003\u00b0X\u0000\u0413\u0412\u0001\u0000\u0000\u0000\u0414\u0415\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0415\u0413\u0001\u0000\u0000\u0000\u0415\u0416\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0416\u0418\u0001\u0000\u0000\u0000\u0417\u0419\u0003&quot;+
		&quot;\u00b6[\u0000\u0418\u0417\u0001\u0000\u0000\u0000\u0418\u0419\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0419\u041c\u0001\u0000\u0000\u0000\u041a\u041c\u0003\u00b6&quot;+
		&quot;[\u0000\u041b\u0413\u0001\u0000\u0000\u0000\u041b\u041a\u0001\u0000\u0000&quot;+
		&quot;\u0000\u041c\u044e\u0001\u0000\u0000\u0000\u041d\u041e\u0005_\u0000\u0000&quot;+
		&quot;\u041e\u041f\u0003\u00b8\\\u0000\u041f\u0423\u0003\u0098L\u0000\u0420&quot;+
		&quot;\u0422\u0003\u00b0X\u0000\u0421\u0420\u0001\u0000\u0000\u0000\u0422\u0425&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0423\u0421\u0001\u0000\u0000\u0000\u0423\u0424&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0424\u0427\u0001\u0000\u0000\u0000\u0425\u0423&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0426\u0428\u0003\u00b6[\u0000\u0427\u0426\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0427\u0428\u0001\u0000\u0000\u0000\u0428\u044e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0429\u042a\u0005\u00cf\u0000\u0000\u042a\u042b\u0003&quot;+
		&quot;\u00d6k\u0000\u042b\u042c\u0005-\u0000\u0000\u042c\u044e\u0001\u0000\u0000&quot;+
		&quot;\u0000\u042d\u044e\u0003\u00a2Q\u0000\u042e\u042f\u0005C\u0000\u0000\u042f&quot;+
		&quot;\u0430\u0003\u00d2i\u0000\u0430\u0431\u0003\u0098L\u0000\u0431\u044e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0432\u0434\u0005X\u0000\u0000\u0433\u0435\u0003\u00d6&quot;+
		&quot;k\u0000\u0434\u0433\u0001\u0000\u0000\u0000\u0434\u0435\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0435\u0436\u0001\u0000\u0000\u0000\u0436\u044e\u0005-\u0000\u0000&quot;+
		&quot;\u0437\u0438\u0005Z\u0000\u0000\u0438\u0439\u0003\u00d6k\u0000\u0439\u043a&quot;+
		&quot;\u0005-\u0000\u0000\u043a\u044e\u0001\u0000\u0000\u0000\u043b\u043d\u0005&quot;+
		&quot;V\u0000\u0000\u043c\u043e\u0003\u0118\u008c\u0000\u043d\u043c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u043d\u043e\u0001\u0000\u0000\u0000\u043e\u043f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u043f\u044e\u0005-\u0000\u0000\u0440\u0442\u0005W\u0000\u0000&quot;+
		&quot;\u0441\u0443\u0003\u0118\u008c\u0000\u0442\u0441\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0442\u0443\u0001\u0000\u0000\u0000\u0443\u0444\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0444\u044e\u0005-\u0000\u0000\u0445\u044e\u0005-\u0000\u0000\u0446\u0447&quot;+
		&quot;\u0003\u00d6k\u0000\u0447\u0448\u0005-\u0000\u0000\u0448\u044e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0449\u044a\u0003\u0118\u008c\u0000\u044a\u044b\u0005R\u0000&quot;+
		&quot;\u0000\u044b\u044c\u0003\u00a0P\u0000\u044c\u044e\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u03f3\u0001\u0000\u0000\u0000\u044d\u03f4\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u03fc\u0001\u0000\u0000\u0000\u044d\u0402\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0406\u0001\u0000\u0000\u0000\u044d\u040a\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0410\u0001\u0000\u0000\u0000\u044d\u041d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0429\u0001\u0000\u0000\u0000\u044d\u042d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u042e\u0001\u0000\u0000\u0000\u044d\u0432\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0437\u0001\u0000\u0000\u0000\u044d\u043b\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0440\u0001\u0000\u0000\u0000\u044d\u0445\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044d\u0446\u0001\u0000\u0000\u0000\u044d\u0449\u0001\u0000\u0000\u0000&quot;+
		&quot;\u044e\u00a1\u0001\u0000\u0000\u0000\u044f\u0450\u0005Y\u0000\u0000\u0450&quot;+
		&quot;\u0451\u0003\u00d2i\u0000\u0451\u0452\u0005H\u0000\u0000\u0452\u0453\u0006&quot;+
		&quot;Q\uffff\uffff\u0000\u0453\u0454\u0003\u00a4R\u0000\u0454\u0455\u0006Q&quot;+
		&quot;\uffff\uffff\u0000\u0455\u0456\u0005I\u0000\u0000\u0456\u00a3\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0457\u0459\u0003\u00a6S\u0000\u0458\u0457\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0459\u045a\u0001\u0000\u0000\u0000\u045a\u0458\u0001\u0000\u0000&quot;+
		&quot;\u0000\u045a\u045b\u0001\u0000\u0000\u0000\u045b\u0469\u0001\u0000\u0000&quot;+
		&quot;\u0000\u045c\u045e\u0003\u00c4b\u0000\u045d\u045c\u0001\u0000\u0000\u0000&quot;+
		&quot;\u045e\u0461\u0001\u0000\u0000\u0000\u045f\u045d\u0001\u0000\u0000\u0000&quot;+
		&quot;\u045f\u0460\u0001\u0000\u0000\u0000\u0460\u0465\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0461\u045f\u0001\u0000\u0000\u0000\u0462\u0464\u0003\u00c6c\u0000\u0463&quot;+
		&quot;\u0462\u0001\u0000\u0000\u0000\u0464\u0467\u0001\u0000\u0000\u0000\u0465&quot;+
		&quot;\u0463\u0001\u0000\u0000\u0000\u0465\u0466\u0001\u0000\u0000\u0000\u0466&quot;+
		&quot;\u0469\u0001\u0000\u0000\u0000\u0467\u0465\u0001\u0000\u0000\u0000\u0468&quot;+
		&quot;\u0458\u0001\u0000\u0000\u0000\u0468\u045f\u0001\u0000\u0000\u0000\u0469&quot;+
		&quot;\u00a5\u0001\u0000\u0000\u0000\u046a\u046e\u0003\u00a8T\u0000\u046b\u046e&quot;+
		&quot;\u0003\u00aaU\u0000\u046c\u046e\u0003\u00acV\u0000\u046d\u046a\u0001\u0000&quot;+
		&quot;\u0000\u0000\u046d\u046b\u0001\u0000\u0000\u0000\u046d\u046c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u046e\u00a7\u0001\u0000\u0000\u0000\u046f\u0470\u0003\u00c6&quot;+
		&quot;c\u0000\u0470\u0471\u0005\u00b5\u0000\u0000\u0471\u0472\u0003\u00d6k\u0000&quot;+
		&quot;\u0472\u0473\u0005-\u0000\u0000\u0473\u00a9\u0001\u0000\u0000\u0000\u0474&quot;+
		&quot;\u0475\u0003\u00c6c\u0000\u0475\u0476\u0005\u00b5\u0000\u0000\u0476\u0477&quot;+
		&quot;\u0003\u0098L\u0000\u0477\u00ab\u0001\u0000\u0000\u0000\u0478\u0479\u0003&quot;+
		&quot;\u00c6c\u0000\u0479\u047a\u0005\u00b5\u0000\u0000\u047a\u047b\u0005Z\u0000&quot;+
		&quot;\u0000\u047b\u047c\u0003\u00d6k\u0000\u047c\u047d\u0005-\u0000\u0000\u047d&quot;+
		&quot;\u00ad\u0001\u0000\u0000\u0000\u047e\u047f\u0005\\\u0000\u0000\u047f\u0480&quot;+
		&quot;\u0003\u00a0P\u0000\u0480\u00af\u0001\u0000\u0000\u0000\u0481\u0482\u0005&quot;+
		&quot;`\u0000\u0000\u0482\u0483\u0005L\u0000\u0000\u0483\u0484\u0003\u00b2Y&quot;+
		&quot;\u0000\u0484\u0485\u0005M\u0000\u0000\u0485\u0486\u0003\u0098L\u0000\u0486&quot;+
		&quot;\u00b1\u0001\u0000\u0000\u0000\u0487\u0489\u0003\f\u0006\u0000\u0488\u0487&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0489\u048c\u0001\u0000\u0000\u0000\u048a\u0488&quot;+
		&quot;\u0001\u0000\u0000\u0000\u048a\u048b\u0001\u0000\u0000\u0000\u048b\u048d&quot;+
		&quot;\u0001\u0000\u0000\u0000\u048c\u048a\u0001\u0000\u0000\u0000\u048d\u048e&quot;+
		&quot;\u0003\u00b4Z\u0000\u048e\u048f\u0003\u0118\u008c\u0000\u048f\u00b3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0490\u0495\u0003^/\u0000\u0491\u0492\u0005p\u0000&quot;+
		&quot;\u0000\u0492\u0494\u0003^/\u0000\u0493\u0491\u0001\u0000\u0000\u0000\u0494&quot;+
		&quot;\u0497\u0001\u0000\u0000\u0000\u0495\u0493\u0001\u0000\u0000\u0000\u0495&quot;+
		&quot;\u0496\u0001\u0000\u0000\u0000\u0496\u00b5\u0001\u0000\u0000\u0000\u0497&quot;+
		&quot;\u0495\u0001\u0000\u0000\u0000\u0498\u0499\u0005a\u0000\u0000\u0499\u049a&quot;+
		&quot;\u0003\u0098L\u0000\u049a\u00b7\u0001\u0000\u0000\u0000\u049b\u049c\u0005&quot;+
		&quot;L\u0000\u0000\u049c\u049e\u0003\u00ba]\u0000\u049d\u049f\u0005-\u0000&quot;+
		&quot;\u0000\u049e\u049d\u0001\u0000\u0000\u0000\u049e\u049f\u0001\u0000\u0000&quot;+
		&quot;\u0000\u049f\u04a0\u0001\u0000\u0000\u0000\u04a0\u04a1\u0005M\u0000\u0000&quot;+
		&quot;\u04a1\u00b9\u0001\u0000\u0000\u0000\u04a2\u04a7\u0003\u00bc^\u0000\u04a3&quot;+
		&quot;\u04a4\u0005-\u0000\u0000\u04a4\u04a6\u0003\u00bc^\u0000\u04a5\u04a3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04a6\u04a9\u0001\u0000\u0000\u0000\u04a7\u04a5\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04a7\u04a8\u0001\u0000\u0000\u0000\u04a8\u00bb\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04a9\u04a7\u0001\u0000\u0000\u0000\u04aa\u04ad\u0003&quot;+
		&quot;\u00be_\u0000\u04ab\u04ad\u0003\u00c0`\u0000\u04ac\u04aa\u0001\u0000\u0000&quot;+
		&quot;\u0000\u04ac\u04ab\u0001\u0000\u0000\u0000\u04ad\u00bd\u0001\u0000\u0000&quot;+
		&quot;\u0000\u04ae\u04b0\u0003\f\u0006\u0000\u04af\u04ae\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04b0\u04b3\u0001\u0000\u0000\u0000\u04b1\u04af\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04b1\u04b2\u0001\u0000\u0000\u0000\u04b2\u04b4\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04b3\u04b1\u0001\u0000\u0000\u0000\u04b4\u04b5\u0003^/\u0000\u04b5\u04b6&quot;+
		&quot;\u0003X,\u0000\u04b6\u04b7\u0005P\u0000\u0000\u04b7\u04b8\u0003\u00d6&quot;+
		&quot;k\u0000\u04b8\u00bf\u0001\u0000\u0000\u0000\u04b9\u04bb\u0003\u00c2a\u0000&quot;+
		&quot;\u04ba\u04b9\u0001\u0000\u0000\u0000\u04bb\u04be\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04bc\u04ba\u0001\u0000\u0000\u0000\u04bc\u04bd\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04bd\u04c1\u0001\u0000\u0000\u0000\u04be\u04bc\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04bf\u04c2\u0003\u0118\u008c\u0000\u04c0\u04c2\u0005N\u0000\u0000\u04c1&quot;+
		&quot;\u04bf\u0001\u0000\u0000\u0000\u04c1\u04c0\u0001\u0000\u0000\u0000\u04c2&quot;+
		&quot;\u00c1\u0001\u0000\u0000\u0000\u04c3\u04c4\u0003\u00d8l\u0000\u04c4\u04c5&quot;+
		&quot;\u0005;\u0000\u0000\u04c5\u00c3\u0001\u0000\u0000\u0000\u04c6\u04c8\u0003&quot;+
		&quot;\u00c6c\u0000\u04c7\u04c6\u0001\u0000\u0000\u0000\u04c8\u04c9\u0001\u0000&quot;+
		&quot;\u0000\u0000\u04c9\u04c7\u0001\u0000\u0000\u0000\u04c9\u04ca\u0001\u0000&quot;+
		&quot;\u0000\u0000\u04ca\u04cc\u0001\u0000\u0000\u0000\u04cb\u04cd\u0003\u009a&quot;+
		&quot;M\u0000\u04cc\u04cb\u0001\u0000\u0000\u0000\u04cd\u04ce\u0001\u0000\u0000&quot;+
		&quot;\u0000\u04ce\u04cc\u0001\u0000\u0000\u0000\u04ce\u04cf\u0001\u0000\u0000&quot;+
		&quot;\u0000\u04cf\u00c5\u0001\u0000\u0000\u0000\u04d0\u04d1\u0005]\u0000\u0000&quot;+
		&quot;\u04d1\u04d3\u0003\u00c8d\u0000\u04d2\u04d4\u0005R\u0000\u0000\u04d3\u04d2&quot;+
		&quot;\u0001\u0000\u0000\u0000\u04d3\u04d4\u0001\u0000\u0000\u0000\u04d4\u04da&quot;+
		&quot;\u0001\u0000\u0000\u0000\u04d5\u04d7\u0005^\u0000\u0000\u04d6\u04d8\u0005&quot;+
		&quot;R\u0000\u0000\u04d7\u04d6\u0001\u0000\u0000\u0000\u04d7\u04d8\u0001\u0000&quot;+
		&quot;\u0000\u0000\u04d8\u04da\u0001\u0000\u0000\u0000\u04d9\u04d0\u0001\u0000&quot;+
		&quot;\u0000\u0000\u04d9\u04d5\u0001\u0000\u0000\u0000\u04da\u00c7\u0001\u0000&quot;+
		&quot;\u0000\u0000\u04db\u04e0\u0003\u00cae\u0000\u04dc\u04dd\u0005J\u0000\u0000&quot;+
		&quot;\u04dd\u04df\u0003\u00cae\u0000\u04de\u04dc\u0001\u0000\u0000\u0000\u04df&quot;+
		&quot;\u04e2\u0001\u0000\u0000\u0000\u04e0\u04de\u0001\u0000\u0000\u0000\u04e0&quot;+
		&quot;\u04e1\u0001\u0000\u0000\u0000\u04e1\u00c9\u0001\u0000\u0000\u0000\u04e2&quot;+
		&quot;\u04e0\u0001\u0000\u0000\u0000\u04e3\u04e7\u0003\u010e\u0087\u0000\u04e4&quot;+
		&quot;\u04e7\u0003\u00d6k\u0000\u04e5\u04e7\u0005^\u0000\u0000\u04e6\u04e3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04e6\u04e4\u0001\u0000\u0000\u0000\u04e6\u04e5\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04e7\u00cb\u0001\u0000\u0000\u0000\u04e8\u04e9\u0005&quot;+
		&quot;L\u0000\u0000\u04e9\u04ea\u0003\u00d0h\u0000\u04ea\u04eb\u0005M\u0000&quot;+
		&quot;\u0000\u04eb\u04fa\u0001\u0000\u0000\u0000\u04ec\u04ee\u0005L\u0000\u0000&quot;+
		&quot;\u04ed\u04ef\u0003\u00ceg\u0000\u04ee\u04ed\u0001\u0000\u0000\u0000\u04ee&quot;+
		&quot;\u04ef\u0001\u0000\u0000\u0000\u04ef\u04f0\u0001\u0000\u0000\u0000\u04f0&quot;+
		&quot;\u04f2\u0005-\u0000\u0000\u04f1\u04f3\u0003\u00d6k\u0000\u04f2\u04f1\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04f2\u04f3\u0001\u0000\u0000\u0000\u04f3\u04f4\u0001&quot;+
		&quot;\u0000\u0000\u0000\u04f4\u04f6\u0005-\u0000\u0000\u04f5\u04f7\u0003\u00d4&quot;+
		&quot;j\u0000\u04f6\u04f5\u0001\u0000\u0000\u0000\u04f6\u04f7\u0001\u0000\u0000&quot;+
		&quot;\u0000\u04f7\u04f8\u0001\u0000\u0000\u0000\u04f8\u04fa\u0005M\u0000\u0000&quot;+
		&quot;\u04f9\u04e8\u0001\u0000\u0000\u0000\u04f9\u04ec\u0001\u0000\u0000\u0000&quot;+
		&quot;\u04fa\u00cd\u0001\u0000\u0000\u0000\u04fb\u04fe\u0003\u009cN\u0000\u04fc&quot;+
		&quot;\u04fe\u0003\u00d4j\u0000\u04fd\u04fb\u0001\u0000\u0000\u0000\u04fd\u04fc&quot;+
		&quot;\u0001\u0000\u0000\u0000\u04fe\u00cf\u0001\u0000\u0000\u0000\u04ff\u0501&quot;+
		&quot;\u0003\f\u0006\u0000\u0500\u04ff\u0001\u0000\u0000\u0000\u0501\u0504\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0502\u0500\u0001\u0000\u0000\u0000\u0502\u0503\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0503\u0505\u0001\u0000\u0000\u0000\u0504\u0502\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0505\u0506\u0003\u0100\u0080\u0000\u0506\u0507\u0003&quot;+
		&quot;X,\u0000\u0507\u0508\u0005R\u0000\u0000\u0508\u0509\u0003\u00d6k\u0000&quot;+
		&quot;\u0509\u00d1\u0001\u0000\u0000\u0000\u050a\u050b\u0005L\u0000\u0000\u050b&quot;+
		&quot;\u050c\u0003\u00d6k\u0000\u050c\u050d\u0005M\u0000\u0000\u050d\u00d3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u050e\u0513\u0003\u00d6k\u0000\u050f\u0510\u0005J\u0000&quot;+
		&quot;\u0000\u0510\u0512\u0003\u00d6k\u0000\u0511\u050f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0512\u0515\u0001\u0000\u0000\u0000\u0513\u0511\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0513\u0514\u0001\u0000\u0000\u0000\u0514\u00d5\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0515\u0513\u0001\u0000\u0000\u0000\u0516\u0517\u0003\u00d8l\u0000\u0517&quot;+
		&quot;\u00d7\u0001\u0000\u0000\u0000\u0518\u0519\u0006l\uffff\uffff\u0000\u0519&quot;+
		&quot;\u053e\u0003\u00e4r\u0000\u051a\u051b\u0003\u0118\u008c\u0000\u051b\u051d&quot;+
		&quot;\u0005L\u0000\u0000\u051c\u051e\u0003\u00d4j\u0000\u051d\u051c\u0001\u0000&quot;+
		&quot;\u0000\u0000\u051d\u051e\u0001\u0000\u0000\u0000\u051e\u051f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u051f\u0520\u0005M\u0000\u0000\u0520\u053e\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0521\u0522\u0005\u0088\u0000\u0000\u0522\u053e\u0003\u00e8t\u0000&quot;+
		&quot;\u0523\u0524\u0007\u0003\u0000\u0000\u0524\u053e\u0003\u00d8l\u0014\u0525&quot;+
		&quot;\u0526\u0007\u0004\u0000\u0000\u0526\u053e\u0003\u00d8l\u0013\u0527\u0528&quot;+
		&quot;\u0003\u0100\u0080\u0000\u0528\u052a\u0005\u00b3\u0000\u0000\u0529\u052b&quot;+
		&quot;\u0003\u0108\u0084\u0000\u052a\u0529\u0001\u0000\u0000\u0000\u052a\u052b&quot;+
		&quot;\u0001\u0000\u0000\u0000\u052b\u052e\u0001\u0000\u0000\u0000\u052c\u052f&quot;+
		&quot;\u0003\u0118\u008c\u0000\u052d\u052f\u0005\u0088\u0000\u0000\u052e\u052c&quot;+
		&quot;\u0001\u0000\u0000\u0000\u052e\u052d\u0001\u0000\u0000\u0000\u052f\u053e&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0530\u0531\u0003\u00e6s\u0000\u0531\u0533\u0005&quot;+
		&quot;\u00b3\u0000\u0000\u0532\u0534\u0003\u0108\u0084\u0000\u0533\u0532\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0533\u0534\u0001\u0000\u0000\u0000\u0534\u0535\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0535\u0536\u0005\u0088\u0000\u0000\u0536\u053e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0537\u0538\u0005L\u0000\u0000\u0538\u0539\u0003\u00da&quot;+
		&quot;m\u0000\u0539\u053a\u0005M\u0000\u0000\u053a\u053b\u0003\u00d8l\u000f&quot;+
		&quot;\u053b\u053e\u0001\u0000\u0000\u0000\u053c\u053e\u0003\u00dcn\u0000\u053d&quot;+
		&quot;\u0518\u0001\u0000\u0000\u0000\u053d\u051a\u0001\u0000\u0000\u0000\u053d&quot;+
		&quot;\u0521\u0001\u0000\u0000\u0000\u053d\u0523\u0001\u0000\u0000\u0000\u053d&quot;+
		&quot;\u0525\u0001\u0000\u0000\u0000\u053d\u0527\u0001\u0000\u0000\u0000\u053d&quot;+
		&quot;\u0530\u0001\u0000\u0000\u0000\u053d\u0537\u0001\u0000\u0000\u0000\u053d&quot;+
		&quot;\u053c\u0001\u0000\u0000\u0000\u053e\u05af\u0001\u0000\u0000\u0000\u053f&quot;+
		&quot;\u0540\n\u000e\u0000\u0000\u0540\u0541\u0007\u0005\u0000\u0000\u0541\u05ae&quot;+
		&quot;\u0003\u00d8l\u000f\u0542\u0543\n\r\u0000\u0000\u0543\u0544\u0007\u0006&quot;+
		&quot;\u0000\u0000\u0544\u05ae\u0003\u00d8l\u000e\u0545\u054d\n\f\u0000\u0000&quot;+
		&quot;\u0546\u0547\u0005u\u0000\u0000\u0547\u054e\u0005u\u0000\u0000\u0548\u0549&quot;+
		&quot;\u0005v\u0000\u0000\u0549\u054a\u0005v\u0000\u0000\u054a\u054e\u0005v&quot;+
		&quot;\u0000\u0000\u054b\u054c\u0005v\u0000\u0000\u054c\u054e\u0005v\u0000\u0000&quot;+
		&quot;\u054d\u0546\u0001\u0000\u0000\u0000\u054d\u0548\u0001\u0000\u0000\u0000&quot;+
		&quot;\u054d\u054b\u0001\u0000\u0000\u0000\u054e\u054f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u054f\u05ae\u0003\u00d8l\r\u0550\u0551\n\n\u0000\u0000\u0551\u0552\u0007&quot;+
		&quot;\u0007\u0000\u0000\u0552\u05ae\u0003\u00d8l\u000b\u0553\u0554\n\t\u0000&quot;+
		&quot;\u0000\u0554\u0555\u0007\b\u0000\u0000\u0555\u05ae\u0003\u00d8l\n\u0556&quot;+
		&quot;\u0557\n\b\u0000\u0000\u0557\u0558\u0005r\u0000\u0000\u0558\u05ae\u0003&quot;+
		&quot;\u00d8l\t\u0559\u055a\n\u0007\u0000\u0000\u055a\u055b\u0005q\u0000\u0000&quot;+
		&quot;\u055b\u05ae\u0003\u00d8l\b\u055c\u055d\n\u0006\u0000\u0000\u055d\u055e&quot;+
		&quot;\u0005p\u0000\u0000\u055e\u05ae\u0003\u00d8l\u0007\u055f\u0560\n\u0005&quot;+
		&quot;\u0000\u0000\u0560\u0561\u0005o\u0000\u0000\u0561\u05ae\u0003\u00d8l\u0006&quot;+
		&quot;\u0562\u0563\n\u0004\u0000\u0000\u0563\u0564\u0005n\u0000\u0000\u0564&quot;+
		&quot;\u05ae\u0003\u00d8l\u0005\u0565\u0566\n\u0003\u0000\u0000\u0566\u0567&quot;+
		&quot;\u0005m\u0000\u0000\u0567\u0568\u0003\u00d8l\u0000\u0568\u0569\u0005R&quot;+
		&quot;\u0000\u0000\u0569\u056a\u0003\u00d8l\u0003\u056a\u05ae\u0001\u0000\u0000&quot;+
		&quot;\u0000\u056b\u056c\n\u0002\u0000\u0000\u056c\u056d\u0007\t\u0000\u0000&quot;+
		&quot;\u056d\u05ae\u0003\u00d8l\u0002\u056e\u056f\n\u001e\u0000\u0000\u056f&quot;+
		&quot;\u0570\u0005;\u0000\u0000\u0570\u05ae\u0003\u0118\u008c\u0000\u0571\u0572&quot;+
		&quot;\n\u001d\u0000\u0000\u0572\u0573\u0005;\u0000\u0000\u0573\u0574\u0003&quot;+
		&quot;\u0118\u008c\u0000\u0574\u0576\u0005L\u0000\u0000\u0575\u0577\u0003\u00d4&quot;+
		&quot;j\u0000\u0576\u0575\u0001\u0000\u0000\u0000\u0576\u0577\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0577\u0578\u0001\u0000\u0000\u0000\u0578\u0579\u0005M\u0000\u0000&quot;+
		&quot;\u0579\u05ae\u0001\u0000\u0000\u0000\u057a\u057b\n\u001c\u0000\u0000\u057b&quot;+
		&quot;\u057c\u0005;\u0000\u0000\u057c\u05ae\u0005N\u0000\u0000\u057d\u057e\n&quot;+
		&quot;\u001b\u0000\u0000\u057e\u057f\u0005;\u0000\u0000\u057f\u0581\u0005\u0088&quot;+
		&quot;\u0000\u0000\u0580\u0582\u0003\u00fa}\u0000\u0581\u0580\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0581\u0582\u0001\u0000\u0000\u0000\u0582\u0583\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0583\u05ae\u0003\u00eew\u0000\u0584\u0585\n\u001a\u0000\u0000&quot;+
		&quot;\u0585\u0587\u0005;\u0000\u0000\u0586\u0588\u0003\u00fa}\u0000\u0587\u0586&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0587\u0588\u0001\u0000\u0000\u0000\u0588\u0589&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0589\u058b\u0005O\u0000\u0000\u058a\u058c\u0003&quot;+
		&quot;\u010a\u0085\u0000\u058b\u058a\u0001\u0000\u0000\u0000\u058b\u058c\u0001&quot;+
		&quot;\u0000\u0000\u0000\u058c\u05ae\u0001\u0000\u0000\u0000\u058d\u058e\n\u0019&quot;+
		&quot;\u0000\u0000\u058e\u058f\u0005;\u0000\u0000\u058f\u0590\u0003\u00fa}\u0000&quot;+
		&quot;\u0590\u0591\u0003\u0118\u008c\u0000\u0591\u0593\u0005L\u0000\u0000\u0592&quot;+
		&quot;\u0594\u0003\u00d4j\u0000\u0593\u0592\u0001\u0000\u0000\u0000\u0593\u0594&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0594\u0595\u0001\u0000\u0000\u0000\u0595\u0596&quot;+
		&quot;\u0005M\u0000\u0000\u0596\u05ae\u0001\u0000\u0000\u0000\u0597\u0598\n&quot;+
		&quot;\u0018\u0000\u0000\u0598\u0599\u0005/\u0000\u0000\u0599\u059a\u0003\u00d8&quot;+
		&quot;l\u0000\u059a\u059b\u00050\u0000\u0000\u059b\u05ae\u0001\u0000\u0000\u0000&quot;+
		&quot;\u059c\u059d\n\u0015\u0000\u0000\u059d\u05ae\u0007\n\u0000\u0000\u059e&quot;+
		&quot;\u059f\n\u0012\u0000\u0000\u059f\u05a1\u0005\u00b3\u0000\u0000\u05a0\u05a2&quot;+
		&quot;\u0003\u0108\u0084\u0000\u05a1\u05a0\u0001\u0000\u0000\u0000\u05a1\u05a2&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05a2\u05a5\u0001\u0000\u0000\u0000\u05a3\u05a6&quot;+
		&quot;\u0003\u0118\u008c\u0000\u05a4\u05a6\u0005\u0088\u0000\u0000\u05a5\u05a3&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05a5\u05a4\u0001\u0000\u0000\u0000\u05a6\u05ae&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05a7\u05a8\n\u000b\u0000\u0000\u05a8\u05ab\u0005&quot;+
		&quot;y\u0000\u0000\u05a9\u05ac\u0003\u0112\u0089\u0000\u05aa\u05ac\u0003\u0100&quot;+
		&quot;\u0080\u0000\u05ab\u05a9\u0001\u0000\u0000\u0000\u05ab\u05aa\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ac\u05ae\u0001\u0000\u0000\u0000\u05ad\u053f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u0542\u0001\u0000\u0000\u0000\u05ad\u0545\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u0550\u0001\u0000\u0000\u0000\u05ad\u0553\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u0556\u0001\u0000\u0000\u0000\u05ad\u0559\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u055c\u0001\u0000\u0000\u0000\u05ad\u055f\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u0562\u0001\u0000\u0000\u0000\u05ad\u0565\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u056b\u0001\u0000\u0000\u0000\u05ad\u056e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u0571\u0001\u0000\u0000\u0000\u05ad\u057a\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u057d\u0001\u0000\u0000\u0000\u05ad\u0584\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u058d\u0001\u0000\u0000\u0000\u05ad\u0597\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u059c\u0001\u0000\u0000\u0000\u05ad\u059e\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05ad\u05a7\u0001\u0000\u0000\u0000\u05ae\u05b1\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05af\u05ad\u0001\u0000\u0000\u0000\u05af\u05b0\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05b0\u00d9\u0001\u0000\u0000\u0000\u05b1\u05af\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05b2\u05b7\u0003\u0100\u0080\u0000\u05b3\u05b4\u0005r\u0000&quot;+
		&quot;\u0000\u05b4\u05b6\u0003\u0100\u0080\u0000\u05b5\u05b3\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05b6\u05b9\u0001\u0000\u0000\u0000\u05b7\u05b5\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05b7\u05b8\u0001\u0000\u0000\u0000\u05b8\u00db\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05b9\u05b7\u0001\u0000\u0000\u0000\u05ba\u05bb\u0003\u00deo\u0000&quot;+
		&quot;\u05bb\u05bc\u0005\u00b5\u0000\u0000\u05bc\u05bd\u0003\u00e2q\u0000\u05bd&quot;+
		&quot;\u00dd\u0001\u0000\u0000\u0000\u05be\u05c9\u0003\u0118\u008c\u0000\u05bf&quot;+
		&quot;\u05c1\u0005L\u0000\u0000\u05c0\u05c2\u0003h4\u0000\u05c1\u05c0\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05c1\u05c2\u0001\u0000\u0000\u0000\u05c2\u05c3\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05c3\u05c9\u0005M\u0000\u0000\u05c4\u05c5\u0005L\u0000&quot;+
		&quot;\u0000\u05c5\u05c6\u0003\u00e0p\u0000\u05c6\u05c7\u0005M\u0000\u0000\u05c7&quot;+
		&quot;\u05c9\u0001\u0000\u0000\u0000\u05c8\u05be\u0001\u0000\u0000\u0000\u05c8&quot;+
		&quot;\u05bf\u0001\u0000\u0000\u0000\u05c8\u05c4\u0001\u0000\u0000\u0000\u05c9&quot;+
		&quot;\u00df\u0001\u0000\u0000\u0000\u05ca\u05cf\u0003\u0118\u008c\u0000\u05cb&quot;+
		&quot;\u05cc\u0005J\u0000\u0000\u05cc\u05ce\u0003\u0118\u008c\u0000\u05cd\u05cb&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05ce\u05d1\u0001\u0000\u0000\u0000\u05cf\u05cd&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05cf\u05d0\u0001\u0000\u0000\u0000\u05d0\u00e1&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05d1\u05cf\u0001\u0000\u0000\u0000\u05d2\u05d5&quot;+
		&quot;\u0003\u00d6k\u0000\u05d3\u05d5\u0003\u0098L\u0000\u05d4\u05d2\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05d4\u05d3\u0001\u0000\u0000\u0000\u05d5\u00e3\u0001\u0000&quot;+
		&quot;\u0000\u0000\u05d6\u05f4\u0003\u00a2Q\u0000\u05d7\u05d8\u0005L\u0000\u0000&quot;+
		&quot;\u05d8\u05d9\u0003\u00d8l\u0000\u05d9\u05da\u0005M\u0000\u0000\u05da\u05f4&quot;+
		&quot;\u0001\u0000\u0000\u0000\u05db\u05f4\u0005N\u0000\u0000\u05dc\u05f4\u0005&quot;+
		&quot;O\u0000\u0000\u05dd\u05f4\u0003r9\u0000\u05de\u05f4\u0003\u0118\u008c&quot;+
		&quot;\u0000\u05df\u05e3\u0003^/\u0000\u05e0\u05e2\u0003\u0104\u0082\u0000\u05e1&quot;+
		&quot;\u05e0\u0001\u0000\u0000\u0000\u05e2\u05e5\u0001\u0000\u0000\u0000\u05e3&quot;+
		&quot;\u05e1\u0001\u0000\u0000\u0000\u05e3\u05e4\u0001\u0000\u0000\u0000\u05e4&quot;+
		&quot;\u05e6\u0001\u0000\u0000\u0000\u05e5\u05e3\u0001\u0000\u0000\u0000\u05e6&quot;+
		&quot;\u05e7\u0005;\u0000\u0000\u05e7\u05e8\u0005E\u0000\u0000\u05e8\u05f4\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05e9\u05ed\u0003\u0106\u0083\u0000\u05ea\u05ec\u0003&quot;+
		&quot;\u0104\u0082\u0000\u05eb\u05ea\u0001\u0000\u0000\u0000\u05ec\u05ef\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05ed\u05eb\u0001\u0000\u0000\u0000\u05ed\u05ee\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05ee\u05f0\u0001\u0000\u0000\u0000\u05ef\u05ed\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05f0\u05f1\u0005;\u0000\u0000\u05f1\u05f2\u0005E\u0000&quot;+
		&quot;\u0000\u05f2\u05f4\u0001\u0000\u0000\u0000\u05f3\u05d6\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05f3\u05d7\u0001\u0000\u0000\u0000\u05f3\u05db\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05f3\u05dc\u0001\u0000\u0000\u0000\u05f3\u05dd\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05f3\u05de\u0001\u0000\u0000\u0000\u05f3\u05df\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05f3\u05e9\u0001\u0000\u0000\u0000\u05f4\u00e5\u0001\u0000\u0000&quot;+
		&quot;\u0000\u05f5\u05f6\u0003^/\u0000\u05f6\u05f7\u0005;\u0000\u0000\u05f7&quot;+
		&quot;\u05f9\u0001\u0000\u0000\u0000\u05f8\u05f5\u0001\u0000\u0000\u0000\u05f8&quot;+
		&quot;\u05f9\u0001\u0000\u0000\u0000\u05f9\u05fa\u0001\u0000\u0000\u0000\u05fa&quot;+
		&quot;\u05fb\u0003z=\u0000\u05fb\u05fd\u0003\u0118\u008c\u0000\u05fc\u05fe\u0003&quot;+
		&quot;\u0108\u0084\u0000\u05fd\u05fc\u0001\u0000\u0000\u0000\u05fd\u05fe\u0001&quot;+
		&quot;\u0000\u0000\u0000\u05fe\u00e7\u0001\u0000\u0000\u0000\u05ff\u0600\u0003&quot;+
		&quot;\u00fa}\u0000\u0600\u0601\u0003\u00eau\u0000\u0601\u0602\u0003\u00f4z&quot;+
		&quot;\u0000\u0602\u060c\u0001\u0000\u0000\u0000\u0603\u0604\u0003z=\u0000\u0604&quot;+
		&quot;\u0609\u0003\u00eau\u0000\u0605\u0606\u0003z=\u0000\u0606\u0607\u0003&quot;+
		&quot;\u00f0x\u0000\u0607\u060a\u0001\u0000\u0000\u0000\u0608\u060a\u0003\u00f4&quot;+
		&quot;z\u0000\u0609\u0605\u0001\u0000\u0000\u0000\u0609\u0608\u0001\u0000\u0000&quot;+
		&quot;\u0000\u060a\u060c\u0001\u0000\u0000\u0000\u060b\u05ff\u0001\u0000\u0000&quot;+
		&quot;\u0000\u060b\u0603\u0001\u0000\u0000\u0000\u060c\u00e9\u0001\u0000\u0000&quot;+
		&quot;\u0000\u060d\u060e\u0003z=\u0000\u060e\u0610\u0003\u0118\u008c\u0000\u060f&quot;+
		&quot;\u0611\u0003\u00f6{\u0000\u0610\u060f\u0001\u0000\u0000\u0000\u0610\u0611&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0611\u0615\u0001\u0000\u0000\u0000\u0612\u0614&quot;+
		&quot;\u0003\u00ecv\u0000\u0613\u0612\u0001\u0000\u0000\u0000\u0614\u0617\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0615\u0613\u0001\u0000\u0000\u0000\u0615\u0616\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0616\u061a\u0001\u0000\u0000\u0000\u0617\u0615\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0618\u061a\u0003\u0106\u0083\u0000\u0619\u060d\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0619\u0618\u0001\u0000\u0000\u0000\u061a\u00eb\u0001&quot;+
		&quot;\u0000\u0000\u0000\u061b\u061c\u0005;\u0000\u0000\u061c\u061d\u0003z=&quot;+
		&quot;\u0000\u061d\u061f\u0003\u0118\u008c\u0000\u061e\u0620\u0003\u00f6{\u0000&quot;+
		&quot;\u061f\u061e\u0001\u0000\u0000\u0000\u061f\u0620\u0001\u0000\u0000\u0000&quot;+
		&quot;\u0620\u00ed\u0001\u0000\u0000\u0000\u0621\u0622\u0003z=\u0000\u0622\u0624&quot;+
		&quot;\u0003\u0118\u008c\u0000\u0623\u0625\u0003\u00f8|\u0000\u0624\u0623\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0624\u0625\u0001\u0000\u0000\u0000\u0625\u0626\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0626\u0627\u0003\u00f4z\u0000\u0627\u00ef\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0628\u063f\u0005/\u0000\u0000\u0629\u062d\u00050\u0000\u0000&quot;+
		&quot;\u062a\u062c\u0003\u0104\u0082\u0000\u062b\u062a\u0001\u0000\u0000\u0000&quot;+
		&quot;\u062c\u062f\u0001\u0000\u0000\u0000\u062d\u062b\u0001\u0000\u0000\u0000&quot;+
		&quot;\u062d\u062e\u0001\u0000\u0000\u0000\u062e\u0630\u0001\u0000\u0000\u0000&quot;+
		&quot;\u062f\u062d\u0001\u0000\u0000\u0000\u0630\u0640\u0003\\.\u0000\u0631&quot;+
		&quot;\u0632\u0003\u00d6k\u0000\u0632\u0636\u00050\u0000\u0000\u0633\u0635\u0003&quot;+
		&quot;\u00f2y\u0000\u0634\u0633\u0001\u0000\u0000\u0000\u0635\u0638\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0636\u0634\u0001\u0000\u0000\u0000\u0636\u0637\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0637\u063c\u0001\u0000\u0000\u0000\u0638\u0636\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0639\u063b\u0003\u0104\u0082\u0000\u063a\u0639\u0001\u0000&quot;+
		&quot;\u0000\u0000\u063b\u063e\u0001\u0000\u0000\u0000\u063c\u063a\u0001\u0000&quot;+
		&quot;\u0000\u0000\u063c\u063d\u0001\u0000\u0000\u0000\u063d\u0640\u0001\u0000&quot;+
		&quot;\u0000\u0000\u063e\u063c\u0001\u0000\u0000\u0000\u063f\u0629\u0001\u0000&quot;+
		&quot;\u0000\u0000\u063f\u0631\u0001\u0000\u0000\u0000\u0640\u00f1\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0641\u0642\u0003z=\u0000\u0642\u0643\u0005/\u0000\u0000&quot;+
		&quot;\u0643\u0644\u0003\u00d6k\u0000\u0644\u0645\u00050\u0000\u0000\u0645\u00f3&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0646\u0648\u0003\u010c\u0086\u0000\u0647\u0649&quot;+
		&quot;\u0003&lt;\u001e\u0000\u0648\u0647\u0001\u0000\u0000\u0000\u0648\u0649\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0649\u00f5\u0001\u0000\u0000\u0000\u064a\u064b\u0005&quot;+
		&quot;u\u0000\u0000\u064b\u064e\u0005v\u0000\u0000\u064c\u064e\u0003\u0108\u0084&quot;+
		&quot;\u0000\u064d\u064a\u0001\u0000\u0000\u0000\u064d\u064c\u0001\u0000\u0000&quot;+
		&quot;\u0000\u064e\u00f7\u0001\u0000\u0000\u0000\u064f\u0650\u0005u\u0000\u0000&quot;+
		&quot;\u0650\u0653\u0005v\u0000\u0000\u0651\u0653\u0003\u00fa}\u0000\u0652\u064f&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0652\u0651\u0001\u0000\u0000\u0000\u0653\u00f9&quot;+
		&quot;\u0001\u0000\u0000\u0000\u0654\u0655\u0005u\u0000\u0000\u0655\u0656\u0003&quot;+
		&quot;\u00fc~\u0000\u0656\u0657\u0005v\u0000\u0000\u0657\u00fb\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0658\u065d\u0003\u0100\u0080\u0000\u0659\u065a\u0005J\u0000\u0000&quot;+
		&quot;\u065a\u065c\u0003\u0100\u0080\u0000\u065b\u0659\u0001\u0000\u0000\u0000&quot;+
		&quot;\u065c\u065f\u0001\u0000\u0000\u0000\u065d\u065b\u0001\u0000\u0000\u0000&quot;+
		&quot;\u065d\u065e\u0001\u0000\u0000\u0000\u065e\u00fd\u0001\u0000\u0000\u0000&quot;+
		&quot;\u065f\u065d\u0001\u0000\u0000\u0000\u0660\u0665\u0003\u0100\u0080\u0000&quot;+
		&quot;\u0661\u0662\u0005J\u0000\u0000\u0662\u0664\u0003\u0100\u0080\u0000\u0663&quot;+
		&quot;\u0661\u0001\u0000\u0000\u0000\u0664\u0667\u0001\u0000\u0000\u0000\u0665&quot;+
		&quot;\u0663\u0001\u0000\u0000\u0000\u0665\u0666\u0001\u0000\u0000\u0000\u0666&quot;+
		&quot;\u00ff\u0001\u0000\u0000\u0000\u0667\u0665\u0001\u0000\u0000\u0000\u0668&quot;+
		&quot;\u0669\u0003z=\u0000\u0669\u066d\u0003\u0102\u0081\u0000\u066a\u066c\u0003&quot;+
		&quot;\u0104\u0082\u0000\u066b\u066a\u0001\u0000\u0000\u0000\u066c\u066f\u0001&quot;+
		&quot;\u0000\u0000\u0000\u066d\u066b\u0001\u0000\u0000\u0000\u066d\u066e\u0001&quot;+
		&quot;\u0000\u0000\u0000\u066e\u0101\u0001\u0000\u0000\u0000\u066f\u066d\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0670\u0673\u0003^/\u0000\u0671\u0673\u0003\u0106\u0083&quot;+
		&quot;\u0000\u0672\u0670\u0001\u0000\u0000\u0000\u0672\u0671\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0673\u0103\u0001\u0000\u0000\u0000\u0674\u0675\u0003z=\u0000\u0675&quot;+
		&quot;\u0676\u0005/\u0000\u0000\u0676\u0677\u00050\u0000\u0000\u0677\u0105\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0678\u0679\u0007\u000b\u0000\u0000\u0679\u0107\u0001&quot;+
		&quot;\u0000\u0000\u0000\u067a\u067b\u0005u\u0000\u0000\u067b\u0680\u0003b1&quot;+
		&quot;\u0000\u067c\u067d\u0005J\u0000\u0000\u067d\u067f\u0003b1\u0000\u067e&quot;+
		&quot;\u067c\u0001\u0000\u0000\u0000\u067f\u0682\u0001\u0000\u0000\u0000\u0680&quot;+
		&quot;\u067e\u0001\u0000\u0000\u0000\u0680\u0681\u0001\u0000\u0000\u0000\u0681&quot;+
		&quot;\u0683\u0001\u0000\u0000\u0000\u0682\u0680\u0001\u0000\u0000\u0000\u0683&quot;+
		&quot;\u0684\u0005v\u0000\u0000\u0684\u0109\u0001\u0000\u0000\u0000\u0685\u0687&quot;+
		&quot;\u0005L\u0000\u0000\u0686\u0688\u0003\u00d4j\u0000\u0687\u0686\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0687\u0688\u0001\u0000\u0000\u0000\u0688\u0689\u0001\u0000&quot;+
		&quot;\u0000\u0000\u0689\u0694\u0005M\u0000\u0000\u068a\u068b\u0005;\u0000\u0000&quot;+
		&quot;\u068b\u0691\u0003\u0118\u008c\u0000\u068c\u068e\u0005L\u0000\u0000\u068d&quot;+
		&quot;\u068f\u0003\u00d4j\u0000\u068e\u068d\u0001\u0000\u0000\u0000\u068e\u068f&quot;+
		&quot;\u0001\u0000\u0000\u0000\u068f\u0690\u0001\u0000\u0000\u0000\u0690\u0692&quot;+
		&quot;\u0005M\u0000\u0000\u0691\u068c\u0001\u0000\u0000\u0000\u0691\u0692\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0692\u0694\u0001\u0000\u0000\u0000\u0693\u0685\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0693\u068a\u0001\u0000\u0000\u0000\u0694\u010b\u0001&quot;+
		&quot;\u0000\u0000\u0000\u0695\u0697\u0005L\u0000\u0000\u0696\u0698\u0003\u00d4&quot;+
		&quot;j\u0000\u0697\u0696\u0001\u0000\u0000\u0000\u0697\u0698\u0001\u0000\u0000&quot;+
		&quot;\u0000\u0698\u0699\u0001\u0000\u0000\u0000\u0699\u069a\u0005M\u0000\u0000&quot;+
		&quot;\u069a\u010d\u0001\u0000\u0000\u0000\u069b\u069e\u0003\u0110\u0088\u0000&quot;+
		&quot;\u069c\u069e\u0003\u0112\u0089\u0000\u069d\u069b\u0001\u0000\u0000\u0000&quot;+
		&quot;\u069d\u069c\u0001\u0000\u0000\u0000\u069e\u010f\u0001\u0000\u0000\u0000&quot;+
		&quot;\u069f\u06a0\u0003\u0112\u0089\u0000\u06a0\u06a1\u0005o\u0000\u0000\u06a1&quot;+
		&quot;\u06a2\u0003\u00d8l\u0000\u06a2\u0111\u0001\u0000\u0000\u0000\u06a3\u06ac&quot;+
		&quot;\u0003\u0114\u008a\u0000\u06a4\u06a7\u0005L\u0000\u0000\u06a5\u06a8\u0003&quot;+
		&quot;\u0110\u0088\u0000\u06a6\u06a8\u0003\u0112\u0089\u0000\u06a7\u06a5\u0001&quot;+
		&quot;\u0000\u0000\u0000\u06a7\u06a6\u0001\u0000\u0000\u0000\u06a8\u06a9\u0001&quot;+
		&quot;\u0000\u0000\u0000\u06a9\u06aa\u0005M\u0000\u0000\u06aa\u06ac\u0001\u0000&quot;+
		&quot;\u0000\u0000\u06ab\u06a3\u0001\u0000\u0000\u0000\u06ab\u06a4\u0001\u0000&quot;+
		&quot;\u0000\u0000\u06ac\u0113\u0001\u0000\u0000\u0000\u06ad\u06af\u0003\n\u0005&quot;+
		&quot;\u0000\u06ae\u06ad\u0001\u0000\u0000\u0000\u06af\u06b2\u0001\u0000\u0000&quot;+
		&quot;\u0000\u06b0\u06ae\u0001\u0000\u0000\u0000\u06b0\u06b1\u0001\u0000\u0000&quot;+
		&quot;\u0000\u06b1\u06b3\u0001\u0000\u0000\u0000\u06b2\u06b0\u0001\u0000\u0000&quot;+
		&quot;\u0000\u06b3\u06b4\u0003\u0100\u0080\u0000\u06b4\u06b5\u0003\u0118\u008c&quot;+
		&quot;\u0000\u06b5\u0115\u0001\u0000\u0000\u0000\u06b6\u06b7\u0005\u00d3\u0000&quot;+
		&quot;\u0000\u06b7\u06bc\u0003^/\u0000\u06b8\u06b9\u0005J\u0000\u0000\u06b9&quot;+
		&quot;\u06bb\u0003^/\u0000\u06ba\u06b8\u0001\u0000\u0000\u0000\u06bb\u06be\u0001&quot;+
		&quot;\u0000\u0000\u0000\u06bc\u06ba\u0001\u0000\u0000\u0000\u06bc\u06bd\u0001&quot;+
		&quot;\u0000\u0000\u0000\u06bd\u0117\u0001\u0000\u0000\u0000\u06be\u06bc\u0001&quot;+
		&quot;\u0000\u0000\u0000\u06bf\u06c0\u0007\f\u0000\u0000\u06c0\u0119\u0001\u0000&quot;+
		&quot;\u0000\u0000\u00cf\u011b\u0120\u0126\u0132\u0137\u013c\u0141\u0148\u014a&quot;+
		&quot;\u0151\u0162\u0166\u016b\u016e\u0171\u0174\u017b\u017f\u0185\u018e\u0193&quot;+
		&quot;\u0196\u01a5\u01ac\u01b1\u01c3\u01cb\u01d6\u01de\u01e4\u01ea\u01ed\u01f0&quot;+
		&quot;\u01f9\u01ff\u0202\u0208\u020e\u0211\u0214\u021f\u0228\u022f\u0235\u0239&quot;+
		&quot;\u0243\u0246\u024e\u0252\u0258\u025e\u0263\u026e\u0273\u027c\u027f\u0287&quot;+
		&quot;\u028b\u0294\u029b\u02a0\u02a6\u02a8\u02ad\u02b2\u02ba\u02bd\u02c0\u02c7&quot;+
		&quot;\u02cc\u02d3\u02da\u02dd\u02df\u02e9\u02ee\u02f7\u02fc\u02ff\u0304\u030d&quot;+
		&quot;\u0319\u0328\u0335\u033d\u0340\u0347\u0351\u0359\u035c\u035f\u036c\u0374&quot;+
		&quot;\u0379\u037e\u0387\u038b\u038f\u0393\u0397\u0399\u03a1\u03a5\u03ae\u03b3&quot;+
		&quot;\u03b9\u03c2\u03c8\u03ce\u03d9\u03de\u03e7\u03ee\u03f1\u03f8\u0400\u0415&quot;+
		&quot;\u0418\u041b\u0423\u0427\u0434\u043d\u0442\u044d\u045a\u045f\u0465\u0468&quot;+
		&quot;\u046d\u048a\u0495\u049e\u04a7\u04ac\u04b1\u04bc\u04c1\u04c9\u04ce\u04d3&quot;+
		&quot;\u04d7\u04d9\u04e0\u04e6\u04ee\u04f2\u04f6\u04f9\u04fd\u0502\u0513\u051d&quot;+
		&quot;\u052a\u052e\u0533\u053d\u054d\u0576\u0581\u0587\u058b\u0593\u05a1\u05a5&quot;+
		&quot;\u05ab\u05ad\u05af\u05b7\u05c1\u05c8\u05cf\u05d4\u05e3\u05ed\u05f3\u05f8&quot;+
		&quot;\u05fd\u0609\u060b\u0610\u0615\u0619\u061f\u0624\u062d\u0636\u063c\u063f&quot;+
		&quot;\u0648\u064d\u0652\u065d\u0665\u066d\u0672\u0680\u0687\u068e\u0691\u0693&quot;+
		&quot;\u0697\u069d\u06a7\u06ab\u06b0\u06bc&quot;;
<span class="fc" id="L13340">	public static final ATN _ATN =</span>
<span class="fc" id="L13341">		new ATNDeserializer().deserialize(_serializedATN.toCharArray());</span>
	static {
<span class="fc" id="L13343">		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];</span>
<span class="fc bfc" id="L13344" title="All 2 branches covered.">		for (int i = 0; i &lt; _ATN.getNumberOfDecisions(); i++) {</span>
<span class="fc" id="L13345">			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);</span>
		}
<span class="fc" id="L13347">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>